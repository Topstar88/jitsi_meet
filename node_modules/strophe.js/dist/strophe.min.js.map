{"version":3,"sources":["webpack://strophe/webpack/universalModuleDefinition","webpack://strophe/webpack/bootstrap","webpack://strophe/./src/md5.js","webpack://strophe/./src/sha1.js","webpack://strophe/./src/utils.js","webpack://strophe/./src/core.js","webpack://strophe/./src/strophe.js","webpack://strophe/(webpack)/buildin/global.js","webpack://strophe/./src/bosh.js","webpack://strophe/./src/websocket.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","safe_add","x","y","lsw","str2binl","str","Error","bin","length","charCodeAt","md5_cmn","q","a","b","num","cnt","bit_rol","md5_ff","md5_gg","md5_hh","md5_ii","core_md5","len","olda","oldb","oldc","oldd","MD5","hexdigest","binarray","charAt","binl2hex","hash","String","fromCharCode","binl2str","core_sha1","j","olde","w","Array","e","rol","sha1_safe_add","sha1_ft","sha1_kt","core_hmac_sha1","data","bkey","str2binb","ipad","opad","concat","binb2b64","triplet","binb2str","SHA1","b64_hmac_sha1","b64_sha1","str_hmac_sha1","str_sha1","utils","out","cookies","cookieName","expires","domain","path","cookieObj","isObj","_typeof","cookieValue","escape","unescape","document","cookie","$build","attrs","Strophe","Builder","$iq","$pres","VERSION","NS","HTTPBIND","BOSH","CLIENT","AUTH","ROSTER","PROFILE","DISCO_INFO","DISCO_ITEMS","MUC","SASL","STREAM","FRAMING","BIND","SESSION","STANZAS","XHTML_IM","XHTML","tags","attributes","blockquote","br","cite","em","img","li","ol","span","strong","ul","body","css","validTag","tag","validAttribute","attribute","validCSS","style","Status","ERROR","CONNECTING","CONNFAIL","AUTHENTICATING","AUTHFAIL","CONNECTED","DISCONNECTED","DISCONNECTING","ATTACHED","REDIRECT","CONNTIMEOUT","ErrorCondition","BAD_FORMAT","CONFLICT","MISSING_JID_NODE","NO_AUTH_MECH","UNKNOWN_REASON","LogLevel","DEBUG","INFO","WARN","FATAL","ElementType","NORMAL","TEXT","CDATA","FRAGMENT","TIMEOUT","SECONDARY_TIMEOUT","addNamespace","forEachChild","elem","elemName","func","childNodes","childNode","nodeType","this","isTagEqual","el","tagName","_xmlGenerator","_makeGenerator","doc","undefined","implementation","createDocument","documentMode","_getIEXmlDom","appendChild","createElement","xmlGenerator","docStrings","ActiveXObject","xmlElement","node","arguments","arg","xmlTextNode","core_typeof","sort","attr","setAttribute","k","xmlescape","text","replace","xmlunescape","createTextNode","xmlHtmlNode","html","DOMParser","parseFromString","async","loadXML","getText","nodeValue","copyElement","nodeName","createHtml","toLowerCase","getAttribute","cssText","cssAttrs","split","cssName","cssValue","push","join","createDocumentFragment","escapeNode","unescapeNode","getNodeFromJid","jid","indexOf","getDomainFromJid","bare","getBareJidFromJid","parts","splice","getResourceFromJid","_handleError","stack","fatal","sourceURL","handler","line","message","fileName","lineNumber","log","level","msg","console","error","debug","info","warn","serialize","tree","names","_toConsumableArray","keys","map","result","reduce","getNamedItem","child","_requestId","_connectionPlugins","addConnectionPlugin","ptype","xmlns","nodeTree","toString","up","parentNode","moreattrs","removeAttribute","cnode","impNode","xmlGen","importNode","newElem","h","fragment","innerHTML","xhtml","Handler","type","id","from","options","matchBareFromJid","ignoreNamespaceFragment","matchBare","user","getNamespace","elNamespace","namespaceMatch","_this","nsMatch","isMatch","elem_type","isArray","run","TimedHandler","period","lastCalled","Date","getTime","reset","Connection","service","_this2","proto","protocol","_proto","Websocket","Bosh","features","_sasl_data","do_session","do_bind","timedHandlers","handlers","removeTimeds","removeHandlers","addTimeds","addHandlers","protocolErrorHandlers","HTTP","websocket","_idleTimeout","_disconnectTimeout","authenticated","connected","disconnecting","do_authentication","paused","restored","_data","_uniqueId","_sasl_success_handler","_sasl_failure_handler","_sasl_challenge_handler","maxRetries","setTimeout","_onIdle","registerSASLMechanisms","mechanisms","F","init","_reset","_requests","pause","resume","getUniqueId","suffix","uuid","Math","random","addProtocolErrorHandler","status_code","callback","connect","pass","wait","hold","route","authcid","authzid","servtype","connect_callback","_changeConnectStatus","_connect","attach","sid","rid","wind","_attach","restore","_sessionCachingSupported","_restore","JSON","sessionStorage","setItem","removeItem","xmlInput","xmlOutput","rawInput","rawOutput","nextValidRid","send","_queueData","_send","flush","clearTimeout","sendPresence","errback","timeout","_this3","timeoutHandler","addHandler","stanza","deleteTimedHandler","addTimedHandler","deleteHandler","sendIQ","_this4","iqtype","element","_sendRestart","_this5","thand","handRef","hand","SASLAnonymous","SASLExternal","SASLMD5","SASLOAuthBearer","SASLXOAuth2","SASLPlain","SASLSHA1","forEach","registerSASLMechanism","mechanism","disconnect","reason","pres","_addSysTimedHandler","_onDisconnectTimeout","_disconnect","_abortAllRequests","_doDisconnect","status","condition","plugin","statusChanged","err","_dataRecv","req","raw","_this6","_reqToData","strip","pop","_emptyQueue","cond","conflict","getElementsByTagName","UNKOWN_REASON","newList","_connect_cb","_callback","bodyWrap","getElementsByTagNameNS","matched","mech","authenticate","_no_auth_received","sortMechanismsByPriority","higher","priority","swap","_attemptSASLAuth","mechanism_found","test","_addSysHandler","_sasl_success_cb","_sasl_failure_cb","_sasl_challenge_cb","_sasl_mechanism","onStart","request_auth_exchange","isClientFirst","response","onChallenge","btoa","_attemptLegacyAuth","_auth1_cb","to","challenge","atob","iq","_auth2_cb","_this7","serverSignature","matches","match","onSuccess","streamfeature_handlers","wrapper","_sasl_auth1_cb","_sasl_bind_cb","resource","jidNode","_sasl_session_cb","onFailure","_this8","now","SASLMechanism","connection","_connection","auth_str","test_cnonce","cnonce","nonce","salt","iter","Hi","U","U_old","responseText","authMessage","attribMatch","substr","clientKey","serverKey","clientSignature","_quote","realm","host","digest_uri","cred","A1","A2","__webpack_exports__","$msg","global","core__WEBPACK_IMPORTED_MODULE_0__","g","Function","eval","Request","sends","xmlData","origFunc","date","NaN","abort","dead","age","timeDead","xhr","_newXHR","getResponse","responseXML","documentElement","querySelector","textContent","XMLHttpRequest","overrideMimeType","onreadystatechange","_conn","floor","errors","inactivity","lastResponseHeaders","_buildBody","keepalive","_cacheSession","xml:lang","content","ver","xmpp:version","xmlns:xmpp","_onRequestStateChange","_throttledRequestHandler","session","parse","getItem","stringify","typ","parseInt","_sendTerminate","_callProtocolErrorHandlers","reqStatus","_getRequestStatus","err_callback","_hitError","xmpp:restart","time_elapsed","def","readyState","getAllResponseHeaders","valid_request","too_many_retries","_removeRequest","reqIs0","_restartRequest","Number","_processRequest","primary_timeout","isNaN","secondary_timeout","server_error","content_type","contentType","open","sync","setRequestHeader","withCredentials","e2","sendFunc","customHeaders","headers","header","backoff","min","pow","abs","new_service","location","pathname","_buildStream","version","_check_streamerror","connectstatus","errorString","_closeSocket","socket","WebSocket","onopen","_onOpen","onerror","_onError","onclose","_onClose","onmessage","_connect_cb_wrapper","_handleStreamStart","streamStart","parsedMessage","see_uri","string","_streamWrap","_onMessage","CLOSED","close","closeString","code","rawStanza","search","firstChild","start","startString"],"mappings":"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","file":"strophe.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"strophe\"] = factory();\n\telse\n\t\troot[\"strophe\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n/*\n * Everything that isn't used by Strophe has been stripped here!\n */\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nconst safe_add = function (x, y) {\n    const lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n};\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nconst bit_rol = function (num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n};\n\n/*\n * Convert a string to an array of little-endian words\n */\nconst str2binl = function (str) {\n    if (typeof str !== \"string\") {\n        throw new Error(\"str2binl was passed a non-string\");\n    }\n    const bin = [];\n    for(let i = 0; i < str.length * 8; i += 8)\n    {\n        bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);\n    }\n    return bin;\n};\n\n/*\n * Convert an array of little-endian words to a string\n */\nconst binl2str = function (bin) {\n    let str = \"\";\n    for(let i = 0; i < bin.length * 32; i += 8)\n    {\n        str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);\n    }\n    return str;\n};\n\n/*\n * Convert an array of little-endian words to a hex string.\n */\nconst binl2hex = function (binarray) {\n    const hex_tab = \"0123456789abcdef\";\n    let str = \"\";\n    for(let i = 0; i < binarray.length * 4; i++)\n    {\n        str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n            hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n    }\n    return str;\n};\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nconst md5_cmn = function (q, a, b, x, s, t) {\n    return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);\n};\n\nconst md5_ff = function (a, b, c, d, x, s, t) {\n    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n};\n\nconst md5_gg = function (a, b, c, d, x, s, t) {\n    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n};\n\nconst md5_hh = function (a, b, c, d, x, s, t) {\n    return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n};\n\nconst md5_ii = function (a, b, c, d, x, s, t) {\n    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n};\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n */\nconst core_md5 = function (x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << ((len) % 32);\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n    let a =  1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d =  271733878;\n\n    let olda, oldb, oldc, oldd;\n    for (let i = 0; i < x.length; i += 16)\n    {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n\n        a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n        d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n        c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n        b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n        a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n        d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n        c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n        b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n        a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n        d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n        c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n        b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n        a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n        d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n        c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n        b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n        a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n        d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n        c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n        b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n        a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n        d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n        c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n        b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n        a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n        d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n        c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n        b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n        a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n        d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n        c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n        b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n        a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n        d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n        c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n        b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n        a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n        d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n        c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n        b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n        a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n        d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n        c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n        b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n        a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n        d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n        c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n        b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n        a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n        d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n        c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n        b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n        a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n        d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n        c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n        b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n        a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n        d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n        c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n        b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n        a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n        d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n        c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n        b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n        a = safe_add(a, olda);\n        b = safe_add(b, oldb);\n        c = safe_add(c, oldc);\n        d = safe_add(d, oldd);\n    }\n    return [a, b, c, d];\n};\n\n/*\n * These are the functions you'll usually want to call.\n * They take string arguments and return either hex or base-64 encoded\n * strings.\n */\nconst MD5 = {\n    hexdigest: function (s) {\n        return binl2hex(core_md5(str2binl(s), s.length * 8));\n    },\n    hash: function (s) {\n        return binl2str(core_md5(str2binl(s), s.length * 8));\n    }\n};\nexport { MD5 as default };\n","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: false */\n/* global define */\n\n/* Some functions and variables have been stripped for use with Strophe */\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << (24 - len % 32);\n    x[((len + 64 >> 9) << 4) + 15] = len;\n\n    var w = new Array(80);\n    var a =  1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d =  271733878;\n    var e = -1009589776;\n\n    var i, j, t, olda, oldb, oldc, oldd, olde;\n    for (i = 0; i < x.length; i += 16) {\n        olda = a;\n        oldb = b;\n        oldc = c;\n        oldd = d;\n        olde = e;\n\n        for (j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = x[i + j];\n            } else {\n                w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n            }\n\n            t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                         safe_add(safe_add(e, w[j]), sha1_kt(j)));\n            e = d;\n            d = c;\n            c = rol(b, 30);\n            b = a;\n            a = t;\n        }\n\n        a = safe_add(a, olda);\n        b = safe_add(b, oldb);\n        c = safe_add(c, oldc);\n        d = safe_add(d, oldd);\n        e = safe_add(e, olde);\n    }\n    return [a, b, c, d, e];\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft (t, b, c, d) {\n    if (t < 20) { return (b & c) | ((~b) & d); }\n    if (t < 40) { return b ^ c ^ d; }\n    if (t < 60) { return (b & c) | (b & d) | (c & d); }\n    return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t) {\n    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 : (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data) {\n    var bkey = str2binb(key);\n    if (bkey.length > 16) {\n        bkey = core_sha1(bkey, key.length * 8);\n    }\n\n    var ipad = new Array(16), opad = new Array(16);\n    for (var i = 0; i < 16; i++) {\n        ipad[i] = bkey[i] ^ 0x36363636;\n        opad[i] = bkey[i] ^ 0x5C5C5C5C;\n    }\n\n    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n    return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str) {\n    var bin = [];\n    var mask = 255;\n    for (var i = 0; i < str.length * 8; i += 8) {\n        bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);\n    }\n    return bin;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64 (binarray) {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var str = \"\";\n    var triplet, j;\n    for (var i = 0; i < binarray.length * 4; i += 3) {\n        triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |\n                  (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |\n                  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n\n        for (j = 0; j < 4; j++) {\n            if (i * 8 + j * 6 > binarray.length * 32) { str += \"=\"; }\n            else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }\n        }\n    }\n    return str;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin) {\n    var str = \"\";\n    var mask = 255;\n    for (var i = 0; i < bin.length * 32; i += 8) {\n        str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);\n    }\n    return str;\n}\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nconst SHA1 = {\n    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },\n    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },\n    binb2str:       binb2str,\n    core_hmac_sha1: core_hmac_sha1,\n    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },\n    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },\n};\nexport { SHA1 as default };\n","const utils = {\n\n    utf16to8: function (str) {\n        var i, c;\n        var out = \"\";\n        var len = str.length;\n        for (i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0000) && (c <= 0x007F)) {\n                out += str.charAt(i);\n            } else if (c > 0x07FF) {\n                out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));\n                out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n            } else {\n                out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));\n                out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n            }\n        }\n        return out;\n    },\n\n    addCookies: function (cookies) {\n        /* Parameters:\n         *  (Object) cookies - either a map of cookie names\n         *    to string values or to maps of cookie values.\n         *\n         * For example:\n         * { \"myCookie\": \"1234\" }\n         *\n         * or:\n         * { \"myCookie\": {\n         *      \"value\": \"1234\",\n         *      \"domain\": \".example.org\",\n         *      \"path\": \"/\",\n         *      \"expires\": expirationDate\n         *      }\n         *  }\n         *\n         *  These values get passed to Strophe.Connection via\n         *   options.cookies\n         */\n        cookies = cookies || {};\n        for (const cookieName in cookies) {\n            if (Object.prototype.hasOwnProperty.call(cookies, cookieName)) {\n                let expires = '';\n                let domain = '';\n                let path = '';\n                const cookieObj = cookies[cookieName];\n                const isObj = typeof cookieObj === \"object\";\n                const cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n                if (isObj) {\n                    expires = cookieObj.expires ? \";expires=\"+cookieObj.expires : '';\n                    domain = cookieObj.domain ? \";domain=\"+cookieObj.domain : '';\n                    path = cookieObj.path ? \";path=\"+cookieObj.path : '';\n                }\n                document.cookie =\n                    cookieName+'='+cookieValue + expires + domain + path;\n            }\n        }\n    }\n};\n\nexport { utils as default };\n","/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2018, OGG, LLC\n*/\n/*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob, module */\n\nimport MD5 from 'md5';\nimport SHA1 from 'sha1';\nimport utils from 'utils';\n\n/** Function: $build\n *  Create a Strophe.Builder.\n *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n *\n *  Parameters:\n *    (String) name - The root element name.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $build(name, attrs) {\n    return new Strophe.Builder(name, attrs);\n}\n\n/** Function: $msg\n *  Create a Strophe.Builder with a <message/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <message/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $msg(attrs) {\n    return new Strophe.Builder(\"message\", attrs);\n}\n\n/** Function: $iq\n *  Create a Strophe.Builder with an <iq/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <iq/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $iq(attrs) {\n    return new Strophe.Builder(\"iq\", attrs);\n}\n\n/** Function: $pres\n *  Create a Strophe.Builder with a <presence/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <presence/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $pres(attrs) {\n    return new Strophe.Builder(\"presence\", attrs);\n}\n\n/** Class: Strophe\n *  An object container for all Strophe library functions.\n *\n *  This class is just a container for all the objects and constants\n *  used in the library.  It is not meant to be instantiated, but to\n *  provide a namespace for library objects, constants, and functions.\n */\nconst Strophe = {\n    /** Constant: VERSION */\n    VERSION: \"@VERSION@\",\n\n    /** Constants: XMPP Namespace Constants\n     *  Common namespace constants from the XMPP RFCs and XEPs.\n     *\n     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n     *  NS.BOSH - BOSH namespace from XEP 206.\n     *  NS.CLIENT - Main XMPP client namespace.\n     *  NS.AUTH - Legacy authentication namespace.\n     *  NS.ROSTER - Roster operations namespace.\n     *  NS.PROFILE - Profile namespace.\n     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n     *  NS.MUC - Multi-User Chat namespace from XEP 45.\n     *  NS.SASL - XMPP SASL namespace from RFC 3920.\n     *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n     *  NS.BIND - XMPP Binding namespace from RFC 3920.\n     *  NS.SESSION - XMPP Session namespace from RFC 3920.\n     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n     *  NS.XHTML - XHTML body namespace from XEP 71.\n     */\n    NS: {\n        HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n        BOSH: \"urn:xmpp:xbosh\",\n        CLIENT: \"jabber:client\",\n        AUTH: \"jabber:iq:auth\",\n        ROSTER: \"jabber:iq:roster\",\n        PROFILE: \"jabber:iq:profile\",\n        DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n        DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n        MUC: \"http://jabber.org/protocol/muc\",\n        SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n        STREAM: \"http://etherx.jabber.org/streams\",\n        FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n        BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n        SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n        VERSION: \"jabber:iq:version\",\n        STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n        XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n        XHTML: \"http://www.w3.org/1999/xhtml\"\n    },\n\n    /** Constants: XHTML_IM Namespace\n     *  contains allowed tags, tag attributes, and css properties.\n     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n     *  allowed tags and their attributes.\n     */\n    XHTML: {\n        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],\n        attributes: {\n            'a':          ['href'],\n            'blockquote': ['style'],\n            'br':         [],\n            'cite':       ['style'],\n            'em':         [],\n            'img':        ['src', 'alt', 'style', 'height', 'width'],\n            'li':         ['style'],\n            'ol':         ['style'],\n            'p':          ['style'],\n            'span':       ['style'],\n            'strong':     [],\n            'ul':         ['style'],\n            'body':       []\n        },\n        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],\n        /** Function: XHTML.validTag\n         *\n         * Utility method to determine whether a tag is allowed\n         * in the XHTML_IM namespace.\n         *\n         * XHTML tag names are case sensitive and must be lower case.\n         */\n        validTag: function(tag) {\n            for (let i=0; i<Strophe.XHTML.tags.length; i++) {\n                if (tag === Strophe.XHTML.tags[i]) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /** Function: XHTML.validAttribute\n         *\n         * Utility method to determine whether an attribute is allowed\n         * as recommended per XEP-0071\n         *\n         * XHTML attribute names are case sensitive and must be lower case.\n         */\n        validAttribute: function(tag, attribute) {\n            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n                for (let i=0; i<Strophe.XHTML.attributes[tag].length; i++) {\n                    if (attribute === Strophe.XHTML.attributes[tag][i]) {\n                        return true;\n                    }\n                }\n            }\n        return false;\n        },\n        validCSS: function(style) {\n            for (let i=0; i<Strophe.XHTML.css.length; i++) {\n                if (style === Strophe.XHTML.css[i]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    /** Constants: Connection Status Constants\n     *  Connection status constants for use by the connection handler\n     *  callback.\n     *\n     *  Status.ERROR - An error has occurred\n     *  Status.CONNECTING - The connection is currently being made\n     *  Status.CONNFAIL - The connection attempt failed\n     *  Status.AUTHENTICATING - The connection is authenticating\n     *  Status.AUTHFAIL - The authentication attempt failed\n     *  Status.CONNECTED - The connection has succeeded\n     *  Status.DISCONNECTED - The connection has been terminated\n     *  Status.DISCONNECTING - The connection is currently being terminated\n     *  Status.ATTACHED - The connection has been attached\n     *  Status.REDIRECT - The connection has been redirected\n     *  Status.CONNTIMEOUT - The connection has timed out\n     */\n    Status: {\n        ERROR: 0,\n        CONNECTING: 1,\n        CONNFAIL: 2,\n        AUTHENTICATING: 3,\n        AUTHFAIL: 4,\n        CONNECTED: 5,\n        DISCONNECTED: 6,\n        DISCONNECTING: 7,\n        ATTACHED: 8,\n        REDIRECT: 9,\n        CONNTIMEOUT: 10\n    },\n\n    ErrorCondition: {\n        BAD_FORMAT: \"bad-format\",\n        CONFLICT: \"conflict\",\n        MISSING_JID_NODE: \"x-strophe-bad-non-anon-jid\",\n        NO_AUTH_MECH: \"no-auth-mech\",\n        UNKNOWN_REASON: \"unknown\",\n    },\n\n    /** Constants: Log Level Constants\n     *  Logging level indicators.\n     *\n     *  LogLevel.DEBUG - Debug output\n     *  LogLevel.INFO - Informational output\n     *  LogLevel.WARN - Warnings\n     *  LogLevel.ERROR - Errors\n     *  LogLevel.FATAL - Fatal errors\n     */\n    LogLevel: {\n        DEBUG: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        FATAL: 4\n    },\n\n    /** PrivateConstants: DOM Element Type Constants\n     *  DOM element types.\n     *\n     *  ElementType.NORMAL - Normal element.\n     *  ElementType.TEXT - Text data element.\n     *  ElementType.FRAGMENT - XHTML fragment element.\n     */\n    ElementType: {\n        NORMAL: 1,\n        TEXT: 3,\n        CDATA: 4,\n        FRAGMENT: 11\n    },\n\n    /** PrivateConstants: Timeout Values\n     *  Timeout values for error states.  These values are in seconds.\n     *  These should not be changed unless you know exactly what you are\n     *  doing.\n     *\n     *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 1.1, and with default wait, 66 seconds.\n     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n     *      Strophe can detect early failure, it will consider the request\n     *      failed if it doesn't return after\n     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 0.1, and with default wait, 6 seconds.\n     */\n    TIMEOUT: 1.1,\n    SECONDARY_TIMEOUT: 0.1,\n\n    /** Function: addNamespace\n     *  This function is used to extend the current namespaces in\n     *  Strophe.NS.  It takes a key and a value with the key being the\n     *  name of the new namespace, with its actual value.\n     *  For example:\n     *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n     *\n     *  Parameters:\n     *    (String) name - The name under which the namespace will be\n     *      referenced under Strophe.NS\n     *    (String) value - The actual namespace.\n     */\n    addNamespace: function (name, value) {\n        Strophe.NS[name] = value;\n    },\n\n    /** Function: forEachChild\n     *  Map a function over some or all child elements of a given element.\n     *\n     *  This is a small convenience function for mapping a function over\n     *  some or all of the children of an element.  If elemName is null, all\n     *  children will be passed to the function, otherwise only children\n     *  whose tag names match elemName will be passed.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The element to operate on.\n     *    (String) elemName - The child element tag name filter.\n     *    (Function) func - The function to apply to each child.  This\n     *      function should take a single argument, a DOM element.\n     */\n    forEachChild: function (elem, elemName, func) {\n        for (let i=0; i<elem.childNodes.length; i++) {\n            const childNode = elem.childNodes[i];\n            if (childNode.nodeType === Strophe.ElementType.NORMAL &&\n                (!elemName || this.isTagEqual(childNode, elemName))) {\n                func(childNode);\n            }\n        }\n    },\n\n    /** Function: isTagEqual\n     *  Compare an element's tag name with a string.\n     *\n     *  This function is case sensitive.\n     *\n     *  Parameters:\n     *    (XMLElement) el - A DOM element.\n     *    (String) name - The element name.\n     *\n     *  Returns:\n     *    true if the element's tag name matches _el_, and false\n     *    otherwise.\n     */\n    isTagEqual: function (el, name) {\n        return el.tagName === name;\n    },\n\n    /** PrivateVariable: _xmlGenerator\n     *  _Private_ variable that caches a DOM document to\n     *  generate elements.\n     */\n    _xmlGenerator: null,\n\n    /** PrivateFunction: _makeGenerator\n     *  _Private_ function that creates a dummy XML DOM document to serve as\n     *  an element and text node generator.\n     */\n    _makeGenerator: function () {\n        let doc;\n        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n        // less than 10 in the case of IE9 and below.\n        if (document.implementation.createDocument === undefined ||\n                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n            doc = this._getIEXmlDom();\n            doc.appendChild(doc.createElement('strophe'));\n        } else {\n            doc = document.implementation\n                .createDocument('jabber:client', 'strophe', null);\n        }\n        return doc;\n    },\n\n    /** Function: xmlGenerator\n     *  Get the DOM document to generate elements.\n     *\n     *  Returns:\n     *    The currently used DOM document.\n     */\n    xmlGenerator: function () {\n        if (!Strophe._xmlGenerator) {\n            Strophe._xmlGenerator = Strophe._makeGenerator();\n        }\n        return Strophe._xmlGenerator;\n    },\n\n    /** PrivateFunction: _getIEXmlDom\n     *  Gets IE xml doc object\n     *\n     *  Returns:\n     *    A Microsoft XML DOM Object\n     *  See Also:\n     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n     */\n    _getIEXmlDom : function() {\n        let doc = null;\n        const docStrings = [\n            \"Msxml2.DOMDocument.6.0\",\n            \"Msxml2.DOMDocument.5.0\",\n            \"Msxml2.DOMDocument.4.0\",\n            \"MSXML2.DOMDocument.3.0\",\n            \"MSXML2.DOMDocument\",\n            \"MSXML.DOMDocument\",\n            \"Microsoft.XMLDOM\"\n        ];\n\n        for (let d=0; d<docStrings.length; d++) {\n            if (doc === null) {\n                try {\n                    doc = new ActiveXObject(docStrings[d]);\n                } catch (e) {\n                    doc = null;\n                }\n            } else {\n                break;\n            }\n        }\n        return doc;\n    },\n\n    /** Function: xmlElement\n     *  Create an XML DOM element.\n     *\n     *  This function creates an XML DOM element correctly across all\n     *  implementations. Note that these are not HTML DOM elements, which\n     *  aren't appropriate for XMPP stanzas.\n     *\n     *  Parameters:\n     *    (String) name - The name for the element.\n     *    (Array|Object) attrs - An optional array or object containing\n     *      key/value pairs to use as element attributes. The object should\n     *      be in the format {'key': 'value'} or {key: 'value'}. The array\n     *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n     *    (String) text - The text child data for the element.\n     *\n     *  Returns:\n     *    A new XML DOM element.\n     */\n    xmlElement: function (name) {\n        if (!name) { return null; }\n\n        const node = Strophe.xmlGenerator().createElement(name);\n        // FIXME: this should throw errors if args are the wrong type or\n        // there are more than two optional args\n        for (let a=1; a<arguments.length; a++) {\n            const arg = arguments[a];\n            if (!arg) { continue; }\n            if (typeof(arg) === \"string\" ||\n                typeof(arg) === \"number\") {\n                node.appendChild(Strophe.xmlTextNode(arg));\n            } else if (typeof(arg) === \"object\" &&\n                       typeof(arg.sort) === \"function\") {\n                for (let i=0; i<arg.length; i++) {\n                    const attr = arg[i];\n                    if (typeof(attr) === \"object\" &&\n                        typeof(attr.sort) === \"function\" &&\n                        attr[1] !== undefined &&\n                        attr[1] !== null) {\n                        node.setAttribute(attr[0], attr[1]);\n                    }\n                }\n            } else if (typeof(arg) === \"object\") {\n                for (const k in arg) {\n                    if (Object.prototype.hasOwnProperty.call(arg, k) && arg[k] !== undefined && arg[k] !== null) {\n                        node.setAttribute(k, arg[k]);\n                    }\n                }\n            }\n        }\n        return node;\n    },\n\n    /*  Function: xmlescape\n     *  Excapes invalid xml characters.\n     *\n     *  Parameters:\n     *     (String) text - text to escape.\n     *\n     *  Returns:\n     *      Escaped text.\n     */\n    xmlescape: function(text) {\n        text = text.replace(/\\&/g, \"&amp;\");\n        text = text.replace(/</g,  \"&lt;\");\n        text = text.replace(/>/g,  \"&gt;\");\n        text = text.replace(/'/g,  \"&apos;\");\n        text = text.replace(/\"/g,  \"&quot;\");\n        return text;\n    },\n\n    /*  Function: xmlunescape\n    *  Unexcapes invalid xml characters.\n    *\n    *  Parameters:\n    *     (String) text - text to unescape.\n    *\n    *  Returns:\n    *      Unescaped text.\n    */\n    xmlunescape: function(text) {\n        text = text.replace(/\\&amp;/g, \"&\");\n        text = text.replace(/&lt;/g,  \"<\");\n        text = text.replace(/&gt;/g,  \">\");\n        text = text.replace(/&apos;/g,  \"'\");\n        text = text.replace(/&quot;/g,  \"\\\"\");\n        return text;\n    },\n\n    /** Function: xmlTextNode\n     *  Creates an XML DOM text node.\n     *\n     *  Provides a cross implementation version of document.createTextNode.\n     *\n     *  Parameters:\n     *    (String) text - The content of the text node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlTextNode: function (text) {\n        return Strophe.xmlGenerator().createTextNode(text);\n    },\n\n    /** Function: xmlHtmlNode\n     *  Creates an XML DOM html node.\n     *\n     *  Parameters:\n     *    (String) html - The content of the html node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlHtmlNode: function (html) {\n        let node;\n        //ensure text is escaped\n        if (DOMParser) {\n            const parser = new DOMParser();\n            node = parser.parseFromString(html, \"text/xml\");\n        } else {\n            node = new ActiveXObject(\"Microsoft.XMLDOM\");\n            node.async=\"false\";\n            node.loadXML(html);\n        }\n        return node;\n    },\n\n    /** Function: getText\n     *  Get the concatenation of all text children of an element.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A String with the concatenated text of all text element children.\n     */\n    getText: function (elem) {\n        if (!elem) { return null; }\n\n        let str = \"\";\n        if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\n            str += elem.nodeValue;\n        }\n        for (let i=0; i<elem.childNodes.length; i++) {\n            if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\n                str += elem.childNodes[i].nodeValue;\n            }\n        }\n        return Strophe.xmlescape(str);\n    },\n\n    /** Function: copyElement\n     *  Copy an XML DOM element.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    copyElement: function (elem) {\n        let el;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            el = Strophe.xmlElement(elem.tagName);\n\n            for (let i=0; i<elem.attributes.length; i++) {\n                el.setAttribute(elem.attributes[i].nodeName,\n                                elem.attributes[i].value);\n            }\n\n            for (let i=0; i<elem.childNodes.length; i++) {\n                el.appendChild(Strophe.copyElement(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n\n    /** Function: createHtml\n     *  Copy an HTML DOM element into an XML DOM.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (HTMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    createHtml: function (elem) {\n        let el;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            const tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n            if (Strophe.XHTML.validTag(tag)) {\n                try {\n                    el = Strophe.xmlElement(tag);\n                    for (let i=0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                        const attribute = Strophe.XHTML.attributes[tag][i];\n                        let value = elem.getAttribute(attribute);\n                        if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\n                            continue;\n                        }\n                        if (attribute === 'style' && typeof value === 'object' && typeof value.cssText !== 'undefined') {\n                            value = value.cssText; // we're dealing with IE, need to get CSS out\n                        }\n                        // filter out invalid css styles\n                        if (attribute === 'style') {\n                            const css = [];\n                            const cssAttrs = value.split(';');\n                            for (let j=0; j < cssAttrs.length; j++) {\n                                const attr = cssAttrs[j].split(':');\n                                const cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n                                if(Strophe.XHTML.validCSS(cssName)) {\n                                    const cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                                    css.push(cssName + ': ' + cssValue);\n                                }\n                            }\n                            if (css.length > 0) {\n                                value = css.join('; ');\n                                el.setAttribute(attribute, value);\n                            }\n                        } else {\n                            el.setAttribute(attribute, value);\n                        }\n                    }\n                    for (let i=0; i < elem.childNodes.length; i++) {\n                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                    }\n                } catch(e) { // invalid elements\n                    el = Strophe.xmlTextNode('');\n                }\n            } else {\n                el = Strophe.xmlGenerator().createDocumentFragment();\n                for (let i=0; i < elem.childNodes.length; i++) {\n                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                }\n            }\n        } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\n            el = Strophe.xmlGenerator().createDocumentFragment();\n            for (let i=0; i < elem.childNodes.length; i++) {\n                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n    /** Function: escapeNode\n     *  Escape the node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An escaped node (or local part).\n     */\n    escapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/^\\s+|\\s+$/g, '')\n            .replace(/\\\\/g,  \"\\\\5c\")\n            .replace(/ /g,   \"\\\\20\")\n            .replace(/\\\"/g,  \"\\\\22\")\n            .replace(/\\&/g,  \"\\\\26\")\n            .replace(/\\'/g,  \"\\\\27\")\n            .replace(/\\//g,  \"\\\\2f\")\n            .replace(/:/g,   \"\\\\3a\")\n            .replace(/</g,   \"\\\\3c\")\n            .replace(/>/g,   \"\\\\3e\")\n            .replace(/@/g,   \"\\\\40\");\n    },\n\n    /** Function: unescapeNode\n     *  Unescape a node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An unescaped node (or local part).\n     */\n    unescapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/\\\\20/g, \" \")\n            .replace(/\\\\22/g, '\"')\n            .replace(/\\\\26/g, \"&\")\n            .replace(/\\\\27/g, \"'\")\n            .replace(/\\\\2f/g, \"/\")\n            .replace(/\\\\3a/g, \":\")\n            .replace(/\\\\3c/g, \"<\")\n            .replace(/\\\\3e/g, \">\")\n            .replace(/\\\\40/g, \"@\")\n            .replace(/\\\\5c/g, \"\\\\\");\n    },\n\n    /** Function: getNodeFromJid\n     *  Get the node portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the node.\n     */\n    getNodeFromJid: function (jid) {\n        if (jid.indexOf(\"@\") < 0) { return null; }\n        return jid.split(\"@\")[0];\n    },\n\n    /** Function: getDomainFromJid\n     *  Get the domain portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the domain.\n     */\n    getDomainFromJid: function (jid) {\n        const bare = Strophe.getBareJidFromJid(jid);\n        if (bare.indexOf(\"@\") < 0) {\n            return bare;\n        } else {\n            const parts = bare.split(\"@\");\n            parts.splice(0, 1);\n            return parts.join('@');\n        }\n    },\n\n    /** Function: getResourceFromJid\n     *  Get the resource portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the resource.\n     */\n    getResourceFromJid: function (jid) {\n        if (!jid) { return null; }\n        const s = jid.split(\"/\");\n        if (s.length < 2) { return null; }\n        s.splice(0, 1);\n        return s.join('/');\n    },\n\n    /** Function: getBareJidFromJid\n     *  Get the bare JID from a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the bare JID.\n     */\n    getBareJidFromJid: function (jid) {\n        return jid ? jid.split(\"/\")[0] : null;\n    },\n\n    /** PrivateFunction: _handleError\n     *  _Private_ function that properly logs an error to the console\n     */\n    _handleError: function (e) {\n        if (typeof e.stack !== \"undefined\") {\n            Strophe.fatal(e.stack);\n        }\n        if (e.sourceURL) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" + e.sourceURL + \":\" +\n                          e.line + \" - \" + e.name + \": \" + e.message);\n        } else if (e.fileName) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" +\n                          e.fileName + \":\" + e.lineNumber + \" - \" +\n                          e.name + \": \" + e.message);\n        } else {\n            Strophe.fatal(\"error: \" + e.message);\n        }\n    },\n\n    /** Function: log\n     *  User overrideable logging function.\n     *\n     *  This function is called whenever the Strophe library calls any\n     *  of the logging functions.  The default implementation of this\n     *  function logs only fatal errors.  If client code wishes to handle the logging\n     *  messages, it should override this with\n     *  > Strophe.log = function (level, msg) {\n     *  >   (user code here)\n     *  > };\n     *\n     *  Please note that data sent and received over the wire is logged\n     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n     *\n     *  The different levels and their meanings are\n     *\n     *    DEBUG - Messages useful for debugging purposes.\n     *    INFO - Informational messages.  This is mostly information like\n     *      'disconnect was called' or 'SASL auth succeeded'.\n     *    WARN - Warnings about potential problems.  This is mostly used\n     *      to report transient connection errors like request timeouts.\n     *    ERROR - Some error occurred.\n     *    FATAL - A non-recoverable fatal error occurred.\n     *\n     *  Parameters:\n     *    (Integer) level - The log level of the log message.  This will\n     *      be one of the values in Strophe.LogLevel.\n     *    (String) msg - The log message.\n     */\n    log: function (level, msg) {\n        if (level === this.LogLevel.FATAL &&\n            typeof window.console === 'object' &&\n            typeof window.console.error === 'function') {\n            window.console.error(msg);\n        }\n    },\n\n    /** Function: debug\n     *  Log a message at the Strophe.LogLevel.DEBUG level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    debug: function(msg) {\n        this.log(this.LogLevel.DEBUG, msg);\n    },\n\n    /** Function: info\n     *  Log a message at the Strophe.LogLevel.INFO level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    info: function (msg) {\n        this.log(this.LogLevel.INFO, msg);\n    },\n\n    /** Function: warn\n     *  Log a message at the Strophe.LogLevel.WARN level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    warn: function (msg) {\n        this.log(this.LogLevel.WARN, msg);\n    },\n\n    /** Function: error\n     *  Log a message at the Strophe.LogLevel.ERROR level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    error: function (msg) {\n        this.log(this.LogLevel.ERROR, msg);\n    },\n\n    /** Function: fatal\n     *  Log a message at the Strophe.LogLevel.FATAL level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    fatal: function (msg) {\n        this.log(this.LogLevel.FATAL, msg);\n    },\n\n    /** Function: serialize\n     *  Render a DOM element and all descendants to a String.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The serialized element tree as a String.\n     */\n    serialize: function (elem) {\n        if (!elem) { return null; }\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        const names = [...Array(elem.attributes.length).keys()].map(i => elem.attributes[i].nodeName);\n        names.sort();\n        let result = names.reduce(\n            (a, n) => `${a} ${n}=\"${Strophe.xmlescape(elem.attributes.getNamedItem(n).value)}\"`,\n            `<${elem.nodeName}`\n        );\n\n        if (elem.childNodes.length > 0) {\n            result += \">\";\n            for (let i=0; i < elem.childNodes.length; i++) {\n                const child = elem.childNodes[i];\n                switch (child.nodeType) {\n                    case Strophe.ElementType.NORMAL:\n                        // normal element, so recurse\n                        result += Strophe.serialize(child);\n                        break;\n                    case Strophe.ElementType.TEXT:\n                        // text element to escape values\n                        result += Strophe.xmlescape(child.nodeValue);\n                        break;\n                    case Strophe.ElementType.CDATA:\n                        // cdata section so don't escape values\n                        result += \"<![CDATA[\"+child.nodeValue+\"]]>\";\n                }\n            }\n            result += \"</\" + elem.nodeName + \">\";\n        } else {\n            result += \"/>\";\n        }\n        return result;\n    },\n\n    /** PrivateVariable: _requestId\n     *  _Private_ variable that keeps track of the request ids for\n     *  connections.\n     */\n    _requestId: 0,\n\n    /** PrivateVariable: Strophe.connectionPlugins\n     *  _Private_ variable Used to store plugin names that need\n     *  initialization on Strophe.Connection construction.\n     */\n    _connectionPlugins: {},\n\n    /** Function: addConnectionPlugin\n     *  Extends the Strophe.Connection object with the given plugin.\n     *\n     *  Parameters:\n     *    (String) name - The name of the extension.\n     *    (Object) ptype - The plugin's prototype.\n     */\n    addConnectionPlugin: function (name, ptype) {\n        Strophe._connectionPlugins[name] = ptype;\n    }\n};\n\n/** Class: Strophe.Builder\n *  XML DOM builder.\n *\n *  This object provides an interface similar to JQuery but for building\n *  DOM elements easily and rapidly.  All the functions except for toString()\n *  and tree() return the object, so calls can be chained.  Here's an\n *  example using the $iq() builder helper.\n *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n *  >     .c('query', {xmlns: 'strophe:example'})\n *  >     .c('example')\n *  >     .toString()\n *\n *  The above generates this XML fragment\n *  > <iq to='you' from='me' type='get' id='1'>\n *  >   <query xmlns='strophe:example'>\n *  >     <example/>\n *  >   </query>\n *  > </iq>\n *  The corresponding DOM manipulations to get a similar fragment would be\n *  a lot more tedious and probably involve several helper variables.\n *\n *  Since adding children makes new operations operate on the child, up()\n *  is provided to traverse up the tree.  To add two children, do\n *  > builder.c('child1', ...).up().c('child2', ...)\n *  The next operation on the Builder will be relative to the second child.\n */\n\n/** Constructor: Strophe.Builder\n *  Create a Strophe.Builder object.\n *\n *  The attributes should be passed in object notation.  For example\n *  > let b = new Builder('message', {to: 'you', from: 'me'});\n *  or\n *  > let b = new Builder('messsage', {'xml:lang': 'en'});\n *\n *  Parameters:\n *    (String) name - The name of the root element.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder.\n */\nStrophe.Builder = function (name, attrs) {\n    // Set correct namespace for jabber:client elements\n    if (name === \"presence\" || name === \"message\" || name === \"iq\") {\n        if (attrs && !attrs.xmlns) {\n            attrs.xmlns = Strophe.NS.CLIENT;\n        } else if (!attrs) {\n            attrs = {xmlns: Strophe.NS.CLIENT};\n        }\n    }\n    // Holds the tree being built.\n    this.nodeTree = Strophe.xmlElement(name, attrs);\n    // Points to the current operation node.\n    this.node = this.nodeTree;\n};\n\nStrophe.Builder.prototype = {\n    /** Function: tree\n     *  Return the DOM tree.\n     *\n     *  This function returns the current DOM tree as an element object.  This\n     *  is suitable for passing to functions like Strophe.Connection.send().\n     *\n     *  Returns:\n     *    The DOM tree as a element object.\n     */\n    tree: function () {\n        return this.nodeTree;\n    },\n\n    /** Function: toString\n     *  Serialize the DOM tree to a String.\n     *\n     *  This function returns a string serialization of the current DOM\n     *  tree.  It is often used internally to pass data to a\n     *  Strophe.Request object.\n     *\n     *  Returns:\n     *    The serialized DOM tree in a String.\n     */\n    toString: function () {\n        return Strophe.serialize(this.nodeTree);\n    },\n\n    /** Function: up\n     *  Make the current parent element the new current element.\n     *\n     *  This function is often used after c() to traverse back up the tree.\n     *  For example, to add two children to the same element\n     *  > builder.c('child1', {}).up().c('child2', {});\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    up: function () {\n        this.node = this.node.parentNode;\n        return this;\n    },\n\n    /** Function: root\n     *  Make the root element the new current element.\n     *\n     *  When at a deeply nested element in the tree, this function can be used\n     *  to jump back to the root of the tree, instead of having to repeatedly\n     *  call up().\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    root: function () {\n        this.node = this.nodeTree;\n        return this;\n    },\n\n    /** Function: attrs\n     *  Add or modify attributes of the current element.\n     *\n     *  The attributes should be passed in object notation.  This function\n     *  does not move the current element pointer.\n     *\n     *  Parameters:\n     *    (Object) moreattrs - The attributes to add/modify in object notation.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    attrs: function (moreattrs) {\n        for (const k in moreattrs) {\n            if (Object.prototype.hasOwnProperty.call(moreattrs, k)) {\n                if (moreattrs[k] === undefined) {\n                    this.node.removeAttribute(k);\n                } else {\n                    this.node.setAttribute(k, moreattrs[k]);\n                }\n            }\n        }\n        return this;\n    },\n\n    /** Function: c\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function moves the current element pointer to the child,\n     *  unless text is provided.  If you need to add another child, it\n     *  is necessary to use up() to go back to the parent in the tree.\n     *\n     *  Parameters:\n     *    (String) name - The name of the child.\n     *    (Object) attrs - The attributes of the child in object notation.\n     *    (String) text - The text to add to the child.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    c: function (name, attrs, text) {\n        const child = Strophe.xmlElement(name, attrs, text);\n        this.node.appendChild(child);\n        if (typeof text !== \"string\" && typeof text !==\"number\") {\n            this.node = child;\n        }\n        return this;\n    },\n\n    /** Function: cnode\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function is the same as c() except that instead of using a\n     *  name and an attributes object to create the child it uses an\n     *  existing DOM element object.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    cnode: function (elem) {\n        let impNode;\n        const xmlGen = Strophe.xmlGenerator();\n        try {\n            impNode = (xmlGen.importNode !== undefined);\n        } catch (e) {\n            impNode = false;\n        }\n        const newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);\n        this.node.appendChild(newElem);\n        this.node = newElem;\n        return this;\n    },\n\n    /** Function: t\n     *  Add a child text element.\n     *\n     *  This *does not* make the child the new current element since there\n     *  are no children of text elements.\n     *\n     *  Parameters:\n     *    (String) text - The text data to append to the current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    t: function (text) {\n        const child = Strophe.xmlTextNode(text);\n        this.node.appendChild(child);\n        return this;\n    },\n\n    /** Function: h\n     *  Replace current element contents with the HTML passed in.\n     *\n     *  This *does not* make the child the new current element\n     *\n     *  Parameters:\n     *    (String) html - The html to insert as contents of current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    h: function (html) {\n        const fragment = document.createElement('body');\n        // force the browser to try and fix any invalid HTML tags\n        fragment.innerHTML = html;\n        // copy cleaned html into an xml dom\n        const xhtml = Strophe.createHtml(fragment);\n        while (xhtml.childNodes.length > 0) {\n            this.node.appendChild(xhtml.childNodes[0]);\n        }\n        return this;\n    }\n};\n\n/** PrivateClass: Strophe.Handler\n *  _Private_ helper class for managing stanza handlers.\n *\n *  A Strophe.Handler encapsulates a user provided callback function to be\n *  executed when matching stanzas are received by the connection.\n *  Handlers can be either one-off or persistant depending on their\n *  return value. Returning true will cause a Handler to remain active, and\n *  returning false will remove the Handler.\n *\n *  Users will not use Strophe.Handler objects directly, but instead they\n *  will use Strophe.Connection.addHandler() and\n *  Strophe.Connection.deleteHandler().\n */\n\n/** PrivateConstructor: Strophe.Handler\n *  Create and initialize a new Strophe.Handler.\n *\n *  Parameters:\n *    (Function) handler - A function to be executed when the handler is run.\n *    (String) ns - The namespace to match.\n *    (String) name - The element name to match.\n *    (String) type - The element type to match.\n *    (String) id - The element id attribute to match.\n *    (String) from - The element from attribute to match.\n *    (Object) options - Handler options\n *\n *  Returns:\n *    A new Strophe.Handler object.\n */\nStrophe.Handler = function (handler, ns, name, type, id, from, options) {\n    this.handler = handler;\n    this.ns = ns;\n    this.name = name;\n    this.type = type;\n    this.id = id;\n    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};\n    // BBB: Maintain backward compatibility with old `matchBare` option\n    if (this.options.matchBare) {\n        Strophe.warn('The \"matchBare\" option is deprecated, use \"matchBareFromJid\" instead.');\n        this.options.matchBareFromJid = this.options.matchBare;\n        delete this.options.matchBare;\n    }\n    if (this.options.matchBareFromJid) {\n        this.from = from ? Strophe.getBareJidFromJid(from) : null;\n    } else {\n        this.from = from;\n    }\n    // whether the handler is a user handler or a system handler\n    this.user = true;\n};\n\nStrophe.Handler.prototype = {\n    /** PrivateFunction: getNamespace\n     *  Returns the XML namespace attribute on an element.\n     *  If `ignoreNamespaceFragment` was passed in for this handler, then the\n     *  URL fragment will be stripped.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element with the namespace.\n     *\n     *  Returns:\n     *    The namespace, with optionally the fragment stripped.\n     */\n    getNamespace: function (elem) {\n        let elNamespace = elem.getAttribute(\"xmlns\");\n        if (elNamespace && this.options.ignoreNamespaceFragment) {\n            elNamespace = elNamespace.split('#')[0];\n        }\n        return elNamespace;\n    },\n\n    /** PrivateFunction: namespaceMatch\n     *  Tests if a stanza matches the namespace set for this Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    namespaceMatch: function (elem) {\n        let nsMatch = false;\n        if (!this.ns) {\n            return true;\n        } else {\n            Strophe.forEachChild(elem, null, (elem) => {\n                if (this.getNamespace(elem) === this.ns) {\n                    nsMatch = true;\n                }\n            });\n            return nsMatch || this.getNamespace(elem) === this.ns;\n        }\n    },\n\n    /** PrivateFunction: isMatch\n     *  Tests if a stanza matches the Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    isMatch: function (elem) {\n        let from = elem.getAttribute('from');\n        if (this.options.matchBareFromJid) {\n            from = Strophe.getBareJidFromJid(from);\n        }\n        const elem_type = elem.getAttribute(\"type\");\n        if (this.namespaceMatch(elem) &&\n            (!this.name || Strophe.isTagEqual(elem, this.name)) &&\n            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) &&\n            (!this.id || elem.getAttribute(\"id\") === this.id) &&\n            (!this.from || from === this.from)) {\n                return true;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: run\n     *  Run the callback on a matching stanza.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The DOM element that triggered the\n     *      Strophe.Handler.\n     *\n     *  Returns:\n     *    A boolean indicating if the handler should remain active.\n     */\n    run: function (elem) {\n        let result = null;\n        try {\n            result = this.handler(elem);\n        } catch (e) {\n            Strophe._handleError(e);\n            throw e;\n        }\n        return result;\n    },\n\n    /** PrivateFunction: toString\n     *  Get a String representation of the Strophe.Handler object.\n     *\n     *  Returns:\n     *    A String.\n     */\n    toString: function () {\n        return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" +\n            this.id + \",\" + this.ns + \")}\";\n    }\n};\n\n/** PrivateClass: Strophe.TimedHandler\n *  _Private_ helper class for managing timed handlers.\n *\n *  A Strophe.TimedHandler encapsulates a user provided callback that\n *  should be called after a certain period of time or at regular\n *  intervals.  The return value of the callback determines whether the\n *  Strophe.TimedHandler will continue to fire.\n *\n *  Users will not use Strophe.TimedHandler objects directly, but instead\n *  they will use Strophe.Connection.addTimedHandler() and\n *  Strophe.Connection.deleteTimedHandler().\n */\n\n/** PrivateConstructor: Strophe.TimedHandler\n *  Create and initialize a new Strophe.TimedHandler object.\n *\n *  Parameters:\n *    (Integer) period - The number of milliseconds to wait before the\n *      handler is called.\n *    (Function) handler - The callback to run when the handler fires.  This\n *      function should take no arguments.\n *\n *  Returns:\n *    A new Strophe.TimedHandler object.\n */\nStrophe.TimedHandler = function (period, handler) {\n    this.period = period;\n    this.handler = handler;\n    this.lastCalled = new Date().getTime();\n    this.user = true;\n};\n\nStrophe.TimedHandler.prototype = {\n    /** PrivateFunction: run\n     *  Run the callback for the Strophe.TimedHandler.\n     *\n     *  Returns:\n     *    true if the Strophe.TimedHandler should be called again, and false\n     *      otherwise.\n     */\n    run: function () {\n        this.lastCalled = new Date().getTime();\n        return this.handler();\n    },\n\n    /** PrivateFunction: reset\n     *  Reset the last called time for the Strophe.TimedHandler.\n     */\n    reset: function () {\n        this.lastCalled = new Date().getTime();\n    },\n\n    /** PrivateFunction: toString\n     *  Get a string representation of the Strophe.TimedHandler object.\n     *\n     *  Returns:\n     *    The string representation.\n     */\n    toString: function () {\n        return \"{TimedHandler: \" + this.handler + \"(\" + this.period +\")}\";\n    }\n};\n\n/** Class: Strophe.Connection\n *  XMPP Connection manager.\n *\n *  This class is the main part of Strophe.  It manages a BOSH or websocket\n *  connection to an XMPP server and dispatches events to the user callbacks\n *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n *  and legacy authentication.\n *\n *  After creating a Strophe.Connection object, the user will typically\n *  call connect() with a user supplied callback to handle connection level\n *  events like authentication failure, disconnection, or connection\n *  complete.\n *\n *  The user will also have several event handlers defined by using\n *  addHandler() and addTimedHandler().  These will allow the user code to\n *  respond to interesting stanzas or do something periodically with the\n *  connection. These handlers will be active once authentication is\n *  finished.\n *\n *  To send data to the connection, use send().\n */\n\n/** Constructor: Strophe.Connection\n *  Create and initialize a Strophe.Connection object.\n *\n *  The transport-protocol for this connection will be chosen automatically\n *  based on the given service parameter. URLs starting with \"ws://\" or\n *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n *  or without a protocol will use BOSH.\n *\n *  To make Strophe connect to the current host you can leave out the protocol\n *  and host part and just pass the path, e.g.\n *\n *  > let conn = new Strophe.Connection(\"/http-bind/\");\n *\n *  Options common to both Websocket and BOSH:\n *  ------------------------------------------\n *\n *  cookies:\n *\n *  The *cookies* option allows you to pass in cookies to be added to the\n *  document. These cookies will then be included in the BOSH XMLHttpRequest\n *  or in the websocket connection.\n *\n *  The passed in value must be a map of cookie names and string values.\n *\n *  > { \"myCookie\": {\n *  >     \"value\": \"1234\",\n *  >     \"domain\": \".example.org\",\n *  >     \"path\": \"/\",\n *  >     \"expires\": expirationDate\n *  >     }\n *  > }\n *\n *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n *  Those cookies need to be set under those domains, for example they can be\n *  set server-side by making a XHR call to that domain to ask it to set any\n *  necessary cookies.\n *\n *  mechanisms:\n *\n *  The *mechanisms* option allows you to specify the SASL mechanisms that this\n *  instance of Strophe.Connection (and therefore your XMPP client) will\n *  support.\n *\n *  The value must be an array of objects with Strophe.SASLMechanism\n *  prototypes.\n *\n *  If nothing is specified, then the following mechanisms (and their\n *  priorities) are registered:\n *\n *      SCRAM-SHA1 - 70\n *      DIGEST-MD5 - 60\n *      PLAIN - 50\n *      OAUTH-BEARER - 40\n *      OAUTH-2 - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  WebSocket options:\n *  ------------------\n *\n *  If you want to connect to the current host with a WebSocket connection you\n *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n *  for Secure WebSocket.\n *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n *\n *  > let conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n *\n *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n *  of the current site.\n *\n *  Also because downgrading security is not permitted by browsers, when using\n *  relative URLs both BOSH and WebSocket connections will use their secure\n *  variants if the current connection to the site is also secure (https).\n *\n *  BOSH options:\n *  -------------\n *\n *  By adding \"sync\" to the options, you can control if requests will\n *  be made synchronously or not. The default behaviour is asynchronous.\n *  If you want to make requests synchronous, make \"sync\" evaluate to true.\n *  > let conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n *\n *  You can also toggle this on an already established connection.\n *  > conn.options.sync = true;\n *\n *  The *customHeaders* option can be used to provide custom HTTP headers to be\n *  included in the XMLHttpRequests made.\n *\n *  The *keepalive* option can be used to instruct Strophe to maintain the\n *  current BOSH session across interruptions such as webpage reloads.\n *\n *  It will do this by caching the sessions tokens in sessionStorage, and when\n *  \"restore\" is called it will check whether there are cached tokens with\n *  which it can resume an existing session.\n *\n *  The *withCredentials* option should receive a Boolean value and is used to\n *  indicate wether cookies should be included in ajax requests (by default\n *  they're not).\n *  Set this value to true if you are connecting to a BOSH service\n *  and for some reason need to send cookies to it.\n *  In order for this to work cross-domain, the server must also enable\n *  credentials by setting the Access-Control-Allow-Credentials response header\n *  to \"true\". For most usecases however this setting should be false (which\n *  is the default).\n *  Additionally, when using Access-Control-Allow-Credentials, the\n *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n *  instead must be restricted to actual domains.\n *\n *  The *contentType* option can be set to change the default Content-Type\n *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n *  CORS preflight requests that are sent to the server.\n *\n *  Parameters:\n *    (String) service - The BOSH or WebSocket service URL.\n *    (Object) options - A hash of configuration options\n *\n *  Returns:\n *    A new Strophe.Connection object.\n */\nStrophe.Connection = function (service, options) {\n    // The service URL\n    this.service = service;\n    // Configuration options\n    this.options = options || {};\n    const proto = this.options.protocol || \"\";\n\n    // Select protocal based on service or options\n    if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 ||\n            proto.indexOf(\"ws\") === 0) {\n        this._proto = new Strophe.Websocket(this);\n    } else {\n        this._proto = new Strophe.Bosh(this);\n    }\n\n    /* The connected JID. */\n    this.jid = \"\";\n    /* the JIDs domain */\n    this.domain = null;\n    /* stream:features */\n    this.features = null;\n\n    // SASL\n    this._sasl_data = {};\n    this.do_session = false;\n    this.do_bind = false;\n\n    // handler lists\n    this.timedHandlers = [];\n    this.handlers = [];\n    this.removeTimeds = [];\n    this.removeHandlers = [];\n    this.addTimeds = [];\n    this.addHandlers = [];\n    this.protocolErrorHandlers = {\n        'HTTP': {},\n        'websocket': {}\n    };\n\n    this._idleTimeout = null;\n    this._disconnectTimeout = null;\n\n    this.authenticated = false;\n    this.connected = false;\n    this.disconnecting = false;\n    this.do_authentication = true;\n    this.paused = false;\n    this.restored = false;\n\n    this._data = [];\n    this._uniqueId = 0;\n\n    this._sasl_success_handler = null;\n    this._sasl_failure_handler = null;\n    this._sasl_challenge_handler = null;\n\n    // Max retries before disconnecting\n    this.maxRetries = 5;\n\n    // Call onIdle callback every 1/10th of a second\n    this._idleTimeout = setTimeout(() => this._onIdle(), 100);\n\n    utils.addCookies(this.options.cookies);\n    this.registerSASLMechanisms(this.options.mechanisms);\n\n    // initialize plugins\n    for (const k in Strophe._connectionPlugins) {\n        if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {\n            const F = function () {};\n            F.prototype = Strophe._connectionPlugins[k];\n            this[k] = new F();\n            this[k].init(this);\n        }\n    }\n};\n\nStrophe.Connection.prototype = {\n    /** Function: reset\n     *  Reset the connection.\n     *\n     *  This function should be called after a connection is disconnected\n     *  before that connection is reused.\n     */\n    reset: function () {\n        this._proto._reset();\n\n        // SASL\n        this.do_session = false;\n        this.do_bind = false;\n\n        // handler lists\n        this.timedHandlers = [];\n        this.handlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        this.authenticated = false;\n        this.connected = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        this._data = [];\n        this._requests = [];\n        this._uniqueId = 0;\n    },\n\n    /** Function: pause\n     *  Pause the request manager.\n     *\n     *  This will prevent Strophe from sending any more requests to the\n     *  server.  This is very useful for temporarily pausing\n     *  BOSH-Connections while a lot of send() calls are happening quickly.\n     *  This causes Strophe to send the data in a single request, saving\n     *  many request trips.\n     */\n    pause: function () {\n        this.paused = true;\n    },\n\n    /** Function: resume\n     *  Resume the request manager.\n     *\n     *  This resumes after pause() has been called.\n     */\n    resume: function () {\n        this.paused = false;\n    },\n\n    /** Function: getUniqueId\n     *  Generate a unique ID for use in <iq/> elements.\n     *\n     *  All <iq/> stanzas are required to have unique id attributes.  This\n     *  function makes creating these easy.  Each connection instance has\n     *  a counter which starts from zero, and the value of this counter\n     *  plus a colon followed by the suffix becomes the unique id. If no\n     *  suffix is supplied, the counter is used as the unique id.\n     *\n     *  Suffixes are used to make debugging easier when reading the stream\n     *  data, and their use is recommended.  The counter resets to 0 for\n     *  every new connection for the same reason.  For connections to the\n     *  same server that authenticate the same way, all the ids should be\n     *  the same, which makes it easy to see changes.  This is useful for\n     *  automated testing as well.\n     *\n     *  Parameters:\n     *    (String) suffix - A optional suffix to append to the id.\n     *\n     *  Returns:\n     *    A unique string to be used for the id attribute.\n     */\n    getUniqueId: function (suffix) {\n        const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            const r = Math.random() * 16 | 0,\n                  v = c === 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n        if (typeof(suffix) === \"string\" || typeof(suffix) === \"number\") {\n            return uuid + \":\" + suffix;\n        } else {\n            return uuid + \"\";\n        }\n    },\n\n    /** Function: addProtocolErrorHandler\n     *  Register a handler function for when a protocol (websocker or HTTP)\n     *  error occurs.\n     *\n     *  NOTE: Currently only HTTP errors for BOSH requests are handled.\n     *  Patches that handle websocket errors would be very welcome.\n     *\n     *  Parameters:\n     *    (String) protocol - 'HTTP' or 'websocket'\n     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\n     *    (Function) callback - Function that will fire on Http error\n     *\n     *  Example:\n     *  function onError(err_code){\n     *    //do stuff\n     *  }\n     *\n     *  let conn = Strophe.connect('http://example.com/http-bind');\n     *  conn.addProtocolErrorHandler('HTTP', 500, onError);\n     *  // Triggers HTTP 500 error and onError handler will be called\n     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\n     */\n    addProtocolErrorHandler: function (protocol, status_code, callback){\n        this.protocolErrorHandlers[protocol][status_code] = callback;\n    },\n\n\n    /** Function: connect\n     *  Starts the connection process.\n     *\n     *  As the connection process proceeds, the user supplied callback will\n     *  be triggered multiple times with status updates.  The callback\n     *  should take two arguments - the status code and the error condition.\n     *\n     *  The status code will be one of the values in the Strophe.Status\n     *  constants.  The error condition will be one of the conditions\n     *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n     *\n     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n     *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n     *  of the optional parameters.\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID,\n     *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\n     *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\n     *      process the provided password value as an access token).\n     *    (String) pass - The user's password.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (String) route - The optional route value.\n     *    (String) authcid - The optional alternative authentication identity\n     *      (username) if intending to impersonate another user.\n     *      When using the SASL-EXTERNAL authentication mechanism, for example\n     *      with client certificates, then the authcid value is used to\n     *      determine whether an authorization JID (authzid) should be sent to\n     *      the server. The authzid should not be sent to the server if the\n     *      authzid and authcid are the same. So to prevent it from being sent\n     *      (for example when the JID is already contained in the client\n     *      certificate), set authcid to that same JID. See XEP-178 for more\n     *      details.\n     */\n    connect: function (jid, pass, callback, wait, hold, route, authcid) {\n        this.jid = jid;\n        /** Variable: authzid\n         *  Authorization identity.\n         */\n        this.authzid = Strophe.getBareJidFromJid(this.jid);\n\n        /** Variable: authcid\n         *  Authentication identity (User name).\n         */\n        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n\n        /** Variable: pass\n         *  Authentication identity (User password).\n         */\n        this.pass = pass;\n\n        /** Variable: servtype\n         *  Digest MD5 compatibility.\n         */\n        this.servtype = \"xmpp\";\n\n        this.connect_callback = callback;\n        this.disconnecting = false;\n        this.connected = false;\n        this.authenticated = false;\n        this.restored = false;\n\n        // parse jid for domain\n        this.domain = Strophe.getDomainFromJid(this.jid);\n\n        this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\n        this._proto._connect(wait, hold, route);\n    },\n\n    /** Function: attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        if (this._proto instanceof Strophe.Bosh) {\n            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n        } else {\n            const error = new Error('The \"attach\" method can only be used with a BOSH connection.');\n            error.name = 'StropheSessionError';\n            throw error;\n        }\n    },\n\n    /** Function: restore\n     *  Attempt to restore a cached BOSH session.\n     *\n     *  This function is only useful in conjunction with providing the\n     *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n     *\n     *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n     *  RID (Request ID) and SID (Session ID) and then when this function is\n     *  called, it will attempt to restore the session from those cached\n     *  tokens.\n     *\n     *  This function must therefore be called instead of connect or attach.\n     *\n     *  For an example on how to use it, please see examples/restore.js\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    restore: function (jid, callback, wait, hold, wind) {\n        if (this._sessionCachingSupported()) {\n            this._proto._restore(jid, callback, wait, hold, wind);\n        } else {\n            const error = new Error('The \"restore\" method can only be used with a BOSH connection.');\n            error.name = 'StropheSessionError';\n            throw error;\n        }\n    },\n\n    /** PrivateFunction: _sessionCachingSupported\n     * Checks whether sessionStorage and JSON are supported and whether we're\n     * using BOSH.\n     */\n    _sessionCachingSupported: function () {\n        if (this._proto instanceof Strophe.Bosh) {\n            if (!JSON) { return false; }\n            try {\n                sessionStorage.setItem('_strophe_', '_strophe_');\n                sessionStorage.removeItem('_strophe_');\n            } catch (e) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    },\n\n    /** Function: xmlInput\n     *  User overrideable function that receives XML data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlInput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML data received by the connection.\n     */\n    /* jshint unused:false */\n    xmlInput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: xmlOutput\n     *  User overrideable function that receives XML data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlOutput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XMLdata sent by the connection.\n     */\n    /* jshint unused:false */\n    xmlOutput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawInput\n     *  User overrideable function that receives raw data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawInput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data received by the connection.\n     */\n    /* jshint unused:false */\n    rawInput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawOutput\n     *  User overrideable function that receives raw data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawOutput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data sent by the connection.\n     */\n    /* jshint unused:false */\n    rawOutput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: nextValidRid\n     *  User overrideable function that receives the new valid rid.\n     *\n     *  The default function does nothing. User code can override this with\n     *  > Strophe.Connection.nextValidRid = function (rid) {\n     *  >    (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (Number) rid - The next valid rid\n     */\n    /* jshint unused:false */\n    nextValidRid: function (rid) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: send\n     *  Send a stanza.\n     *\n     *  This function is called to push data onto the send queue to\n     *  go out over the wire.  Whenever a request is sent to the BOSH\n     *  server, all pending data is sent and the queue is flushed.\n     *\n     *  Parameters:\n     *    (XMLElement |\n     *     [XMLElement] |\n     *     Strophe.Builder) elem - The stanza to send.\n     */\n    send: function (elem) {\n        if (elem === null) { return ; }\n        if (typeof(elem.sort) === \"function\") {\n            for (let i=0; i < elem.length; i++) {\n                this._queueData(elem[i]);\n            }\n        } else if (typeof(elem.tree) === \"function\") {\n            this._queueData(elem.tree());\n        } else {\n            this._queueData(elem);\n        }\n        this._proto._send();\n    },\n\n    /** Function: flush\n     *  Immediately send any pending outgoing data.\n     *\n     *  Normally send() queues outgoing data until the next idle period\n     *  (100ms), which optimizes network use in the common cases when\n     *  several send()s are called in succession. flush() can be used to\n     *  immediately send all pending data.\n     */\n    flush: function () {\n        // cancel the pending idle period and run the idle function\n        // immediately\n        clearTimeout(this._idleTimeout);\n        this._onIdle();\n    },\n\n    /** Function: sendPresence\n     *  Helper function to send presence stanzas. The main benefit is for\n     *  sending presence stanzas for which you expect a responding presence\n     *  stanza with the same id (for example when leaving a chat room).\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the presence.\n     */\n    sendPresence: function(elem, callback, errback, timeout) {\n        let timeoutHandler = null;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        let id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendPresence\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            const handler = this.addHandler(stanza => {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    this.deleteTimedHandler(timeoutHandler);\n                }\n                if (stanza.getAttribute('type') === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else if (callback) {\n                    callback(stanza);\n                }\n            }, null, 'presence', null, id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, () => {\n                    // get rid of normal handler\n                    this.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** Function: sendIQ\n     *  Helper function to send IQ stanzas.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the IQ.\n    */\n    sendIQ: function(elem, callback, errback, timeout) {\n        let timeoutHandler = null;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        let id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendIQ\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            const handler = this.addHandler(stanza => {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    this.deleteTimedHandler(timeoutHandler);\n                }\n                const iqtype = stanza.getAttribute('type');\n                if (iqtype === 'result') {\n                    if (callback) {\n                        callback(stanza);\n                    }\n                } else if (iqtype === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else {\n                    const error = new Error(`Got bad IQ type of ${iqtype}`);\n                    error.name = \"StropheError\";\n                    throw(error);\n                }\n            }, null, 'iq', ['error', 'result'], id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, () => {\n                    // get rid of normal handler\n                    this.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** PrivateFunction: _queueData\n     *  Queue outgoing data for later sending.  Also ensures that the data\n     *  is a DOMElement.\n     */\n    _queueData: function (element) {\n        if (element === null ||\n                !element.tagName ||\n                !element.childNodes) {\n            const error = new Error(\"Cannot queue non-DOMElement.\");\n            error.name = \"StropheError\";\n            throw(error);\n        }\n        this._data.push(element);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._data.push(\"restart\");\n        this._proto._sendRestart();\n        this._idleTimeout = setTimeout(() => this._onIdle(), 100);\n    },\n\n    /** Function: addTimedHandler\n     *  Add a timed handler to the connection.\n     *\n     *  This function adds a timed handler.  The provided handler will\n     *  be called every period milliseconds until it returns false,\n     *  the connection is terminated, or the handler is removed.  Handlers\n     *  that wish to continue being invoked should return true.\n     *\n     *  Because of method binding it is necessary to save the result of\n     *  this function if you wish to remove a handler with\n     *  deleteTimedHandler().\n     *\n     *  Note that user handlers are not active until authentication is\n     *  successful.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addTimedHandler: function (period, handler) {\n        const thand = new Strophe.TimedHandler(period, handler);\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** Function: deleteTimedHandler\n     *  Delete a timed handler for a connection.\n     *\n     *  This function removes a timed handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addTimedHandler(),\n     *  but is the reference returned from addTimedHandler().\n     *\n     *  Parameters:\n     *    (Strophe.TimedHandler) handRef - The handler reference.\n     */\n    deleteTimedHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeTimeds.push(handRef);\n    },\n\n    /** Function: addHandler\n     *  Add a stanza handler for the connection.\n     *\n     *  This function adds a stanza handler to the connection.  The\n     *  handler callback will be called for any stanza that matches\n     *  the parameters.  Note that if multiple parameters are supplied,\n     *  they must all match for the handler to be invoked.\n     *\n     *  The handler will receive the stanza that triggered it as its argument.\n     *  *The handler should return true if it is to be invoked again;\n     *  returning false will remove the handler after it returns.*\n     *\n     *  As a convenience, the ns parameters applies to the top level element\n     *  and also any of its immediate children.  This is primarily to make\n     *  matching /iq/query elements easy.\n     *\n     *  Options\n     *  ~~~~~~~\n     *  With the options argument, you can specify boolean flags that affect how\n     *  matches are being done.\n     *\n     *  Currently two flags exist:\n     *\n     *  - matchBareFromJid:\n     *      When set to true, the from parameter and the\n     *      from attribute on the stanza will be matched as bare JIDs instead\n     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\n     *      value of options. The default value for matchBareFromJid is false.\n     *\n     *  - ignoreNamespaceFragment:\n     *      When set to true, a fragment specified on the stanza's namespace\n     *      URL will be ignored when it's matched with the one configured for\n     *      the handler.\n     *\n     *      This means that if you register like this:\n     *      >   connection.addHandler(\n     *      >       handler,\n     *      >       'http://jabber.org/protocol/muc',\n     *      >       null, null, null, null,\n     *      >       {'ignoreNamespaceFragment': true}\n     *      >   );\n     *\n     *      Then a stanza with XML namespace of\n     *      'http://jabber.org/protocol/muc#user' will also be matched. If\n     *      'ignoreNamespaceFragment' is false, then only stanzas with\n     *      'http://jabber.org/protocol/muc' will be matched.\n     *\n     *  Deleting the handler\n     *  ~~~~~~~~~~~~~~~~~~~~\n     *  The return value should be saved if you wish to remove the handler\n     *  with deleteHandler().\n     *\n     *  Parameters:\n     *    (Function) handler - The user callback.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String|Array) type - The stanza type (or types if an array) to match.\n     *    (String) id - The stanza id attribute to match.\n     *    (String) from - The stanza from attribute to match.\n     *    (String) options - The handler options\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addHandler: function (handler, ns, name, type, id, from, options) {\n        const hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** Function: deleteHandler\n     *  Delete a stanza handler for a connection.\n     *\n     *  This function removes a stanza handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addHandler(),\n     *  but is the reference returned from addHandler().\n     *\n     *  Parameters:\n     *    (Strophe.Handler) handRef - The handler reference.\n     */\n    deleteHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeHandlers.push(handRef);\n        // If a handler is being deleted while it is being added,\n        // prevent it from getting added\n        const i = this.addHandlers.indexOf(handRef);\n        if (i >= 0) {\n            this.addHandlers.splice(i, 1);\n        }\n    },\n\n    /** Function: registerSASLMechanisms\n     *\n     * Register the SASL mechanisms which will be supported by this instance of\n     * Strophe.Connection (i.e. which this XMPP client will support).\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\n     *\n     */\n    registerSASLMechanisms: function (mechanisms) {\n        this.mechanisms = {};\n        mechanisms = mechanisms || [\n            Strophe.SASLAnonymous,\n            Strophe.SASLExternal,\n            Strophe.SASLMD5,\n            Strophe.SASLOAuthBearer,\n            Strophe.SASLXOAuth2,\n            Strophe.SASLPlain,\n            Strophe.SASLSHA1\n        ];\n        mechanisms.forEach(this.registerSASLMechanism.bind(this));\n    },\n\n    /** Function: registerSASLMechanism\n     *\n     * Register a single SASL mechanism, to be supported by this client.\n     *\n     *  Parameters:\n     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\n     *\n     */\n    registerSASLMechanism: function (mechanism) {\n        this.mechanisms[mechanism.prototype.name] = mechanism;\n    },\n\n    /** Function: disconnect\n     *  Start the graceful disconnection process.\n     *\n     *  This function starts the disconnection process.  This process starts\n     *  by sending unavailable presence and sending BOSH body of type\n     *  terminate.  A timeout handler makes sure that disconnection happens\n     *  even if the BOSH server does not respond.\n     *  If the Connection object isn't connected, at least tries to abort all pending requests\n     *  so the connection object won't generate successful requests (which were already opened).\n     *\n     *  The user supplied connection callback will be notified of the\n     *  progress as this process happens.\n     *\n     *  Parameters:\n     *    (String) reason - The reason the disconnect is occuring.\n     */\n    disconnect: function (reason) {\n        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n        Strophe.warn(\"Disconnect was called because: \" + reason);\n        if (this.connected) {\n            let pres = false;\n            this.disconnecting = true;\n            if (this.authenticated) {\n                pres = $pres({\n                    'xmlns': Strophe.NS.CLIENT,\n                    'type': 'unavailable'\n                });\n            }\n            // setup timeout handler\n            this._disconnectTimeout = this._addSysTimedHandler(\n                3000, this._onDisconnectTimeout.bind(this));\n            this._proto._disconnect(pres);\n        } else {\n            Strophe.warn(\"Disconnect was called before Strophe connected to the server\");\n            this._proto._abortAllRequests();\n            this._doDisconnect();\n        }\n    },\n\n    /** PrivateFunction: _changeConnectStatus\n     *  _Private_ helper function that makes sure plugins and the user's\n     *  callback are notified of connection status changes.\n     *\n     *  Parameters:\n     *    (Integer) status - the new connection status, one of the values\n     *      in Strophe.Status\n     *    (String) condition - the error condition or null\n     *    (XMLElement) elem - The triggering stanza.\n     */\n    _changeConnectStatus: function (status, condition, elem) {\n        // notify all plugins listening for status changes\n        for (const k in Strophe._connectionPlugins) {\n            if (Object.prototype.hasOwnProperty.call(Strophe._connectionPlugins, k)) {\n                const plugin = this[k];\n                if (plugin.statusChanged) {\n                    try {\n                        plugin.statusChanged(status, condition);\n                    } catch (err) {\n                        Strophe.error(`${k} plugin caused an exception changing status: ${err}`);\n                    }\n                }\n            }\n        }\n        // notify the user's callback\n        if (this.connect_callback) {\n            try {\n                this.connect_callback(status, condition, elem);\n            } catch (e) {\n                Strophe._handleError(e);\n                Strophe.error(`User connection callback caused an exception: ${e}`);\n            }\n        }\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  This is the last piece of the disconnection logic.  This resets the\n     *  connection and alerts the user's connection callback.\n     */\n    _doDisconnect: function (condition) {\n        if (typeof this._idleTimeout === \"number\") {\n            clearTimeout(this._idleTimeout);\n        }\n\n        // Cancel Disconnect Timeout\n        if (this._disconnectTimeout !== null) {\n            this.deleteTimedHandler(this._disconnectTimeout);\n            this._disconnectTimeout = null;\n        }\n\n        Strophe.debug(\"_doDisconnect was called\");\n        this._proto._doDisconnect();\n\n        this.authenticated = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        // delete handlers\n        this.handlers = [];\n        this.timedHandlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        // tell the parent we disconnected\n        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n        this.connected = false;\n    },\n\n    /** PrivateFunction: _dataRecv\n     *  _Private_ handler to processes incoming data from the the connection.\n     *\n     *  Except for _connect_cb handling the initial connection request,\n     *  this function handles the incoming data for all requests.  This\n     *  function also fires stanza handlers that match each incoming\n     *  stanza.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that has data ready.\n     *    (string) req - The stanza a raw string (optiona).\n     */\n    _dataRecv: function (req, raw) {\n        Strophe.debug(\"_dataRecv called\");\n        const elem = this._proto._reqToData(req);\n        if (elem === null) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n                this.xmlInput(elem.childNodes[0]);\n            } else {\n                this.xmlInput(elem);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(elem));\n            }\n        }\n\n        // remove handlers scheduled for deletion\n        while (this.removeHandlers.length > 0) {\n            const hand = this.removeHandlers.pop();\n            const i = this.handlers.indexOf(hand);\n            if (i >= 0) {\n                this.handlers.splice(i, 1);\n            }\n        }\n\n        // add handlers scheduled for addition\n        while (this.addHandlers.length > 0) {\n            this.handlers.push(this.addHandlers.pop());\n        }\n\n        // handle graceful disconnect\n        if (this.disconnecting && this._proto._emptyQueue()) {\n            this._doDisconnect();\n            return;\n        }\n\n        const type = elem.getAttribute(\"type\");\n        if (type !== null && type === \"terminate\") {\n            // Don't process stanzas that come in after disconnect\n            if (this.disconnecting) {\n                return;\n            }\n            // an error occurred\n            let cond = elem.getAttribute(\"condition\");\n            const conflict = elem.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._changeConnectStatus(\n                    Strophe.Status.CONNFAIL,\n                    Strophe.ErrorCondition.UNKOWN_REASON\n                );\n            }\n            this._doDisconnect(cond);\n            return;\n        }\n\n        // send each incoming stanza through the handler chain\n        Strophe.forEachChild(elem, null, child => {\n            // process handlers\n            const newList = this.handlers;\n            this.handlers = [];\n            for (let i=0; i < newList.length; i++) {\n                const hand = newList[i];\n                // encapsulate 'handler.run' not to lose the whole handler list if\n                // one of the handlers throws an exception\n                try {\n                    if (hand.isMatch(child) &&\n                        (this.authenticated || !hand.user)) {\n                        if (hand.run(child)) {\n                            this.handlers.push(hand);\n                        }\n                    } else {\n                        this.handlers.push(hand);\n                    }\n                } catch(e) {\n                    // if the handler throws an exception, we consider it as false\n                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);\n                }\n            }\n        });\n    },\n\n\n    /** Attribute: mechanisms\n     *  SASL Mechanisms available for Connection.\n     */\n    mechanisms: {},\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the initial connection request\n     *  response from the BOSH server. It is used to set up authentication\n     *  handlers and start the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The current request.\n     *    (Function) _callback - low level (xmpp) connect callback function.\n     *      Useful for plugins with their own xmpp connect callback (when they\n     *      want to do something special).\n     */\n    _connect_cb: function (req, _callback, raw) {\n        Strophe.debug(\"_connect_cb was called\");\n        this.connected = true;\n\n        let bodyWrap;\n        try {\n            bodyWrap = this._proto._reqToData(req);\n        } catch (e) {\n            if (e.name !== Strophe.ErrorCondition.BAD_FORMAT) { throw e; }\n            this._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                Strophe.ErrorCondition.BAD_FORMAT\n            );\n            this._doDisconnect(Strophe.ErrorCondition.BAD_FORMAT);\n        }\n        if (!bodyWrap) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n                this.xmlInput(bodyWrap.childNodes[0]);\n            } else {\n                this.xmlInput(bodyWrap);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(bodyWrap));\n            }\n        }\n\n        const conncheck = this._proto._connect_cb(bodyWrap);\n        if (conncheck === Strophe.Status.CONNFAIL) {\n            return;\n        }\n\n        // Check for the stream:features tag\n        let hasFeatures;\n        if (bodyWrap.getElementsByTagNameNS) {\n            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n        } else {\n            hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 ||\n                            bodyWrap.getElementsByTagName(\"features\").length > 0;\n        }\n        if (!hasFeatures) {\n            this._proto._no_auth_received(_callback);\n            return;\n        }\n\n        const matched = [];\n        const mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n        if (mechanisms.length > 0) {\n            for (let i=0; i < mechanisms.length; i++) {\n                const mech = Strophe.getText(mechanisms[i]);\n                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n            }\n        }\n        if (matched.length === 0) {\n            if (bodyWrap.getElementsByTagName(\"auth\").length === 0) {\n                // There are no matching SASL mechanisms and also no legacy\n                // auth available.\n                this._proto._no_auth_received(_callback);\n                return;\n            }\n        }\n        if (this.do_authentication !== false) {\n            this.authenticate(matched);\n        }\n    },\n\n    /** Function: sortMechanismsByPriority\n     *\n     *  Sorts an array of objects with prototype SASLMechanism according to\n     *  their priorities.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     */\n    sortMechanismsByPriority: function (mechanisms) {\n        // Sorting mechanisms according to priority.\n        for (let i=0; i < mechanisms.length - 1; ++i) {\n            let higher = i;\n            for (let j=i + 1; j < mechanisms.length; ++j) {\n                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\n                    higher = j;\n                }\n            }\n            if (higher !== i) {\n                const swap = mechanisms[i];\n                mechanisms[i] = mechanisms[higher];\n                mechanisms[higher] = swap;\n            }\n        }\n        return mechanisms;\n    },\n\n    /** PrivateFunction: _attemptSASLAuth\n     *\n     *  Iterate through an array of SASL mechanisms and attempt authentication\n     *  with the highest priority (enabled) mechanism.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     *  Returns:\n     *    (Boolean) mechanism_found - true or false, depending on whether a\n     *          valid SASL mechanism was found with which authentication could be\n     *          started.\n     */\n    _attemptSASLAuth: function (mechanisms) {\n        mechanisms = this.sortMechanismsByPriority(mechanisms || []);\n        let mechanism_found = false;\n        for (let i=0; i < mechanisms.length; ++i) {\n            if (!mechanisms[i].prototype.test(this)) {\n                continue;\n            }\n            this._sasl_success_handler = this._addSysHandler(\n                this._sasl_success_cb.bind(this), null,\n                \"success\", null, null);\n            this._sasl_failure_handler = this._addSysHandler(\n                this._sasl_failure_cb.bind(this), null,\n                \"failure\", null, null);\n            this._sasl_challenge_handler = this._addSysHandler(\n                this._sasl_challenge_cb.bind(this), null,\n                \"challenge\", null, null);\n\n            this._sasl_mechanism = new mechanisms[i]();\n            this._sasl_mechanism.onStart(this);\n\n            const request_auth_exchange = $build(\"auth\", {\n                'xmlns': Strophe.NS.SASL,\n                'mechanism': this._sasl_mechanism.name\n            });\n            if (this._sasl_mechanism.isClientFirst) {\n                const response = this._sasl_mechanism.onChallenge(this, null);\n                request_auth_exchange.t(btoa(response));\n            }\n            this.send(request_auth_exchange.tree());\n            mechanism_found = true;\n            break;\n        }\n        return mechanism_found;\n    },\n\n    /** PrivateFunction: _attemptLegacyAuth\n     *\n     *  Attempt legacy (i.e. non-SASL) authentication.\n     *\n     */\n    _attemptLegacyAuth: function () {\n        if (Strophe.getNodeFromJid(this.jid) === null) {\n            // we don't have a node, which is required for non-anonymous\n            // client connections\n            this._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                Strophe.ErrorCondition.MISSING_JID_NODE\n            );\n            this.disconnect(Strophe.ErrorCondition.MISSING_JID_NODE);\n        } else {\n            // Fall back to legacy authentication\n            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n            this._addSysHandler(\n                this._auth1_cb.bind(this),\n                null, null, null, \"_auth_1\"\n            );\n            this.send($iq({\n                    'type': \"get\",\n                    'to': this.domain,\n                    'id': \"_auth_1\"\n                }).c(\"query\", {xmlns: Strophe.NS.AUTH})\n                .c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid))\n                .tree());\n        }\n    },\n\n    /** Function: authenticate\n     * Set up authentication\n     *\n     *  Continues the initial connection request by setting up authentication\n     *  handlers and starting the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Array) matched - Array of SASL mechanisms supported.\n     *\n     */\n    authenticate: function (matched) {\n        if (!this._attemptSASLAuth(matched)) {\n            this._attemptLegacyAuth();\n        }\n    },\n\n    /** PrivateFunction: _sasl_challenge_cb\n     *  _Private_ handler for the SASL challenge\n     *\n     */\n    _sasl_challenge_cb: function(elem) {\n      const challenge = atob(Strophe.getText(elem));\n      const response = this._sasl_mechanism.onChallenge(this, challenge);\n      const stanza = $build('response', {'xmlns': Strophe.NS.SASL});\n      if (response !== \"\") {\n        stanza.t(btoa(response));\n      }\n      this.send(stanza.tree());\n      return true;\n    },\n\n    /** PrivateFunction: _auth1_cb\n     *  _Private_ handler for legacy authentication.\n     *\n     *  This handler is called in response to the initial <iq type='get'/>\n     *  for legacy authentication.  It builds an authentication <iq/> and\n     *  sends it, creating a handler (calling back to _auth2_cb()) to\n     *  handle the result\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _auth1_cb: function (elem) {\n        // build plaintext auth iq\n        const iq = $iq({type: \"set\", id: \"_auth_2\"})\n            .c('query', {xmlns: Strophe.NS.AUTH})\n            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))\n            .up()\n            .c('password').t(this.pass);\n\n        if (!Strophe.getResourceFromJid(this.jid)) {\n            // since the user has not supplied a resource, we pick\n            // a default one here.  unlike other auth methods, the server\n            // cannot do this for us.\n            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n        }\n        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\n        this._addSysHandler(this._auth2_cb.bind(this), null, null, null, \"_auth_2\");\n        this.send(iq.tree());\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _sasl_success_cb\n     *  _Private_ handler for succesful SASL authentication.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_success_cb: function (elem) {\n        if (this._sasl_data[\"server-signature\"]) {\n            let serverSignature;\n            const success = atob(Strophe.getText(elem));\n            const attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n            const matches = success.match(attribMatch);\n            if (matches[1] === \"v\") {\n                serverSignature = matches[2];\n            }\n            if (serverSignature !== this._sasl_data[\"server-signature\"]) {\n                // remove old handlers\n                this.deleteHandler(this._sasl_failure_handler);\n                this._sasl_failure_handler = null;\n                if (this._sasl_challenge_handler) {\n                    this.deleteHandler(this._sasl_challenge_handler);\n                    this._sasl_challenge_handler = null;\n                }\n                this._sasl_data = {};\n                return this._sasl_failure_cb(null);\n            }\n        }\n        Strophe.info(\"SASL authentication succeeded.\");\n\n        if (this._sasl_mechanism) {\n            this._sasl_mechanism.onSuccess();\n        }\n        // remove old handlers\n        this.deleteHandler(this._sasl_failure_handler);\n        this._sasl_failure_handler = null;\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n        const streamfeature_handlers = [];\n        const wrapper = (handlers, elem) => {\n            while (handlers.length) {\n                this.deleteHandler(handlers.pop());\n            }\n            this._sasl_auth1_cb(elem);\n            return false;\n        };\n        streamfeature_handlers.push(\n            this._addSysHandler(elem => wrapper(streamfeature_handlers, elem),\n            null, \"stream:features\", null, null)\n        );\n\n        streamfeature_handlers.push(\n            this._addSysHandler(elem => wrapper(streamfeature_handlers, elem),\n            Strophe.NS.STREAM, \"features\", null, null)\n        );\n\n        // we must send an xmpp:restart now\n        this._sendRestart();\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_auth1_cb\n     *  _Private_ handler to start stream binding.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_auth1_cb: function (elem) {\n        // save stream:features for future usage\n        this.features = elem;\n        for (let i=0; i < elem.childNodes.length; i++) {\n            const child = elem.childNodes[i];\n            if (child.nodeName === 'bind') {\n                this.do_bind = true;\n            }\n            if (child.nodeName === 'session') {\n                this.do_session = true;\n            }\n        }\n\n        if (!this.do_bind) {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            return false;\n        } else {\n            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,\n                                null, \"_bind_auth_2\");\n\n            const resource = Strophe.getResourceFromJid(this.jid);\n            if (resource) {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .c('resource', {}).t(resource).tree());\n            } else {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .tree());\n            }\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_bind_cb\n     *  _Private_ handler for binding result and session start.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_bind_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.warn(\"SASL binding failed.\");\n            const conflict = elem.getElementsByTagName(\"conflict\");\n            let condition;\n            if (conflict.length > 0) {\n                condition = Strophe.ErrorCondition.CONFLICT;\n            }\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition, elem);\n            return false;\n        }\n\n        // TODO - need to grab errors\n        const bind = elem.getElementsByTagName(\"bind\");\n        if (bind.length > 0) {\n            const jidNode = bind[0].getElementsByTagName(\"jid\");\n            if (jidNode.length > 0) {\n                this.jid = Strophe.getText(jidNode[0]);\n\n                if (this.do_session) {\n                    this._addSysHandler(this._sasl_session_cb.bind(this),\n                                        null, null, null, \"_session_auth_2\");\n\n                    this.send($iq({type: \"set\", id: \"_session_auth_2\"})\n                                  .c('session', {xmlns: Strophe.NS.SESSION})\n                                  .tree());\n                } else {\n                    this.authenticated = true;\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                }\n            }\n        } else {\n            Strophe.warn(\"SASL binding failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            return false;\n        }\n    },\n\n    /** PrivateFunction: _sasl_session_cb\n     *  _Private_ handler to finish successful SASL connection.\n     *\n     *  This sets Connection.authenticated to true on success, which\n     *  starts the processing of user handlers.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_session_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.warn(\"Session creation failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            return false;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_failure_cb\n     *  _Private_ handler for SASL authentication failure.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _sasl_failure_cb: function (elem) {\n        // delete unneeded handlers\n        if (this._sasl_success_handler) {\n            this.deleteHandler(this._sasl_success_handler);\n            this._sasl_success_handler = null;\n        }\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n\n        if(this._sasl_mechanism)\n          this._sasl_mechanism.onFailure();\n        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _auth2_cb\n     *  _Private_ handler to finish legacy authentication.\n     *\n     *  This handler is called when the result from the jabber:iq:auth\n     *  <iq/> stanza is returned.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _auth2_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null, elem);\n            this.disconnect('authentication failed');\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _addSysTimedHandler\n     *  _Private_ function to add a system level timed handler.\n     *\n     *  This function is used to add a Strophe.TimedHandler for the\n     *  library code.  System timed handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     */\n    _addSysTimedHandler: function (period, handler) {\n        const thand = new Strophe.TimedHandler(period, handler);\n        thand.user = false;\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** PrivateFunction: _addSysHandler\n     *  _Private_ function to add a system level stanza handler.\n     *\n     *  This function is used to add a Strophe.Handler for the\n     *  library code.  System stanza handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Function) handler - The callback function.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String) type - The stanza type attribute to match.\n     *    (String) id - The stanza id attribute to match.\n     */\n    _addSysHandler: function (handler, ns, name, type, id) {\n        const hand = new Strophe.Handler(handler, ns, name, type, id);\n        hand.user = false;\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  If the graceful disconnect process does not complete within the\n     *  time allotted, this handler finishes the disconnect anyway.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _onDisconnectTimeout: function () {\n        Strophe.debug(\"_onDisconnectTimeout was called\");\n        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n        this._proto._onDisconnectTimeout();\n        // actually disconnect\n        this._doDisconnect();\n        return false;\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler to process events during idle cycle.\n     *\n     *  This handler is called every 100ms to fire timed handlers that\n     *  are ready and keep poll requests going.\n     */\n    _onIdle: function () {\n        // add timed handlers scheduled for addition\n        // NOTE: we add before remove in the case a timed handler is\n        // added and then deleted before the next _onIdle() call.\n        while (this.addTimeds.length > 0) {\n            this.timedHandlers.push(this.addTimeds.pop());\n        }\n\n        // remove timed handlers that have been scheduled for deletion\n        while (this.removeTimeds.length > 0) {\n            const thand = this.removeTimeds.pop();\n            const i = this.timedHandlers.indexOf(thand);\n            if (i >= 0) {\n                this.timedHandlers.splice(i, 1);\n            }\n        }\n\n        // call ready timed handlers\n        const now = new Date().getTime();\n        const newList = [];\n        for (let i=0; i < this.timedHandlers.length; i++) {\n            const thand = this.timedHandlers[i];\n            if (this.authenticated || !thand.user) {\n                const since = thand.lastCalled + thand.period;\n                if (since - now <= 0) {\n                    if (thand.run()) {\n                        newList.push(thand);\n                    }\n                } else {\n                    newList.push(thand);\n                }\n            }\n        }\n        this.timedHandlers = newList;\n        clearTimeout(this._idleTimeout);\n        this._proto._onIdle();\n\n        // reactivate the timer only if connected\n        if (this.connected) {\n            this._idleTimeout = setTimeout(() => this._onIdle(), 100);\n        }\n    }\n};\n\n/** Class: Strophe.SASLMechanism\n *\n *  encapsulates SASL authentication mechanisms.\n *\n *  User code may override the priority for each mechanism or disable it completely.\n *  See <priority> for information about changing priority and <test> for informatian on\n *  how to disable a mechanism.\n *\n *  By default, all mechanisms are enabled and the priorities are\n *\n *      OAUTHBEARER - 60\n *      SCRAM-SHA1 - 50\n *      DIGEST-MD5 - 40\n *      PLAIN - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  See: Strophe.Connection.addSupportedSASLMechanisms\n */\n\n/**\n * PrivateConstructor: Strophe.SASLMechanism\n * SASL auth mechanism abstraction.\n *\n *  Parameters:\n *    (String) name - SASL Mechanism name.\n *    (Boolean) isClientFirst - If client should send response first without challenge.\n *    (Number) priority - Priority.\n *\n *  Returns:\n *    A new Strophe.SASLMechanism object.\n */\nStrophe.SASLMechanism = function(name, isClientFirst, priority) {\n  /** PrivateVariable: name\n   *  Mechanism name.\n   */\n  this.name = name;\n  /** PrivateVariable: isClientFirst\n   *  If client sends response without initial server challenge.\n   */\n  this.isClientFirst = isClientFirst;\n  /** Variable: priority\n   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n   *  Users may override this to prioritize mechanisms differently.\n   *\n   *  In the default configuration the priorities are\n   *\n   *  SCRAM-SHA1 - 40\n   *  DIGEST-MD5 - 30\n   *  Plain - 20\n   *\n   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n   *\n   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n   *\n   *  See <SASL mechanisms> for a list of available mechanisms.\n   *\n   */\n  this.priority = priority;\n};\n\nStrophe.SASLMechanism.prototype = {\n    /**\n     *  Function: test\n     *  Checks if mechanism able to run.\n     *  To disable a mechanism, make this return false;\n     *\n     *  To disable plain authentication run\n     *  > Strophe.SASLPlain.test = function() {\n     *  >   return false;\n     *  > }\n     *\n     *  See <SASL mechanisms> for a list of available mechanisms.\n     *\n     *  Parameters:\n     *    (Strophe.Connection) connection - Target Connection.\n     *\n     *  Returns:\n     *    (Boolean) If mechanism was able to run.\n     */\n    /* jshint unused:false */\n    test: function(connection) {\n        return true;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: onStart\n     *  Called before starting mechanism on some connection.\n     *\n     *  Parameters:\n     *    (Strophe.Connection) connection - Target Connection.\n     */\n    onStart: function(connection) {\n        this._connection = connection;\n    },\n\n    /** PrivateFunction: onChallenge\n     *  Called by protocol implementation on incoming challenge. If client is\n     *  first (isClientFirst === true) challenge will be null on the first call.\n     *\n     *  Parameters:\n     *    (Strophe.Connection) connection - Target Connection.\n     *    (String) challenge - current challenge to handle.\n     *\n     *  Returns:\n     *    (String) Mechanism response.\n     */\n    /* jshint unused:false */\n    onChallenge: function (connection, challenge) {\n        throw new Error(\"You should implement challenge handling!\");\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: onFailure\n     *  Protocol informs mechanism implementation about SASL failure.\n     */\n    onFailure: function() {\n        this._connection = null;\n    },\n\n    /** PrivateFunction: onSuccess\n     *  Protocol informs mechanism implementation about SASL success.\n     */\n    onSuccess: function() {\n        this._connection = null;\n    }\n};\n\n/** Constants: SASL mechanisms\n *  Available authentication mechanisms\n *\n *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n *  Strophe.SASLPlain - SASL PLAIN authentication.\n *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n *  Strophe.SASLExternal - SASL EXTERNAL authentication\n *  Strophe.SASLXOAuth2 - SASL X-OAuth2 authentication\n */\n\n// Building SASL callbacks\n\n/** PrivateConstructor: SASLAnonymous\n *  SASL ANONYMOUS authentication.\n */\nStrophe.SASLAnonymous = function() {};\nStrophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 20);\n\nStrophe.SASLAnonymous.prototype.test = function(connection) {\n    return connection.authcid === null;\n};\n\n\n/** PrivateConstructor: SASLPlain\n *  SASL PLAIN authentication.\n */\nStrophe.SASLPlain = function() {};\nStrophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 50);\n\nStrophe.SASLPlain.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLPlain.prototype.onChallenge = function(connection) {\n    let auth_str = connection.authzid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.authcid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.pass;\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLSHA1\n *  SASL SCRAM SHA 1 authentication.\n */\nStrophe.SASLSHA1 = function() {};\nStrophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 70);\n\nStrophe.SASLSHA1.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n    const cnonce = test_cnonce || MD5.hexdigest(\"\" + (Math.random() * 1234567890));\n    let auth_str = \"n=\" + utils.utf16to8(connection.authcid);\n    auth_str += \",r=\";\n    auth_str += cnonce;\n    connection._sasl_data.cnonce = cnonce;\n    connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n    auth_str = \"n,,\" + auth_str;\n\n    this.onChallenge = (connection, challenge) => {\n        let nonce, salt, iter, Hi, U, U_old, i, k;\n        let responseText = \"c=biws,\";\n        let authMessage = `${connection._sasl_data[\"client-first-message-bare\"]},${challenge},`;\n        const cnonce = connection._sasl_data.cnonce;\n        const attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\n        while (challenge.match(attribMatch)) {\n            const matches = challenge.match(attribMatch);\n            challenge = challenge.replace(matches[0], \"\");\n            switch (matches[1]) {\n            case \"r\":\n                nonce = matches[2];\n                break;\n            case \"s\":\n                salt = matches[2];\n                break;\n            case \"i\":\n                iter = matches[2];\n                break;\n            }\n        }\n\n        if (nonce.substr(0, cnonce.length) !== cnonce) {\n            connection._sasl_data = {};\n            return connection._sasl_failure_cb();\n        }\n\n        responseText += \"r=\" + nonce;\n        authMessage += responseText;\n\n        salt = atob(salt);\n        salt += \"\\x00\\x00\\x00\\x01\";\n\n        const pass = utils.utf16to8(connection.pass);\n        Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\n        for (i=1; i<iter; i++) {\n            U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\n            for (k = 0; k < 5; k++) {\n                Hi[k] ^= U[k];\n            }\n            U_old = U;\n        }\n        Hi = SHA1.binb2str(Hi);\n\n        const clientKey = SHA1.core_hmac_sha1(Hi, \"Client Key\");\n        const serverKey = SHA1.str_hmac_sha1(Hi, \"Server Key\");\n        const clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\n        connection._sasl_data[\"server-signature\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\n\n        for (k = 0; k < 5; k++) {\n            clientKey[k] ^= clientSignature[k];\n        }\n        responseText += \",p=\" + btoa(SHA1.binb2str(clientKey));\n        return responseText;\n    }\n    return auth_str;\n};\n\n\n/** PrivateConstructor: SASLMD5\n *  SASL DIGEST MD5 authentication.\n */\nStrophe.SASLMD5 = function() {};\nStrophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 60);\n\nStrophe.SASLMD5.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\n/** PrivateFunction: _quote\n *  _Private_ utility function to backslash escape and quote strings.\n *\n *  Parameters:\n *    (String) str - The string to be quoted.\n *\n *  Returns:\n *    quoted string\n */\nStrophe.SASLMD5.prototype._quote = function (str) {\n    return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"';\n    //\" end string workaround for emacs\n};\n\nStrophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n    const attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n    const cnonce = test_cnonce || MD5.hexdigest(\"\" + (Math.random() * 1234567890));\n    let realm = \"\";\n    let host = null;\n    let nonce = \"\";\n    let qop = \"\";\n\n    while (challenge.match(attribMatch)) {\n        const matches = challenge.match(attribMatch);\n        challenge = challenge.replace(matches[0], \"\");\n        matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n        switch (matches[1]) {\n        case \"realm\":\n           realm = matches[2];\n           break;\n        case \"nonce\":\n           nonce = matches[2];\n           break;\n        case \"qop\":\n           qop = matches[2];\n           break;\n        case \"host\":\n           host = matches[2];\n           break;\n        }\n    }\n    let digest_uri = connection.servtype + \"/\" + connection.domain;\n    if (host !== null) {\n        digest_uri = digest_uri + \"/\" + host;\n    }\n\n    const cred = utils.utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n    const A1 = MD5.hash(cred) + \":\" + nonce + \":\" + cnonce;\n    const A2 = 'AUTHENTICATE:' + digest_uri;\n\n    let responseText = \"\";\n    responseText += 'charset=utf-8,';\n    responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\n    responseText += 'realm=' + this._quote(realm) + ',';\n    responseText += 'nonce=' + this._quote(nonce) + ',';\n    responseText += 'nc=00000001,';\n    responseText += 'cnonce=' + this._quote(cnonce) + ',';\n    responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n    responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \":\" +\n                                                nonce + \":00000001:\" +\n                                                cnonce + \":auth:\" +\n                                                MD5.hexdigest(A2)) + \",\";\n    responseText += 'qop=auth';\n    this.onChallenge = () => \"\";\n    return responseText;\n};\n\n\n/** PrivateConstructor: SASLOAuthBearer\n *  SASL OAuth Bearer authentication.\n */\nStrophe.SASLOAuthBearer = function() {};\nStrophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 40);\n\nStrophe.SASLOAuthBearer.prototype.test = function(connection) {\n    return connection.pass !== null;\n};\n\nStrophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {\n    let auth_str = 'n,';\n    if (connection.authcid !== null) {\n        auth_str = auth_str + 'a=' + connection.authzid;\n    }\n    auth_str = auth_str + ',';\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + 'auth=Bearer ';\n    auth_str = auth_str + connection.pass;\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + \"\\u0001\";\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLExternal\n *  SASL EXTERNAL authentication.\n *\n *  The EXTERNAL mechanism allows a client to request the server to use\n *  credentials established by means external to the mechanism to\n *  authenticate the client. The external means may be, for instance,\n *  TLS services.\n */\nStrophe.SASLExternal = function() {};\nStrophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 10);\n\nStrophe.SASLExternal.prototype.onChallenge = function(connection) {\n    /** According to XEP-178, an authzid SHOULD NOT be presented when the\n     * authcid contained or implied in the client certificate is the JID (i.e.\n     * authzid) with which the user wants to log in as.\n     *\n     * To NOT send the authzid, the user should therefore set the authcid equal\n     * to the JID when instantiating a new Strophe.Connection object.\n     */\n    return connection.authcid === connection.authzid ? '' : connection.authzid;\n};\n\n\n/** PrivateConstructor: SASLXOAuth2\n *  SASL X-OAuth2 authentication.\n */\nStrophe.SASLXOAuth2 = function () { };\nStrophe.SASLXOAuth2.prototype = new Strophe.SASLMechanism(\"X-OAUTH2\", true, 30);\n\nStrophe.SASLXOAuth2.prototype.test = function (connection) {\n    return connection.pass !== null;\n};\n\nStrophe.SASLXOAuth2.prototype.onChallenge = function (connection) {\n    let auth_str = '\\u0000';\n    if (connection.authcid !== null) {\n        auth_str = auth_str + connection.authzid;\n    }\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.pass;\n    return utils.utf16to8(auth_str);\n};\n\nexport { Strophe, $build, $iq, $msg, $pres, SHA1, MD5 };\n\nexport default {\n    'Strophe':         Strophe,\n    '$build':          $build,\n    '$iq':             $iq,\n    '$msg':            $msg,\n    '$pres':           $pres,\n    'SHA1':            SHA1,\n    'MD5':             MD5,\n    'b64_hmac_sha1':   SHA1.b64_hmac_sha1,\n    'b64_sha1':        SHA1.b64_sha1,\n    'str_hmac_sha1':   SHA1.str_hmac_sha1,\n    'str_sha1':        SHA1.str_sha1\n};\n","/*global global*/\n\nimport * as Strophe from 'core';\nimport * as bosh from 'bosh';\nimport * as websocket from 'websocket';\n\nglobal.Strophe = Strophe.default.Strophe;\nglobal.$build = Strophe.default.$build;\nglobal.$iq = Strophe.default.$iq;\nglobal.$msg = Strophe.default.$msg;\nglobal.$pres = Strophe.default.$pres;\n\nexport { default } from 'core';\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* global window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject */\n\nimport core from 'core';\n\nconst Strophe = core.Strophe;\nconst $build = core.$build;\n\n\n/** PrivateClass: Strophe.Request\n *  _Private_ helper class that provides a cross implementation abstraction\n *  for a BOSH related XMLHttpRequest.\n *\n *  The Strophe.Request class is used internally to encapsulate BOSH request\n *  information.  It is not meant to be used from user's code.\n */\n\n/** PrivateConstructor: Strophe.Request\n *  Create and initialize a new Strophe.Request object.\n *\n *  Parameters:\n *    (XMLElement) elem - The XML data to be sent in the request.\n *    (Function) func - The function that will be called when the\n *      XMLHttpRequest readyState changes.\n *    (Integer) rid - The BOSH rid attribute associated with this request.\n *    (Integer) sends - The number of times this same request has been sent.\n */\nStrophe.Request = function (elem, func, rid, sends) {\n    this.id = ++Strophe._requestId;\n    this.xmlData = elem;\n    this.data = Strophe.serialize(elem);\n    // save original function in case we need to make a new request\n    // from this one.\n    this.origFunc = func;\n    this.func = func;\n    this.rid = rid;\n    this.date = NaN;\n    this.sends = sends || 0;\n    this.abort = false;\n    this.dead = null;\n\n    this.age = function () {\n        if (!this.date) { return 0; }\n        const now = new Date();\n        return (now - this.date) / 1000;\n    };\n    this.timeDead = function () {\n        if (!this.dead) { return 0; }\n        const now = new Date();\n        return (now - this.dead) / 1000;\n    };\n    this.xhr = this._newXHR();\n};\n\nStrophe.Request.prototype = {\n    /** PrivateFunction: getResponse\n     *  Get a response from the underlying XMLHttpRequest.\n     *\n     *  This function attempts to get a response from the request and checks\n     *  for errors.\n     *\n     *  Throws:\n     *    \"parsererror\" - A parser error occured.\n     *    \"bad-format\" - The entity has sent XML that cannot be processed.\n     *\n     *  Returns:\n     *    The DOM element tree of the response.\n     */\n    getResponse: function () {\n        let node = null;\n        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n            node = this.xhr.responseXML.documentElement;\n            if (node.tagName === \"parsererror\") {\n                Strophe.error(\"invalid response received\");\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                Strophe.error(\"responseXML: \" +\n                              Strophe.serialize(this.xhr.responseXML));\n                throw new Error(\"parsererror\");\n            }\n        } else if (this.xhr.responseText) {\n            // In React Native, we may get responseText but no responseXML.  We can try to parse it manually.\n            Strophe.debug(\"Got responseText but no responseXML; attempting to parse it with DOMParser...\");\n            node = new DOMParser().parseFromString(this.xhr.responseText, 'application/xml').documentElement;\n            if (!node) {\n                throw new Error('Parsing produced null node');\n            } else if (node.querySelector('parsererror')) {\n                Strophe.error(\"invalid response received: \" + node.querySelector('parsererror').textContent);\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                const error = new Error();\n                error.name = Strophe.ErrorCondition.BAD_FORMAT;\n                throw error;\n            }\n        }\n        return node;\n    },\n\n    /** PrivateFunction: _newXHR\n     *  _Private_ helper function to create XMLHttpRequests.\n     *\n     *  This function creates XMLHttpRequests across all implementations.\n     *\n     *  Returns:\n     *    A new XMLHttpRequest.\n     */\n    _newXHR: function () {\n        let xhr = null;\n        if (window.XMLHttpRequest) {\n            xhr = new XMLHttpRequest();\n            if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n            }\n        } else if (window.ActiveXObject) {\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n        // use Function.bind() to prepend ourselves as an argument\n        xhr.onreadystatechange = this.func.bind(null, this);\n        return xhr;\n    }\n};\n\n/** Class: Strophe.Bosh\n *  _Private_ helper class that handles BOSH Connections\n *\n *  The Strophe.Bosh class is used internally by Strophe.Connection\n *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n */\n\n/** File: bosh.js\n *  A JavaScript library to enable BOSH in Strophejs.\n *\n *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n *  More information on BOSH can be found in XEP 124.\n */\n\n/** PrivateConstructor: Strophe.Bosh\n *  Create and initialize a Strophe.Bosh object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n *\n *  Returns:\n *    A new Strophe.Bosh object.\n */\nStrophe.Bosh = function(connection) {\n    this._conn = connection;\n    /* request id for body tags */\n    this.rid = Math.floor(Math.random() * 4294967295);\n    /* The current session ID. */\n    this.sid = null;\n\n    // default BOSH values\n    this.hold = 1;\n    this.wait = 60;\n    this.window = 5;\n    this.errors = 0;\n    this.inactivity = null;\n\n    this.lastResponseHeaders = null;\n    this._requests = [];\n};\n\nStrophe.Bosh.prototype = {\n    /** Variable: strip\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n     *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n     *\n     *  > Strophe.Bosh.prototype.strip = \"body\";\n     *\n     *  This will enable stripping of the body tag in both\n     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n     */\n    strip: null,\n\n    /** PrivateFunction: _buildBody\n     *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <body/> element.\n     */\n    _buildBody: function () {\n        const bodyWrap = $build('body', {\n            'rid': this.rid++,\n            'xmlns': Strophe.NS.HTTPBIND\n        });\n        if (this.sid !== null) {\n            bodyWrap.attrs({'sid': this.sid});\n        }\n        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n            this._cacheSession();\n        }\n        return bodyWrap;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection\n     */\n    _reset: function () {\n        this.rid = Math.floor(Math.random() * 4294967295);\n        this.sid = null;\n        this.errors = 0;\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function that initializes the BOSH connection.\n     *\n     *  Creates and sends the Request that initializes the BOSH connection.\n     */\n    _connect: function (wait, hold, route) {\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.errors = 0;\n\n        const body = this._buildBody().attrs({\n            \"to\": this._conn.domain,\n            \"xml:lang\": \"en\",\n            \"wait\": this.wait,\n            \"hold\": this.hold,\n            \"content\": \"text/xml; charset=utf-8\",\n            \"ver\": \"1.6\",\n            \"xmpp:version\": \"1.0\",\n            \"xmlns:xmpp\": Strophe.NS.BOSH\n        });\n        if (route){\n            body.attrs({'route': route});\n        }\n\n        const _connect_cb = this._conn._connect_cb;\n        this._requests.push(\n            new Strophe.Request(\n                body.tree(),\n                this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)),\n                body.tree().getAttribute(\"rid\")\n            )\n        );\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        this._conn.jid = jid;\n        this.sid = sid;\n        this.rid = rid;\n\n        this._conn.connect_callback = callback;\n        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n        this._conn.authenticated = true;\n        this._conn.connected = true;\n\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.window = wind || this.window;\n\n        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n    },\n\n    /** PrivateFunction: _restore\n     *  Attempt to restore a cached BOSH session\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *      This parameter is optional but recommended, specifically in cases\n     *      where prebinded BOSH sessions are used where it's important to know\n     *      that the right session is being restored.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _restore: function (jid, callback, wait, hold, wind) {\n        const session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n        if (typeof session !== \"undefined\" &&\n                   session !== null &&\n                   session.rid &&\n                   session.sid &&\n                   session.jid &&\n                   (    typeof jid === \"undefined\" ||\n                        jid === null ||\n                        Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) ||\n                        // If authcid is null, then it's an anonymous login, so\n                        // we compare only the domains:\n                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) === jid))\n                    )\n        ) {\n            this._conn.restored = true;\n            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n        } else {\n            const error = new Error(\"_restore: no restoreable session.\");\n            error.name = \"StropheSessionError\";\n            throw error;\n        }\n    },\n\n    /** PrivateFunction: _cacheSession\n     *  _Private_ handler for the beforeunload event.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _cacheSession: function () {\n        if (this._conn.authenticated) {\n            if (this._conn.jid && this.rid && this.sid) {\n                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n                    'jid': this._conn.jid,\n                    'rid': this.rid,\n                    'sid': this.sid\n                }));\n            }\n        } else {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function (bodyWrap) {\n        const typ = bodyWrap.getAttribute(\"type\");\n        if (typ !== null && typ === \"terminate\") {\n            // an error occurred\n            let cond = bodyWrap.getAttribute(\"condition\");\n            Strophe.error(\"BOSH-Connection failed: \" + cond);\n            const conflict = bodyWrap.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n            }\n            this._conn._doDisconnect(cond);\n            return Strophe.Status.CONNFAIL;\n        }\n\n        // check to make sure we don't overwrite these if _connect_cb is\n        // called multiple times in the case of missing stream:features\n        if (!this.sid) {\n            this.sid = bodyWrap.getAttribute(\"sid\");\n        }\n        const wind = bodyWrap.getAttribute('requests');\n        if (wind) { this.window = parseInt(wind, 10); }\n        const hold = bodyWrap.getAttribute('hold');\n        if (hold) { this.hold = parseInt(hold, 10); }\n        const wait = bodyWrap.getAttribute('wait');\n        if (wait) { this.wait = parseInt(wait, 10); }\n        const inactivity = bodyWrap.getAttribute('inactivity');\n        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ part of Connection.disconnect for Bosh\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        this._sendTerminate(pres);\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Resets the SID and RID.\n     */\n    _doDisconnect: function () {\n        this.sid = null;\n        this.rid = Math.floor(Math.random() * 4294967295);\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the Request queue is empty.\n     *\n     *  Returns:\n     *    True, if there are no Requests queued, False otherwise.\n     */\n    _emptyQueue: function () {\n        return this._requests.length === 0;\n    },\n\n    /** PrivateFunction: _callProtocolErrorHandlers\n     *  _Private_ function to call error handlers registered for HTTP errors.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _callProtocolErrorHandlers: function (req) {\n        const reqStatus = this._getRequestStatus(req);\n        const err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\n        if (err_callback) {\n            err_callback.call(this, reqStatus);\n        }\n    },\n\n    /** PrivateFunction: _hitError\n     *  _Private_ function to handle the error count.\n     *\n     *  Requests are resent automatically until their error count reaches\n     *  5.  Each time an error is encountered, this function is called to\n     *  increment the count and disconnect if the count is too high.\n     *\n     *  Parameters:\n     *    (Integer) reqStatus - The request status.\n     */\n    _hitError: function (reqStatus) {\n        this.errors++;\n        Strophe.warn(\"request errored, status: \" + reqStatus +\n                     \", number of errors: \" + this.errors);\n        if (this.errors > 4) {\n            this._conn._onDisconnectTimeout();\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received and sends a blank poll request.\n     */\n    _no_auth_received: function (callback) {\n        Strophe.warn(\"Server did not yet offer a supported authentication \"+\n                     \"mechanism. Sending a blank poll request.\");\n        if (callback) {\n            callback = callback.bind(this._conn);\n        } else {\n            callback = this._conn._connect_cb.bind(this._conn);\n        }\n        const body = this._buildBody();\n        this._requests.push(\n            new Strophe.Request(\n                body.tree(),\n                this._onRequestStateChange.bind(this, callback),\n                body.tree().getAttribute(\"rid\")\n            )\n        );\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  Cancels all remaining Requests and clears the queue.\n     */\n    _onDisconnectTimeout: function () {\n        this._abortAllRequests();\n    },\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function _abortAllRequests() {\n        while (this._requests.length > 0) {\n            const req = this._requests.pop();\n            req.abort = true;\n            req.xhr.abort();\n            // jslint complains, but this is fine. setting to empty func\n            // is necessary for IE6\n            req.xhr.onreadystatechange = function () {}; // jshint ignore:line\n        }\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler called by Strophe.Connection._onIdle\n     *\n     *  Sends all queued Requests or polls with empty Request if there are none.\n     */\n    _onIdle: function () {\n        const data = this._conn._data;\n        // if no requests are in progress, poll\n        if (this._conn.authenticated && this._requests.length === 0 &&\n            data.length === 0 && !this._conn.disconnecting) {\n            Strophe.debug(\"no requests during idle cycle, sending blank request\");\n            data.push(null);\n        }\n\n        if (this._conn.paused) {\n            return;\n        }\n\n        if (this._requests.length < 2 && data.length > 0) {\n            const body = this._buildBody();\n            for (let i=0; i<data.length; i++) {\n                if (data[i] !== null) {\n                    if (data[i] === \"restart\") {\n                        body.attrs({\n                            \"to\": this._conn.domain,\n                            \"xml:lang\": \"en\",\n                            \"xmpp:restart\": \"true\",\n                            \"xmlns:xmpp\": Strophe.NS.BOSH\n                        });\n                    } else {\n                        body.cnode(data[i]).up();\n                    }\n                }\n            }\n            delete this._conn._data;\n            this._conn._data = [];\n            this._requests.push(\n                new Strophe.Request(\n                    body.tree(),\n                    this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),\n                    body.tree().getAttribute(\"rid\")\n                )\n            );\n            this._throttledRequestHandler();\n        }\n\n        if (this._requests.length > 0) {\n            const time_elapsed = this._requests[0].age();\n            if (this._requests[0].dead !== null) {\n                if (this._requests[0].timeDead() >\n                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                    this._throttledRequestHandler();\n                }\n            }\n            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n                Strophe.warn(\"Request \" +\n                             this._requests[0].id +\n                             \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) +\n                             \" seconds since last activity\");\n                this._throttledRequestHandler();\n            }\n        }\n    },\n\n    /** PrivateFunction: _getRequestStatus\n     *\n     *  Returns the HTTP status code from a Strophe.Request\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The Strophe.Request instance.\n     *    (Integer) def - The default value that should be returned if no\n     *          status value was found.\n     */\n    _getRequestStatus: function (req, def) {\n        let reqStatus;\n        if (req.xhr.readyState === 4) {\n            try {\n                reqStatus = req.xhr.status;\n            } catch (e) {\n                // ignore errors from undefined status attribute. Works\n                // around a browser bug\n                Strophe.error(\n                    \"Caught an error while retrieving a request's status, \" +\n                    \"reqStatus: \" + reqStatus);\n            }\n        }\n        if (typeof(reqStatus) === \"undefined\") {\n            reqStatus = typeof def === 'number' ? def : 0;\n        }\n        return reqStatus;\n    },\n\n    /** PrivateFunction: _onRequestStateChange\n     *  _Private_ handler for Strophe.Request state changes.\n     *\n     *  This function is called when the XMLHttpRequest readyState changes.\n     *  It contains a lot of error handling logic for the many ways that\n     *  requests can fail, and calls the request callback when requests\n     *  succeed.\n     *\n     *  Parameters:\n     *    (Function) func - The handler for the request.\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _onRequestStateChange: function (func, req) {\n        Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\n                      \" state changed to \"+req.xhr.readyState);\n        if (req.abort) {\n            req.abort = false;\n            return;\n        }\n        if (req.xhr.readyState !== 4) {\n            // The request is not yet complete\n            return;\n        }\n        const reqStatus = this._getRequestStatus(req);\n        this.lastResponseHeaders = req.xhr.getAllResponseHeaders();\n        if (this.disconnecting && reqStatus >= 400) {\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            return;\n        }\n\n        const valid_request = reqStatus > 0 && reqStatus < 500;\n        const too_many_retries = req.sends > this._conn.maxRetries;\n        if (valid_request || too_many_retries) {\n            // remove from internal queue\n            this._removeRequest(req);\n            Strophe.debug(\"request id \"+req.id+\" should now be removed\");\n        }\n\n        if (reqStatus === 200) {\n            // request succeeded\n            const reqIs0 = (this._requests[0] === req);\n            const reqIs1 = (this._requests[1] === req);\n            // if request 1 finished, or request 0 finished and request\n            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n            // restart the other - both will be in the first spot, as the\n            // completed request has been removed from the queue already\n            if (reqIs1 ||\n                (reqIs0 && this._requests.length > 0 &&\n                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {\n                this._restartRequest(0);\n            }\n            this._conn.nextValidRid(Number(req.rid) + 1);\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" got 200\");\n            func(req); // call handler\n            this.errors = 0;\n        } else if (reqStatus === 0 ||\n                   (reqStatus >= 400 && reqStatus < 600) ||\n                   reqStatus >= 12000) {\n            // request failed\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            if (reqStatus >= 400 && reqStatus < 500) {\n                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n                this._conn._doDisconnect();\n            }\n        } else {\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n        }\n\n        if (!valid_request && !too_many_retries) {\n            this._throttledRequestHandler();\n        } else if (too_many_retries && !this._conn.connected) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"giving-up\");\n        }\n    },\n\n    /** PrivateFunction: _processRequest\n     *  _Private_ function to process a request in the queue.\n     *\n     *  This function takes requests off the queue and sends them and\n     *  restarts dead requests.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _processRequest: function (i) {\n        let req = this._requests[i];\n        const reqStatus = this._getRequestStatus(req, -1);\n\n        // make sure we limit the number of retries\n        if (req.sends > this._conn.maxRetries) {\n            this._conn._onDisconnectTimeout();\n            return;\n        }\n        const time_elapsed = req.age();\n        const primary_timeout = (!isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));\n        const secondary_timeout = (req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));\n        const server_error = (req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500));\n\n        if (primary_timeout || secondary_timeout || server_error) {\n            if (secondary_timeout) {\n                Strophe.error(`Request ${this._requests[i].id} timed out (secondary), restarting`);\n            }\n            req.abort = true;\n            req.xhr.abort();\n            // setting to null fails on IE6, so set to empty function\n            req.xhr.onreadystatechange = function () {};\n            this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);\n            req = this._requests[i];\n        }\n\n        if (req.xhr.readyState === 0) {\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" posting\");\n\n            try {\n                const content_type = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n                req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n                if (typeof req.xhr.setRequestHeader !== 'undefined') {\n                    // IE9 doesn't have setRequestHeader\n                    req.xhr.setRequestHeader(\"Content-Type\", content_type);\n                }\n                if (this._conn.options.withCredentials) {\n                    req.xhr.withCredentials = true;\n                }\n            } catch (e2) {\n                Strophe.error(\"XHR open failed: \" + e2.toString());\n                if (!this._conn.connected) {\n                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"bad-service\");\n                }\n                this._conn.disconnect();\n                return;\n            }\n\n            // Fires the XHR request -- may be invoked immediately\n            // or on a gradually expanding retry window for reconnects\n            const sendFunc = () => {\n                req.date = new Date();\n                if (this._conn.options.customHeaders){\n                    const headers = this._conn.options.customHeaders;\n                    for (const header in headers) {\n                        if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                            req.xhr.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n                req.xhr.send(req.data);\n            };\n\n            // Implement progressive backoff for reconnects --\n            // First retry (send === 1) should also be instantaneous\n            if (req.sends > 1) {\n                // Using a cube of the retry number creates a nicely\n                // expanding retry window\n                const backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),\n                                       Math.pow(req.sends, 3)) * 1000;\n                setTimeout(function() {\n                    // XXX: setTimeout should be called only with function expressions (23974bc1)\n                    sendFunc();\n                }, backoff);\n            } else {\n                sendFunc();\n            }\n\n            req.sends++;\n\n            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n                    this._conn.xmlOutput(req.xmlData.childNodes[0]);\n                } else {\n                    this._conn.xmlOutput(req.xmlData);\n                }\n            }\n            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n                this._conn.rawOutput(req.data);\n            }\n        } else {\n            Strophe.debug(\"_processRequest: \" +\n                          (i === 0 ? \"first\" : \"second\") +\n                          \" request has readyState of \" +\n                          req.xhr.readyState);\n        }\n    },\n\n    /** PrivateFunction: _removeRequest\n     *  _Private_ function to remove a request from the queue.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request to remove.\n     */\n    _removeRequest: function (req) {\n        Strophe.debug(\"removing request\");\n        for (let i=this._requests.length - 1; i>=0; i--) {\n            if (req === this._requests[i]) {\n                this._requests.splice(i, 1);\n            }\n        }\n        // IE6 fails on setting to null, so set to empty function\n        req.xhr.onreadystatechange = function () {};\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _restartRequest\n     *  _Private_ function to restart a request that is presumed dead.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _restartRequest: function (i) {\n        const req = this._requests[i];\n        if (req.dead === null) {\n            req.dead = new Date();\n        }\n        this._processRequest(i);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * Tries to extract a stanza out of a Request Object.\n     * When this fails the current connection will be disconnected.\n     *\n     *  Parameters:\n     *    (Object) req - The Request.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (req) {\n        try {\n            return req.getResponse();\n        } catch (e) {\n            if (e.message !== \"parsererror\") { throw e; }\n            this._conn.disconnect(\"strophe-parsererror\");\n        }\n    },\n\n    /** PrivateFunction: _sendTerminate\n     *  _Private_ function to send initial disconnect sequence.\n     *\n     *  This is the first step in a graceful disconnect.  It sends\n     *  the BOSH server a terminate body and includes an unavailable\n     *  presence if authentication has completed.\n     */\n    _sendTerminate: function (pres) {\n        Strophe.debug(\"_sendTerminate was called\");\n        const body = this._buildBody().attrs({type: \"terminate\"});\n        if (pres) {\n            body.cnode(pres.tree());\n        }\n        const req = new Strophe.Request(\n            body.tree(),\n            this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)),\n            body.tree().getAttribute(\"rid\")\n        );\n        this._requests.push(req);\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for BOSH\n     *\n     * Just triggers the RequestHandler to send the messages that are in the queue\n     */\n    _send: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._throttledRequestHandler();\n        this._conn._idleTimeout = setTimeout(() => this._conn._onIdle(), 100);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._throttledRequestHandler();\n        clearTimeout(this._conn._idleTimeout);\n    },\n\n    /** PrivateFunction: _throttledRequestHandler\n     *  _Private_ function to throttle requests to the connection window.\n     *\n     *  This function makes sure we don't send requests so fast that the\n     *  request ids overflow the connection window in the case that one\n     *  request died.\n     */\n    _throttledRequestHandler: function () {\n        if (!this._requests) {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          \"undefined requests\");\n        } else {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          this._requests.length + \" requests\");\n        }\n\n        if (!this._requests || this._requests.length === 0) {\n            return;\n        }\n\n        if (this._requests.length > 0) {\n            this._processRequest(0);\n        }\n\n        if (this._requests.length > 1 &&\n            Math.abs(this._requests[0].rid -\n                     this._requests[1].rid) < this.window) {\n            this._processRequest(1);\n        }\n    }\n};\n","/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* global window, clearTimeout, WebSocket, DOMParser */\n\nimport core from 'core';\n\nconst Strophe = core.Strophe;\nconst $build = core.$build;\n\n\n/** Class: Strophe.WebSocket\n *  _Private_ helper class that handles WebSocket Connections\n *\n *  The Strophe.WebSocket class is used internally by Strophe.Connection\n *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n */\n\n/** File: websocket.js\n *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n *\n *  This file implements XMPP over WebSockets for Strophejs.\n *  If a Connection is established with a Websocket url (ws://...)\n *  Strophe will use WebSockets.\n *  For more information on XMPP-over-WebSocket see RFC 7395:\n *  http://tools.ietf.org/html/rfc7395\n *\n *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n */\n\n/** PrivateConstructor: Strophe.Websocket\n *  Create and initialize a Strophe.WebSocket object.\n *  Currently only sets the connection Object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n *\n *  Returns:\n *    A new Strophe.WebSocket object.\n */\nStrophe.Websocket = function(connection) {\n    this._conn = connection;\n    this.strip = \"wrapper\";\n\n    const service = connection.service;\n    if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n        // If the service is not an absolute URL, assume it is a path and put the absolute\n        // URL together from options, current URL and the path.\n        let new_service = \"\";\n        if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n            new_service += \"ws\";\n        } else {\n            new_service += \"wss\";\n        }\n\n        new_service += \"://\" + window.location.host;\n        if (service.indexOf(\"/\") !== 0) {\n            new_service += window.location.pathname + service;\n        } else {\n            new_service += service;\n        }\n        connection.service = new_service;\n    }\n};\n\nStrophe.Websocket.prototype = {\n    /** PrivateFunction: _buildStream\n     *  _Private_ helper function to generate the <stream> start tag for WebSockets\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <stream> element.\n     */\n    _buildStream: function () {\n        return $build(\"open\", {\n            \"xmlns\": Strophe.NS.FRAMING,\n            \"to\": this._conn.domain,\n            \"version\": '1.0'\n        });\n    },\n\n    /** PrivateFunction: _check_streamerror\n     * _Private_ checks a message for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     *    connectstatus - The ConnectStatus that will be set on error.\n     *  Returns:\n     *     true if there was a streamerror, false otherwise.\n     */\n    _check_streamerror: function (bodyWrap, connectstatus) {\n        let errors;\n        if (bodyWrap.getElementsByTagNameNS) {\n            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n        } else {\n            errors = bodyWrap.getElementsByTagName(\"stream:error\");\n        }\n        if (errors.length === 0) {\n            return false;\n        }\n        const error = errors[0];\n\n        let condition = \"\";\n        let text = \"\";\n\n        const ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n        for (let i=0; i<error.childNodes.length; i++) {\n            const e = error.childNodes[i];\n            if (e.getAttribute(\"xmlns\") !== ns) {\n                break;\n            } if (e.nodeName === \"text\") {\n                text = e.textContent;\n            } else {\n                condition = e.nodeName;\n            }\n        }\n\n        let errorString = \"WebSocket stream error: \";\n        if (condition) {\n            errorString += condition;\n        } else {\n            errorString += \"unknown\";\n        }\n        if (text) {\n            errorString += \" - \" + text;\n        }\n        Strophe.error(errorString);\n\n        // close the connection on stream_error\n        this._conn._changeConnectStatus(connectstatus, condition);\n        this._conn._doDisconnect();\n        return true;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection.\n     *  Is not needed by WebSockets.\n     */\n    _reset: function () {\n        return;\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function called by Strophe.Connection.connect\n     *\n     *  Creates a WebSocket for a connection and assigns Callbacks to it.\n     *  Does nothing if there already is a WebSocket.\n     */\n    _connect: function () {\n        // Ensure that there is no open WebSocket from a previous Connection.\n        this._closeSocket();\n\n        // Create the new WobSocket\n        this.socket = new WebSocket(this._conn.service, \"xmpp\");\n        this.socket.onopen = this._onOpen.bind(this);\n        this.socket.onerror = this._onError.bind(this);\n        this.socket.onclose = this._onClose.bind(this);\n        this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ function called by Strophe.Connection._connect_cb\n     *\n     * checks for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function(bodyWrap) {\n        const error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n        if (error) {\n            return Strophe.Status.CONNFAIL;\n        }\n    },\n\n    /** PrivateFunction: _handleStreamStart\n     * _Private_ function that checks the opening <open /> tag for errors.\n     *\n     * Disconnects if there is an error and returns false, true otherwise.\n     *\n     *  Parameters:\n     *    (Node) message - Stanza containing the <open /> tag.\n     */\n    _handleStreamStart: function(message) {\n        let error = false;\n\n        // Check for errors in the <open /> tag\n        const ns = message.getAttribute(\"xmlns\");\n        if (typeof ns !== \"string\") {\n            error = \"Missing xmlns in <open />\";\n        } else if (ns !== Strophe.NS.FRAMING) {\n            error = \"Wrong xmlns in <open />: \" + ns;\n        }\n\n        const ver = message.getAttribute(\"version\");\n        if (typeof ver !== \"string\") {\n            error = \"Missing version in <open />\";\n        } else if (ver !== \"1.0\") {\n            error = \"Wrong version in <open />: \" + ver;\n        }\n\n        if (error) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n            this._conn._doDisconnect();\n            return false;\n        }\n        return true;\n    },\n\n    /** PrivateFunction: _connect_cb_wrapper\n     * _Private_ function that handles the first connection messages.\n     *\n     * On receiving an opening stream tag this callback replaces itself with the real\n     * message handler. On receiving a stream error the connection is terminated.\n     */\n    _connect_cb_wrapper: function(message) {\n        if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n            // Strip the XML Declaration, if there is one\n            const data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n            if (data === '') return;\n\n            const streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n            this._conn.xmlInput(streamStart);\n            this._conn.rawInput(message.data);\n\n            //_handleStreamSteart will check for XML errors and disconnect on error\n            if (this._handleStreamStart(streamStart)) {\n                //_connect_cb will check for stream:error and disconnect on error\n                this._connect_cb(streamStart);\n            }\n        } else if (message.data.indexOf(\"<close \") === 0) { // <close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />\n            // Parse the raw string to an XML element\n            const parsedMessage = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n            // Report this input to the raw and xml handlers\n            this._conn.xmlInput(parsedMessage);\n            this._conn.rawInput(message.data);\n            const see_uri = parsedMessage.getAttribute(\"see-other-uri\");\n            if (see_uri) {\n                const service = this._conn.service;\n                // Valid scenarios: WSS->WSS, WS->ANY\n                const isSecureRedirect = (service.indexOf(\"wss:\") >= 0 && see_uri.indexOf(\"wss:\") >= 0) || (service.indexOf(\"ws:\") >= 0);\n                if (isSecureRedirect) {\n                    this._conn._changeConnectStatus(\n                        Strophe.Status.REDIRECT,\n                        \"Received see-other-uri, resetting connection\"\n                    );\n                    this._conn.reset();\n                    this._conn.service = see_uri;\n                    this._connect();\n                }\n            } else {\n                this._conn._changeConnectStatus(\n                    Strophe.Status.CONNFAIL,\n                    \"Received closing stream\"\n                );\n                this._conn._doDisconnect();\n            }\n        } else {\n            const string = this._streamWrap(message.data);\n            const elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n            this.socket.onmessage = this._onMessage.bind(this);\n            this._conn._connect_cb(elem, null, message.data);\n        }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ function called by Strophe.Connection.disconnect\n     *\n     *  Disconnects and sends a last stanza if one is given\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n            if (pres) {\n                this._conn.send(pres);\n            }\n            const close = $build(\"close\", { \"xmlns\": Strophe.NS.FRAMING });\n            this._conn.xmlOutput(close.tree());\n            const closeString = Strophe.serialize(close);\n            this._conn.rawOutput(closeString);\n            try {\n                this.socket.send(closeString);\n            } catch (e) {\n                Strophe.warn(\"Couldn't send <close /> tag.\");\n            }\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Just closes the Socket for WebSockets\n     */\n    _doDisconnect: function () {\n        Strophe.debug(\"WebSockets _doDisconnect was called\");\n        this._closeSocket();\n    },\n\n    /** PrivateFunction _streamWrap\n     *  _Private_ helper function to wrap a stanza in a <stream> tag.\n     *  This is used so Strophe can process stanzas from WebSockets like BOSH\n     */\n    _streamWrap: function (stanza) {\n        return \"<wrapper>\" + stanza + '</wrapper>';\n    },\n\n\n    /** PrivateFunction: _closeSocket\n     *  _Private_ function to close the WebSocket.\n     *\n     *  Closes the socket if it is still open and deletes it\n     */\n    _closeSocket: function () {\n        if (this.socket) {\n            try {\n                this.socket.onerror = null;\n                this.socket.close();\n            } catch (e) {\n                Strophe.debug(e.message);\n            }\n        }\n        this.socket = null;\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the message queue is empty.\n     *\n     *  Returns:\n     *    True, because WebSocket messages are send immediately after queueing.\n     */\n    _emptyQueue: function () {\n        return true;\n    },\n\n    /** PrivateFunction: _onClose\n     * _Private_ function to handle websockets closing.\n     *\n     * Nothing to do here for WebSockets\n     */\n    _onClose: function(e) {\n        if (this._conn.connected && !this._conn.disconnecting) {\n            Strophe.error(\"Websocket closed unexpectedly\");\n            this._conn._doDisconnect();\n        } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\n            // in case the onError callback was not called (Safari 10 does not\n            // call onerror when the initial connection fails) we need to\n            // dispatch a CONNFAIL status update to be consistent with the\n            // behavior on other browsers.\n            Strophe.error(\"Websocket closed unexcectedly\");\n            this._conn._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                \"The WebSocket connection could not be established or was disconnected.\"\n            );\n            this._conn._doDisconnect();\n        } else {\n            Strophe.debug(\"Websocket closed\");\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received.\n     */\n    _no_auth_received: function (callback) {\n        Strophe.error(\"Server did not offer a supported authentication mechanism\");\n        this._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            Strophe.ErrorCondition.NO_AUTH_MECH\n        );\n        if (callback) {\n            callback.call(this._conn);\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  This does nothing for WebSockets\n     */\n    _onDisconnectTimeout: function () {},\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function () {},\n\n    /** PrivateFunction: _onError\n     * _Private_ function to handle websockets errors.\n     *\n     * Parameters:\n     * (Object) error - The websocket error.\n     */\n    _onError: function(error) {\n        Strophe.error(\"Websocket error \" + error);\n        this._conn._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            \"The WebSocket connection could not be established or was disconnected.\"\n        );\n        this._disconnect();\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ function called by Strophe.Connection._onIdle\n     *\n     *  sends all queued stanzas\n     */\n    _onIdle: function () {\n        const data = this._conn._data;\n        if (data.length > 0 && !this._conn.paused) {\n            for (let i=0; i<data.length; i++) {\n                if (data[i] !== null) {\n                    let stanza;\n                    if (data[i] === \"restart\") {\n                        stanza = this._buildStream().tree();\n                    } else {\n                        stanza = data[i];\n                    }\n                    const rawStanza = Strophe.serialize(stanza);\n                    this._conn.xmlOutput(stanza);\n                    this._conn.rawOutput(rawStanza);\n                    this.socket.send(rawStanza);\n                }\n            }\n            this._conn._data = [];\n        }\n    },\n\n    /** PrivateFunction: _onMessage\n     * _Private_ function to handle websockets messages.\n     *\n     * This function parses each of the messages as if they are full documents.\n     * [TODO : We may actually want to use a SAX Push parser].\n     *\n     * Since all XMPP traffic starts with\n     *  <stream:stream version='1.0'\n     *                 xml:lang='en'\n     *                 xmlns='jabber:client'\n     *                 xmlns:stream='http://etherx.jabber.org/streams'\n     *                 id='3697395463'\n     *                 from='SERVER'>\n     *\n     * The first stanza will always fail to be parsed.\n     *\n     * Additionally, the seconds stanza will always be <stream:features> with\n     * the stream NS defined in the previous stanza, so we need to 'force'\n     * the inclusion of the NS in this stanza.\n     *\n     * Parameters:\n     * (string) message - The websocket message.\n     */\n    _onMessage: function(message) {\n        let elem;\n        // check for closing stream\n        const close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n        if (message.data === close) {\n            this._conn.rawInput(close);\n            this._conn.xmlInput(message);\n            if (!this._conn.disconnecting) {\n                this._conn._doDisconnect();\n            }\n            return;\n        } else if (message.data.search(\"<open \") === 0) {\n            // This handles stream restarts\n            elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n            if (!this._handleStreamStart(elem)) {\n                return;\n            }\n        } else {\n            const data = this._streamWrap(message.data);\n            elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n        }\n\n        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n            return;\n        }\n\n        //handle unavailable presence stanza before disconnecting\n        if (this._conn.disconnecting &&\n                elem.firstChild.nodeName === \"presence\" &&\n                elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n            this._conn.xmlInput(elem);\n            this._conn.rawInput(Strophe.serialize(elem));\n            // if we are already disconnecting we will ignore the unavailable stanza and\n            // wait for the </stream:stream> tag before we close the connection\n            return;\n        }\n        this._conn._dataRecv(elem, message.data);\n    },\n\n    /** PrivateFunction: _onOpen\n     * _Private_ function to handle websockets connection setup.\n     *\n     * The opening stream tag is sent here.\n     */\n    _onOpen: function() {\n        Strophe.debug(\"Websocket open\");\n        const start = this._buildStream();\n        this._conn.xmlOutput(start.tree());\n\n        const startString = Strophe.serialize(start);\n        this._conn.rawOutput(startString);\n        this.socket.send(startString);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * WebSockets don't use requests, so the passed argument is just returned.\n     *\n     *  Parameters:\n     *    (Object) stanza - The stanza.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (stanza) {\n        return stanza;\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for WebSocket\n     *\n     * Just flushes the messages that are in the queue\n     */\n    _send: function () {\n        this._conn.flush();\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._conn._onIdle.bind(this._conn)();\n    }\n};\n"],"sourceRoot":""}