{"version":3,"sources":["index.ts"],"names":["State","setup","DeprecatedState","_isConnectedListeners","Map","fetch","latest","addEventListener","listenerOrType","deprecatedHandler","undefined","DeprecatedUtils","warnOnce","DeprecatedTypes","CHANGE_EVENT_NAME","add","remove","listener","useNetInfo","type","Types","NetInfoStateType","unknown","isConnected","isInternetReachable","details","netInfo","setNetInfo","removeEventListener","handler","getConnectionInfo","isConnectionExpensive","then","eventName","state","set","_eventName","get","delete"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {useState, useEffect} from 'react';\nimport DeprecatedUtils from './internal/deprecatedUtils';\nimport DeprecatedState from './internal/deprecatedState';\nimport * as DeprecatedTypes from './internal/deprecatedTypes';\nimport State from './internal/state';\nimport * as Types from './internal/types';\n\n// Call the setup methods of the two state modules right away\nState.setup();\nDeprecatedState.setup();\n\nconst _isConnectedListeners = new Map<\n  DeprecatedTypes.IsConnectedHandler,\n  /// @ts-ignore Typescript des not like the trailing comma that Prettier insists upon\n  Types.NetInfoChangeHandler\n>();\n\n/**\n * Returns a `Promise` that resolves to a `NetInfoState` object.\n *\n * @returns A Promise which contains the current connection state.\n */\nexport function fetch(): Promise<Types.NetInfoState> {\n  return State.latest();\n}\n\n/**\n * Subscribe to connection information. The callback is called with a parameter of type\n * [`NetInfoState`](README.md#netinfostate) whenever the connection state changes. Your listener\n * will be called with the latest information soon after you subscribe and then with any\n * subsequent changes afterwards. You should not assume that the listener is called in the same\n * way across devices or platforms.\n *\n * @param listener The listener which is called when the network state changes.\n *\n * @returns An ofunction which can be called to unsubscribe.\n */\nexport function addEventListener(\n  listener: Types.NetInfoChangeHandler,\n): Types.NetInfoSubscription;\n\n/**\n * Deprecated network state listener. You should remove the event name and change your handler to\n * use the new state shape.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param deprecatedHandler The listener.\n *\n * @returns An object with a remove function which can be called to unsubscribe.\n */\nexport function addEventListener(\n  type: string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler,\n): DeprecatedTypes.Subscription;\n\n// Implementation of the overloaded methods above\nexport function addEventListener(\n  listenerOrType: Types.NetInfoChangeHandler | string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler | undefined = undefined,\n): Types.NetInfoSubscription | DeprecatedTypes.Subscription {\n  if (typeof listenerOrType === 'string') {\n    DeprecatedUtils.warnOnce();\n\n    if (\n      listenerOrType === DeprecatedTypes.CHANGE_EVENT_NAME &&\n      deprecatedHandler\n    ) {\n      DeprecatedState.add(deprecatedHandler);\n      return {\n        remove: (): void => {\n          DeprecatedState.remove(deprecatedHandler);\n        },\n      };\n    } else {\n      return {\n        remove: (): void => {},\n      };\n    }\n  } else {\n    const listener = listenerOrType;\n    State.add(listener);\n    return (): void => {\n      State.remove(listener);\n    };\n  }\n}\n\n/**\n * A React Hook which updates when the connection state changes.\n *\n * @returns The connection state.\n */\nexport function useNetInfo(): Types.NetInfoState {\n  const [netInfo, setNetInfo] = useState<Types.NetInfoState>({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: false,\n    isInternetReachable: false,\n    details: null,\n  });\n\n  useEffect((): (() => void) => {\n    return addEventListener(setNetInfo);\n  }, []);\n\n  return netInfo;\n}\n\n/**\n * Deprecated method to remove the listener. You should upgrade to the new API.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param handler The event listener.\n */\nexport function removeEventListener(\n  type: string,\n  handler: DeprecatedTypes.ChangeHandler,\n): void {\n  DeprecatedUtils.warnOnce();\n\n  if (type === DeprecatedTypes.CHANGE_EVENT_NAME) {\n    DeprecatedState.remove(handler);\n  }\n}\n\n/**\n * Deprecated method to get the current state. You should upgrade to the new `fetch` method and\n * handle the new state type.\n *\n * @deprecated\n */\nexport function getConnectionInfo(): Promise<DeprecatedTypes.NetInfoData> {\n  DeprecatedUtils.warnOnce();\n  return DeprecatedState.latest();\n}\n\n/**\n * Deprecated method to tell if the current connection is \"expensive\". Only available on Android.\n * You should now call the `fetch` method and look at the `details.isConnectionExpensive` property.\n *\n * @deprecated\n */\nexport function isConnectionExpensive(): Promise<boolean> {\n  DeprecatedUtils.warnOnce();\n  return State.latest().then(DeprecatedUtils.isConnectionExpensive);\n}\n\nexport const isConnected = {\n  /**\n   * Deprecated method to listen for changes to the connected boolean. You should now use the\n   * normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  addEventListener: (\n    eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): DeprecatedTypes.Subscription => {\n    if (eventName !== DeprecatedTypes.CHANGE_EVENT_NAME) {\n      return {remove: (): void => {}};\n    }\n\n    const listener = (state: Types.NetInfoState): void => {\n      handler(DeprecatedUtils.isConnected(state));\n    };\n\n    _isConnectedListeners.set(handler, listener);\n    State.add(listener);\n\n    return {\n      remove: (): void => {\n        State.remove(listener);\n      },\n    };\n  },\n\n  /**\n   * Deprecated method to stop listening for changes to the connected boolean. You should now use\n   * the normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  removeEventListener: (\n    _eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): void => {\n    const listener = _isConnectedListeners.get(handler);\n    listener && State.remove(listener);\n    _isConnectedListeners.delete(handler);\n  },\n\n  /**\n   * Deprecated method to get the current is connected boolean. You should now use the normal\n   * `fetch` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  fetch: (): Promise<boolean> => {\n    return State.latest().then(DeprecatedUtils.isConnected);\n  },\n};\n\nexport * from './internal/types';\nexport * from './internal/deprecatedTypes';\n\nexport default {\n  fetch,\n  addEventListener,\n  useNetInfo,\n  removeEventListener,\n  getConnectionInfo,\n  isConnectionExpensive,\n  isConnected,\n};\n"]}