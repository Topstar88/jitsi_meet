{"version":3,"sources":["bitreader.c","./include\\private/bitmath.h","bitwriter.c","../../include\\share/alloc.h","cpu.c","crc.c","fixed.c","format.c","lpc.c","md5.c","memory.c","stream_decoder.c","stream_encoder.c","stream_encoder_framing.c","window.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AACA;AAAA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;AEpnBA;AAAA;AAOA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;;AAEA;AAAA;AASA;;;;AANA;AAAA;AAMA;;;;AAHA;AAAA;AAGA;;;;;;;;;;AAtFA;;;;;;;;AA4DA;;;;;;;;;;AC3GA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;AAKA;;AAEA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;ACgFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;AAAA;;;;AAAA;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;;AACA;;;AAEA;;;;;AAWA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AAEA;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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CA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApCA;AAAA;AAAA;;AAuCA;;AA9MA;AAAA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAdA;AAAA;AAAA;;AA2MA;;;AAzLA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AAyLA;;;AAvKA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAsKA;;;AAtJA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAsJA;;;;AAtIA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAmIA;;;AArHA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApCA;AAAA;AAAA;;AAuCA;;AA9MA;AAAA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAdA;AAAA;AAAA;;AA2MA;;;AAzLA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AAyLA;;;AAvKA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAsKA;;;AAtJA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAsJA;;;;AAtIA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAmIA;;;AArHA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;AAqHA;;;AAvGA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAsGA;;;AA1FA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AA0FA;;;;AA7EA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AA2EA;;;AAjEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAiEA;;;AAvDA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAsDA;;;AA9CA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwDA;AAAA;;AAwKA;;AAAA;AAAA;AAAA;;;;AACA;AACA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApCA;AAAA;AAAA;;AAuCA;;AA9MA;AAAA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAdA;AAAA;AAAA;;AA2MA;;;AAzLA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AAyLA;;;AAvKA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAsKA;;;AAtJA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAsJA;;;;AAtIA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAmIA;;;AArHA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;AAqHA;;;AAvGA;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApCA;AAAA;AAAA;;AAuCA;;AA9MA;AAAA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAdA;AAAA;AAAA;;AA2MA;;;AAzLA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;;AAyLA;;;AAvKA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAsKA;;;AAtJA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;;AAsJA;;;;AAtIA;;;AACA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;;AAmIA;;;AArHA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AATA;AAAA;AAAA;;AAqHA;;;AAvGA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;;AAsGA;;;AA1FA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;;AA0FA;;;;AA7EA;;;AACA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AA2EA;;;AAjEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAiEA;;;AAvDA;;;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAsDA;;;AA9CA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AA8CA;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;AAKA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;;;AAEA;;;;AAEA;AAAA;;AACA;;;AAGA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;;;;;;;;;AC/mCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAKA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnNA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AA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A;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;;;AAQA;AAAA;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;;;AAQA;AAAA;;;;AAAA;AAAA;AAAA;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AAxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAmCA;;AAlCA;AAAA;AAAA;AAkCA;;AA9BA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;A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AA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAlBA;AAAA;AAAA;;;;;;AAuCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAoBA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAKA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;AAGA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAGA;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAKA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAjGA;AAAA;AAAA;;AAIA;AAmGA;AAAA;;;AAFA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAhNA;AACA;AAAA;AAAA;AAAA;AADA;AAGA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;;;AAJA;AAMA;AAAA;AAAA;AARA;;;;;;;;AX96HA;AAAA;AAAA;;;;;;;;;;;;;;;;;;AW+pCA;AAEA;AACA;AACA;AACA;AACA;AAPA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvnBA;AAAA;AAAA;AAAA;;AACA;AA2mBA;AAAA;;AAzmBA;AAAA;;AACA;AAwmBA;AAAA;;AAtmBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAklBA;AAAA;;AAhlBA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;AAEA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAqkBA;AAAA;;AAnkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAkkBA;AAAA;;AAhkBA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;AAiBA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;;AACA;;;AAEA;;;;AArBA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;AACA;AAAA;;;AACA;AAAA;AAAA;;;;;AACA;;;AAEA;;;;AAYA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AA+hBA;AAAA;;;AA7hBA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AA2hBA;AAAA;;AA1hBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAyhBA;AAAA;;AAvhBA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAihBA;AAAA;;;AAhhBA;AAAA;AAAA;AAAA;AAAA;;AACA;AA+gBA;AAAA;;AA7gBA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAugBA;AAAA;;;AAngBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkBA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAkeA;AAAA;;;AAjeA;AACA;AACA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;;;AACA;AAAA;;;;;AAEA;AACA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;;AACA;AAAA;;;;;AAEA;;;AAEA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAGA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;;;;AAEA;;;AAjBA;AAAA;;;;;AAEA;AAGA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAjCA;AAAA;AAAA;;;;AAGA;AA0dA;AAAA;;;;AAvdA;AAudA;AAAA;;;;AApdA;AAodA;AAAA;;;;AAhdA;AAgdA;AAAA;;;;AA3cA;AA2cA;AAAA;;;;AAvcA;AAucA;AAAA;;;;AApcA;AAocA;AAAA;;;;AAzbA;AAybA;AAAA;;;;AArbA;AAqbA;AAAA;;;;AA/aA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAOA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA6LA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAkKA;AAAA;;AA/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AACA;AA6JA;AAAA;;AAvJA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AA8IA;AAAA;;AA3IA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAkIA;AAAA;;;AA9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AA4HA;AAAA;;;AAzHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AACA;AAiGA;AAAA;;AA/FA;AAAA;;AAEA;AA6FA;AAAA;;AAvFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AACA;AAqEA;AAAA;;AAnEA;AAAA;;AAEA;AAiEA;AAAA;;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AACA;AAiCA;AAAA;;AA/BA;AAAA;;;;AAEA;AA6BA;AAAA;;;AAtBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;;;;;AANA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAkBA;AAAA;;;AAdA;AAcA;AAAA;;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAOA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;;;;;;AAxkBA;AAwkBA;AAAA;;;AArlBA;AAqlBA;AAAA;;;AAlmBA;AAkmBA;AAAA;;;AArmBA;AAqmBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4pFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;;;AASA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;;;AAYA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9iDA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AA+HA;AAAA;;AA7HA;AAQA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAWA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;;AAYA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AADA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;;AAGA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAKA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AADA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAIA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAxDA;AAAA;AAAA;;;;;;AA+DA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AA0wDA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;A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AAA;AAAA;;AAEA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;AAIA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;;AAIA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;;;AAIA;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AA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA","file":"D:/git_repo/libflac.js/flac-1.3.2/Emscripten/js_debug_asmjs/libflac4-1.3.2.dev.js","sourcesContent":["/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include \"private/bitmath.h\"\n#include \"private/bitreader.h\"\n#include \"private/crc.h\"\n#include \"private/macros.h\"\n#include \"FLAC/assert.h\"\n#include \"share/compat.h\"\n#include \"share/endswap.h\"\n\n/* Things should be fastest when this matches the machine word size */\n/* WATCHOUT: if you change this you must also change the following #defines down to COUNT_ZERO_MSBS2 below to match */\n/* WATCHOUT: there are a few places where the code will not work unless brword is >= 32 bits wide */\n/*           also, some sections currently only have fast versions for 4 or 8 bytes per word */\n\n#if (ENABLE_64_BIT_WORDS == 0)\n\ntypedef FLAC__uint32 brword;\n#define FLAC__BYTES_PER_WORD 4\t\t/* sizeof brword */\n#define FLAC__BITS_PER_WORD 32\n#define FLAC__WORD_ALL_ONES ((FLAC__uint32)0xffffffff)\n/* SWAP_BE_WORD_TO_HOST swaps bytes in a brword (which is always big-endian) if necessary to match host byte order */\n#if WORDS_BIGENDIAN\n#define SWAP_BE_WORD_TO_HOST(x) (x)\n#else\n#define SWAP_BE_WORD_TO_HOST(x) ENDSWAP_32(x)\n#endif\n/* counts the # of zero MSBs in a word */\n#define COUNT_ZERO_MSBS(word) FLAC__clz_uint32(word)\n#define COUNT_ZERO_MSBS2(word) FLAC__clz2_uint32(word)\n\n#else\n\ntypedef FLAC__uint64 brword;\n#define FLAC__BYTES_PER_WORD 8\t\t/* sizeof brword */\n#define FLAC__BITS_PER_WORD 64\n#define FLAC__WORD_ALL_ONES ((FLAC__uint64)FLAC__U64L(0xffffffffffffffff))\n/* SWAP_BE_WORD_TO_HOST swaps bytes in a brword (which is always big-endian) if necessary to match host byte order */\n#if WORDS_BIGENDIAN\n#define SWAP_BE_WORD_TO_HOST(x) (x)\n#else\n#define SWAP_BE_WORD_TO_HOST(x) ENDSWAP_64(x)\n#endif\n/* counts the # of zero MSBs in a word */\n#define COUNT_ZERO_MSBS(word) FLAC__clz_uint64(word)\n#define COUNT_ZERO_MSBS2(word) FLAC__clz2_uint64(word)\n\n#endif\n\n/*\n * This should be at least twice as large as the largest number of words\n * required to represent any 'number' (in any encoding) you are going to\n * read.  With FLAC this is on the order of maybe a few hundred bits.\n * If the buffer is smaller than that, the decoder won't be able to read\n * in a whole number that is in a variable length encoding (e.g. Rice).\n * But to be practical it should be at least 1K bytes.\n *\n * Increase this number to decrease the number of read callbacks, at the\n * expense of using more memory.  Or decrease for the reverse effect,\n * keeping in mind the limit from the first paragraph.  The optimal size\n * also depends on the CPU cache size and other factors; some twiddling\n * may be necessary to squeeze out the best performance.\n */\nstatic const unsigned FLAC__BITREADER_DEFAULT_CAPACITY = 65536u / FLAC__BITS_PER_WORD; /* in words */\n\nstruct FLAC__BitReader {\n\t/* any partially-consumed word at the head will stay right-justified as bits are consumed from the left */\n\t/* any incomplete word at the tail will be left-justified, and bytes from the read callback are added on the right */\n\tbrword *buffer;\n\tunsigned capacity; /* in words */\n\tunsigned words; /* # of completed words in buffer */\n\tunsigned bytes; /* # of bytes in incomplete word at buffer[words] */\n\tunsigned consumed_words; /* #words ... */\n\tunsigned consumed_bits; /* ... + (#bits of head word) already consumed from the front of buffer */\n\tunsigned read_crc16; /* the running frame CRC */\n\tunsigned crc16_align; /* the number of bits in the current consumed word that should not be CRC'd */\n\tFLAC__BitReaderReadCallback read_callback;\n\tvoid *client_data;\n};\n\nstatic inline void crc16_update_word_(FLAC__BitReader *br, brword word)\n{\n\tregister unsigned crc = br->read_crc16;\n#if FLAC__BYTES_PER_WORD == 4\n\tswitch(br->crc16_align) {\n\t\tcase  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 24), crc);\n\t\tcase  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);\n\t\tcase 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);\n\t\tcase 24: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);\n\t}\n#elif FLAC__BYTES_PER_WORD == 8\n\tswitch(br->crc16_align) {\n\t\tcase  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 56), crc);\n\t\tcase  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 48) & 0xff), crc);\n\t\tcase 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 40) & 0xff), crc);\n\t\tcase 24: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 32) & 0xff), crc);\n\t\tcase 32: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 24) & 0xff), crc);\n\t\tcase 40: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);\n\t\tcase 48: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);\n\t\tcase 56: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);\n\t}\n#else\n\tfor( ; br->crc16_align < FLAC__BITS_PER_WORD; br->crc16_align += 8)\n\t\tcrc = FLAC__CRC16_UPDATE((unsigned)((word >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), crc);\n\tbr->read_crc16 = crc;\n#endif\n\tbr->crc16_align = 0;\n}\n\nstatic FLAC__bool bitreader_read_from_client_(FLAC__BitReader *br)\n{\n\tunsigned start, end;\n\tsize_t bytes;\n\tFLAC__byte *target;\n\n\t/* first shift the unconsumed buffer data toward the front as much as possible */\n\tif(br->consumed_words > 0) {\n\t\tstart = br->consumed_words;\n\t\tend = br->words + (br->bytes? 1:0);\n\t\tmemmove(br->buffer, br->buffer+start, FLAC__BYTES_PER_WORD * (end - start));\n\n\t\tbr->words -= start;\n\t\tbr->consumed_words = 0;\n\t}\n\n\t/*\n\t * set the target for reading, taking into account word alignment and endianness\n\t */\n\tbytes = (br->capacity - br->words) * FLAC__BYTES_PER_WORD - br->bytes;\n\tif(bytes == 0)\n\t\treturn false; /* no space left, buffer is too small; see note for FLAC__BITREADER_DEFAULT_CAPACITY  */\n\ttarget = ((FLAC__byte*)(br->buffer+br->words)) + br->bytes;\n\n\t/* before reading, if the existing reader looks like this (say brword is 32 bits wide)\n\t *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1 (partial tail word is left-justified)\n\t *   buffer[BE]:  11 22 33 44 55 ?? ?? ??   (shown layed out as bytes sequentially in memory)\n\t *   buffer[LE]:  44 33 22 11 ?? ?? ?? 55   (?? being don't-care)\n\t *                               ^^-------target, bytes=3\n\t * on LE machines, have to byteswap the odd tail word so nothing is\n\t * overwritten:\n\t */\n#if WORDS_BIGENDIAN\n#else\n\tif(br->bytes)\n\t\tbr->buffer[br->words] = SWAP_BE_WORD_TO_HOST(br->buffer[br->words]);\n#endif\n\n\t/* now it looks like:\n\t *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1\n\t *   buffer[BE]:  11 22 33 44 55 ?? ?? ??\n\t *   buffer[LE]:  44 33 22 11 55 ?? ?? ??\n\t *                               ^^-------target, bytes=3\n\t */\n\n\t/* read in the data; note that the callback may return a smaller number of bytes */\n\tif(!br->read_callback(target, &bytes, br->client_data))\n\t\treturn false;\n\n\t/* after reading bytes 66 77 88 99 AA BB CC DD EE FF from the client:\n\t *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF\n\t *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??\n\t *   buffer[LE]:  44 33 22 11 55 66 77 88 99 AA BB CC DD EE FF ??\n\t * now have to byteswap on LE machines:\n\t */\n#if WORDS_BIGENDIAN\n#else\n\tend = (br->words*FLAC__BYTES_PER_WORD + br->bytes + (unsigned)bytes + (FLAC__BYTES_PER_WORD-1)) / FLAC__BYTES_PER_WORD;\n\tfor(start = br->words; start < end; start++)\n\t\tbr->buffer[start] = SWAP_BE_WORD_TO_HOST(br->buffer[start]);\n#endif\n\n\t/* now it looks like:\n\t *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF\n\t *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??\n\t *   buffer[LE]:  44 33 22 11 88 77 66 55 CC BB AA 99 ?? FF EE DD\n\t * finally we'll update the reader values:\n\t */\n\tend = br->words*FLAC__BYTES_PER_WORD + br->bytes + (unsigned)bytes;\n\tbr->words = end / FLAC__BYTES_PER_WORD;\n\tbr->bytes = end % FLAC__BYTES_PER_WORD;\n\n\treturn true;\n}\n\n/***********************************************************************\n *\n * Class constructor/destructor\n *\n ***********************************************************************/\n\nFLAC__BitReader *FLAC__bitreader_new(void)\n{\n\tFLAC__BitReader *br = calloc(1, sizeof(FLAC__BitReader));\n\n\t/* calloc() implies:\n\t\tmemset(br, 0, sizeof(FLAC__BitReader));\n\t\tbr->buffer = 0;\n\t\tbr->capacity = 0;\n\t\tbr->words = br->bytes = 0;\n\t\tbr->consumed_words = br->consumed_bits = 0;\n\t\tbr->read_callback = 0;\n\t\tbr->client_data = 0;\n\t*/\n\treturn br;\n}\n\nvoid FLAC__bitreader_delete(FLAC__BitReader *br)\n{\n\tFLAC__ASSERT(0 != br);\n\n\tFLAC__bitreader_free(br);\n\tfree(br);\n}\n\n/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n\nFLAC__bool FLAC__bitreader_init(FLAC__BitReader *br, FLAC__BitReaderReadCallback rcb, void *cd)\n{\n\tFLAC__ASSERT(0 != br);\n\n\tbr->words = br->bytes = 0;\n\tbr->consumed_words = br->consumed_bits = 0;\n\tbr->capacity = FLAC__BITREADER_DEFAULT_CAPACITY;\n\tbr->buffer = malloc(sizeof(brword) * br->capacity);\n\tif(br->buffer == 0)\n\t\treturn false;\n\tbr->read_callback = rcb;\n\tbr->client_data = cd;\n\n\treturn true;\n}\n\nvoid FLAC__bitreader_free(FLAC__BitReader *br)\n{\n\tFLAC__ASSERT(0 != br);\n\n\tif(0 != br->buffer)\n\t\tfree(br->buffer);\n\tbr->buffer = 0;\n\tbr->capacity = 0;\n\tbr->words = br->bytes = 0;\n\tbr->consumed_words = br->consumed_bits = 0;\n\tbr->read_callback = 0;\n\tbr->client_data = 0;\n}\n\nFLAC__bool FLAC__bitreader_clear(FLAC__BitReader *br)\n{\n\tbr->words = br->bytes = 0;\n\tbr->consumed_words = br->consumed_bits = 0;\n\treturn true;\n}\n\nvoid FLAC__bitreader_dump(const FLAC__BitReader *br, FILE *out)\n{\n\tunsigned i, j;\n\tif(br == 0) {\n\t\tfprintf(out, \"bitreader is NULL\\n\");\n\t}\n\telse {\n\t\tfprintf(out, \"bitreader: capacity=%u words=%u bytes=%u consumed: words=%u, bits=%u\\n\", br->capacity, br->words, br->bytes, br->consumed_words, br->consumed_bits);\n\n\t\tfor(i = 0; i < br->words; i++) {\n\t\t\tfprintf(out, \"%08X: \", i);\n\t\t\tfor(j = 0; j < FLAC__BITS_PER_WORD; j++)\n\t\t\t\tif(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))\n\t\t\t\t\tfprintf(out, \".\");\n\t\t\t\telse\n\t\t\t\t\tfprintf(out, \"%01u\", br->buffer[i] & ((brword)1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t\tif(br->bytes > 0) {\n\t\t\tfprintf(out, \"%08X: \", i);\n\t\t\tfor(j = 0; j < br->bytes*8; j++)\n\t\t\t\tif(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))\n\t\t\t\t\tfprintf(out, \".\");\n\t\t\t\telse\n\t\t\t\t\tfprintf(out, \"%01u\", br->buffer[i] & ((brword)1 << (br->bytes*8-j-1)) ? 1:0);\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t}\n}\n\nvoid FLAC__bitreader_reset_read_crc16(FLAC__BitReader *br, FLAC__uint16 seed)\n{\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\tFLAC__ASSERT((br->consumed_bits & 7) == 0);\n\n\tbr->read_crc16 = (unsigned)seed;\n\tbr->crc16_align = br->consumed_bits;\n}\n\nFLAC__uint16 FLAC__bitreader_get_read_crc16(FLAC__BitReader *br)\n{\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\tFLAC__ASSERT((br->consumed_bits & 7) == 0);\n\tFLAC__ASSERT(br->crc16_align <= br->consumed_bits);\n\n\t/* CRC any tail bytes in a partially-consumed word */\n\tif(br->consumed_bits) {\n\t\tconst brword tail = br->buffer[br->consumed_words];\n\t\tfor( ; br->crc16_align < br->consumed_bits; br->crc16_align += 8)\n\t\t\tbr->read_crc16 = FLAC__CRC16_UPDATE((unsigned)((tail >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), br->read_crc16);\n\t}\n\treturn br->read_crc16;\n}\n\ninline FLAC__bool FLAC__bitreader_is_consumed_byte_aligned(const FLAC__BitReader *br)\n{\n\treturn ((br->consumed_bits & 7) == 0);\n}\n\ninline unsigned FLAC__bitreader_bits_left_for_byte_alignment(const FLAC__BitReader *br)\n{\n\treturn 8 - (br->consumed_bits & 7);\n}\n\ninline unsigned FLAC__bitreader_get_input_bits_unconsumed(const FLAC__BitReader *br)\n{\n\treturn (br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits;\n}\n\nFLAC__bool FLAC__bitreader_read_raw_uint32(FLAC__BitReader *br, FLAC__uint32 *val, unsigned bits)\n{\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\tFLAC__ASSERT(bits <= 32);\n\tFLAC__ASSERT((br->capacity*FLAC__BITS_PER_WORD) * 2 >= bits);\n\tFLAC__ASSERT(br->consumed_words <= br->words);\n\n\t/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */\n\tFLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);\n\n\tif(bits == 0) { /* OPT: investigate if this can ever happen, maybe change to assertion */\n\t\t*val = 0;\n\t\treturn true;\n\t}\n\n\twhile((br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits < bits) {\n\t\tif(!bitreader_read_from_client_(br))\n\t\t\treturn false;\n\t}\n\tif(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */\n\t\t/* OPT: taking out the consumed_bits==0 \"else\" case below might make things faster if less code allows the compiler to inline this function */\n\t\tif(br->consumed_bits) {\n\t\t\t/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */\n\t\t\tconst unsigned n = FLAC__BITS_PER_WORD - br->consumed_bits;\n\t\t\tconst brword word = br->buffer[br->consumed_words];\n\t\t\tif(bits < n) {\n\t\t\t\t*val = (FLAC__uint32)((word & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (n-bits)); /* The result has <= 32 non-zero bits */\n\t\t\t\tbr->consumed_bits += bits;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* (FLAC__BITS_PER_WORD - br->consumed_bits <= bits) ==> (FLAC__WORD_ALL_ONES >> br->consumed_bits) has no more than 'bits' non-zero bits */\n\t\t\t*val = (FLAC__uint32)(word & (FLAC__WORD_ALL_ONES >> br->consumed_bits));\n\t\t\tbits -= n;\n\t\t\tcrc16_update_word_(br, word);\n\t\t\tbr->consumed_words++;\n\t\t\tbr->consumed_bits = 0;\n\t\t\tif(bits) { /* if there are still bits left to read, there have to be less than 32 so they will all be in the next word */\n\t\t\t\t*val <<= bits;\n\t\t\t\t*val |= (FLAC__uint32)(br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits));\n\t\t\t\tbr->consumed_bits = bits;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse { /* br->consumed_bits == 0 */\n\t\t\tconst brword word = br->buffer[br->consumed_words];\n\t\t\tif(bits < FLAC__BITS_PER_WORD) {\n\t\t\t\t*val = (FLAC__uint32)(word >> (FLAC__BITS_PER_WORD-bits));\n\t\t\t\tbr->consumed_bits = bits;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t/* at this point bits == FLAC__BITS_PER_WORD == 32; because of previous assertions, it can't be larger */\n\t\t\t*val = (FLAC__uint32)word;\n\t\t\tcrc16_update_word_(br, word);\n\t\t\tbr->consumed_words++;\n\t\t\treturn true;\n\t\t}\n\t}\n\telse {\n\t\t/* in this case we're starting our read at a partial tail word;\n\t\t * the reader has guaranteed that we have at least 'bits' bits\n\t\t * available to read, which makes this case simpler.\n\t\t */\n\t\t/* OPT: taking out the consumed_bits==0 \"else\" case below might make things faster if less code allows the compiler to inline this function */\n\t\tif(br->consumed_bits) {\n\t\t\t/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */\n\t\t\tFLAC__ASSERT(br->consumed_bits + bits <= br->bytes*8);\n\t\t\t*val = (FLAC__uint32)((br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (FLAC__BITS_PER_WORD-br->consumed_bits-bits));\n\t\t\tbr->consumed_bits += bits;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\t*val = (FLAC__uint32)(br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits));\n\t\t\tbr->consumed_bits += bits;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nFLAC__bool FLAC__bitreader_read_raw_int32(FLAC__BitReader *br, FLAC__int32 *val, unsigned bits)\n{\n\tFLAC__uint32 uval, mask;\n\t/* OPT: inline raw uint32 code here, or make into a macro if possible in the .h file */\n\tif(!FLAC__bitreader_read_raw_uint32(br, &uval, bits))\n\t\treturn false;\n\t/* sign-extend *val assuming it is currently bits wide. */\n\t/* From: https://graphics.stanford.edu/~seander/bithacks.html#FixedSignExtend */\n\tmask = 1u << (bits - 1);\n\t*val = (uval ^ mask) - mask;\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_read_raw_uint64(FLAC__BitReader *br, FLAC__uint64 *val, unsigned bits)\n{\n\tFLAC__uint32 hi, lo;\n\n\tif(bits > 32) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &hi, bits-32))\n\t\t\treturn false;\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &lo, 32))\n\t\t\treturn false;\n\t\t*val = hi;\n\t\t*val <<= 32;\n\t\t*val |= lo;\n\t}\n\telse {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &lo, bits))\n\t\t\treturn false;\n\t\t*val = lo;\n\t}\n\treturn true;\n}\n\ninline FLAC__bool FLAC__bitreader_read_uint32_little_endian(FLAC__BitReader *br, FLAC__uint32 *val)\n{\n\tFLAC__uint32 x8, x32 = 0;\n\n\t/* this doesn't need to be that fast as currently it is only used for vorbis comments */\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x32, 8))\n\t\treturn false;\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))\n\t\treturn false;\n\tx32 |= (x8 << 8);\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))\n\t\treturn false;\n\tx32 |= (x8 << 16);\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))\n\t\treturn false;\n\tx32 |= (x8 << 24);\n\n\t*val = x32;\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_skip_bits_no_crc(FLAC__BitReader *br, unsigned bits)\n{\n\t/*\n\t * OPT: a faster implementation is possible but probably not that useful\n\t * since this is only called a couple of times in the metadata readers.\n\t */\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\tif(bits > 0) {\n\t\tconst unsigned n = br->consumed_bits & 7;\n\t\tunsigned m;\n\t\tFLAC__uint32 x;\n\n\t\tif(n != 0) {\n\t\t\tm = flac_min(8-n, bits);\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, m))\n\t\t\t\treturn false;\n\t\t\tbits -= m;\n\t\t}\n\t\tm = bits / 8;\n\t\tif(m > 0) {\n\t\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(br, m))\n\t\t\t\treturn false;\n\t\t\tbits %= 8;\n\t\t}\n\t\tif(bits > 0) {\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, bits))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_skip_byte_block_aligned_no_crc(FLAC__BitReader *br, unsigned nvals)\n{\n\tFLAC__uint32 x;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));\n\n\t/* step 1: skip over partial head word to get word aligned */\n\twhile(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\tnvals--;\n\t}\n\tif(0 == nvals)\n\t\treturn true;\n\t/* step 2: skip whole words in chunks */\n\twhile(nvals >= FLAC__BYTES_PER_WORD) {\n\t\tif(br->consumed_words < br->words) {\n\t\t\tbr->consumed_words++;\n\t\t\tnvals -= FLAC__BYTES_PER_WORD;\n\t\t}\n\t\telse if(!bitreader_read_from_client_(br))\n\t\t\treturn false;\n\t}\n\t/* step 3: skip any remainder from partial tail bytes */\n\twhile(nvals) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\tnvals--;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_read_byte_block_aligned_no_crc(FLAC__BitReader *br, FLAC__byte *val, unsigned nvals)\n{\n\tFLAC__uint32 x;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));\n\n\t/* step 1: read from partial head word to get word aligned */\n\twhile(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\t*val++ = (FLAC__byte)x;\n\t\tnvals--;\n\t}\n\tif(0 == nvals)\n\t\treturn true;\n\t/* step 2: read whole words in chunks */\n\twhile(nvals >= FLAC__BYTES_PER_WORD) {\n\t\tif(br->consumed_words < br->words) {\n\t\t\tconst brword word = br->buffer[br->consumed_words++];\n#if FLAC__BYTES_PER_WORD == 4\n\t\t\tval[0] = (FLAC__byte)(word >> 24);\n\t\t\tval[1] = (FLAC__byte)(word >> 16);\n\t\t\tval[2] = (FLAC__byte)(word >> 8);\n\t\t\tval[3] = (FLAC__byte)word;\n#elif FLAC__BYTES_PER_WORD == 8\n\t\t\tval[0] = (FLAC__byte)(word >> 56);\n\t\t\tval[1] = (FLAC__byte)(word >> 48);\n\t\t\tval[2] = (FLAC__byte)(word >> 40);\n\t\t\tval[3] = (FLAC__byte)(word >> 32);\n\t\t\tval[4] = (FLAC__byte)(word >> 24);\n\t\t\tval[5] = (FLAC__byte)(word >> 16);\n\t\t\tval[6] = (FLAC__byte)(word >> 8);\n\t\t\tval[7] = (FLAC__byte)word;\n#else\n\t\t\tfor(x = 0; x < FLAC__BYTES_PER_WORD; x++)\n\t\t\t\tval[x] = (FLAC__byte)(word >> (8*(FLAC__BYTES_PER_WORD-x-1)));\n#endif\n\t\t\tval += FLAC__BYTES_PER_WORD;\n\t\t\tnvals -= FLAC__BYTES_PER_WORD;\n\t\t}\n\t\telse if(!bitreader_read_from_client_(br))\n\t\t\treturn false;\n\t}\n\t/* step 3: read any remainder from partial tail bytes */\n\twhile(nvals) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\t*val++ = (FLAC__byte)x;\n\t\tnvals--;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_read_unary_unsigned(FLAC__BitReader *br, unsigned *val)\n#if 0 /* slow but readable version */\n{\n\tunsigned bit;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\t*val = 0;\n\twhile(1) {\n\t\tif(!FLAC__bitreader_read_bit(br, &bit))\n\t\t\treturn false;\n\t\tif(bit)\n\t\t\tbreak;\n\t\telse\n\t\t\t*val++;\n\t}\n\treturn true;\n}\n#else\n{\n\tunsigned i;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\t*val = 0;\n\twhile(1) {\n\t\twhile(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */\n\t\t\tbrword b = br->buffer[br->consumed_words] << br->consumed_bits;\n\t\t\tif(b) {\n\t\t\t\ti = COUNT_ZERO_MSBS(b);\n\t\t\t\t*val += i;\n\t\t\t\ti++;\n\t\t\t\tbr->consumed_bits += i;\n\t\t\t\tif(br->consumed_bits >= FLAC__BITS_PER_WORD) { /* faster way of testing if(br->consumed_bits == FLAC__BITS_PER_WORD) */\n\t\t\t\t\tcrc16_update_word_(br, br->buffer[br->consumed_words]);\n\t\t\t\t\tbr->consumed_words++;\n\t\t\t\t\tbr->consumed_bits = 0;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*val += FLAC__BITS_PER_WORD - br->consumed_bits;\n\t\t\t\tcrc16_update_word_(br, br->buffer[br->consumed_words]);\n\t\t\t\tbr->consumed_words++;\n\t\t\t\tbr->consumed_bits = 0;\n\t\t\t\t/* didn't find stop bit yet, have to keep going... */\n\t\t\t}\n\t\t}\n\t\t/* at this point we've eaten up all the whole words; have to try\n\t\t * reading through any tail bytes before calling the read callback.\n\t\t * this is a repeat of the above logic adjusted for the fact we\n\t\t * don't have a whole word.  note though if the client is feeding\n\t\t * us data a byte at a time (unlikely), br->consumed_bits may not\n\t\t * be zero.\n\t\t */\n\t\tif(br->bytes*8 > br->consumed_bits) {\n\t\t\tconst unsigned end = br->bytes * 8;\n\t\t\tbrword b = (br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD-end))) << br->consumed_bits;\n\t\t\tif(b) {\n\t\t\t\ti = COUNT_ZERO_MSBS(b);\n\t\t\t\t*val += i;\n\t\t\t\ti++;\n\t\t\t\tbr->consumed_bits += i;\n\t\t\t\tFLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*val += end - br->consumed_bits;\n\t\t\t\tbr->consumed_bits = end;\n\t\t\t\tFLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);\n\t\t\t\t/* didn't find stop bit yet, have to keep going... */\n\t\t\t}\n\t\t}\n\t\tif(!bitreader_read_from_client_(br))\n\t\t\treturn false;\n\t}\n}\n#endif\n\nFLAC__bool FLAC__bitreader_read_rice_signed(FLAC__BitReader *br, int *val, unsigned parameter)\n{\n\tFLAC__uint32 lsbs = 0, msbs = 0;\n\tunsigned uval;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\tFLAC__ASSERT(parameter <= 31);\n\n\t/* read the unary MSBs and end bit */\n\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n\t\treturn false;\n\n\t/* read the binary LSBs */\n\tif(!FLAC__bitreader_read_raw_uint32(br, &lsbs, parameter))\n\t\treturn false;\n\n\t/* compose the value */\n\tuval = (msbs << parameter) | lsbs;\n\tif(uval & 1)\n\t\t*val = -((int)(uval >> 1)) - 1;\n\telse\n\t\t*val = (int)(uval >> 1);\n\n\treturn true;\n}\n\n/* this is by far the most heavily used reader call.  it ain't pretty but it's fast */\nFLAC__bool FLAC__bitreader_read_rice_signed_block(FLAC__BitReader *br, int vals[], unsigned nvals, unsigned parameter)\n{\n\t/* try and get br->consumed_words and br->consumed_bits into register;\n\t * must remember to flush them back to *br before calling other\n\t * bitreader functions that use them, and before returning */\n\tunsigned cwords, words, lsbs, msbs, x, y;\n\tunsigned ucbits; /* keep track of the number of unconsumed bits in word */\n\tbrword b;\n\tint *val, *end;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\t/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */\n\tFLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);\n\tFLAC__ASSERT(parameter < 32);\n\t/* the above two asserts also guarantee that the binary part never straddles more than 2 words, so we don't have to loop to read it */\n\n\tval = vals;\n\tend = vals + nvals;\n\n\tif(parameter == 0) {\n\t\twhile(val < end) {\n\t\t\t/* read the unary MSBs and end bit */\n\t\t\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n\t\t\t\treturn false;\n\n\t\t\t*val++ = (int)(msbs >> 1) ^ -(int)(msbs & 1);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tFLAC__ASSERT(parameter > 0);\n\n\tcwords = br->consumed_words;\n\twords = br->words;\n\n\t/* if we've not consumed up to a partial tail word... */\n\tif(cwords >= words) {\n\t\tx = 0;\n\t\tgoto process_tail;\n\t}\n\n\tucbits = FLAC__BITS_PER_WORD - br->consumed_bits;\n\tb = br->buffer[cwords] << br->consumed_bits;  /* keep unconsumed bits aligned to left */\n\n\twhile(val < end) {\n\t\t/* read the unary MSBs and end bit */\n\t\tx = y = COUNT_ZERO_MSBS2(b);\n\t\tif(x == FLAC__BITS_PER_WORD) {\n\t\t\tx = ucbits;\n\t\t\tdo {\n\t\t\t\t/* didn't find stop bit yet, have to keep going... */\n\t\t\t\tcrc16_update_word_(br, br->buffer[cwords++]);\n\t\t\t\tif (cwords >= words)\n\t\t\t\t\tgoto incomplete_msbs;\n\t\t\t\tb = br->buffer[cwords];\n\t\t\t\ty = COUNT_ZERO_MSBS2(b);\n\t\t\t\tx += y;\n\t\t\t} while(y == FLAC__BITS_PER_WORD);\n\t\t}\n\t\tb <<= y;\n\t\tb <<= 1; /* account for stop bit */\n\t\tucbits = (ucbits - x - 1) % FLAC__BITS_PER_WORD;\n\t\tmsbs = x;\n\n\t\t/* read the binary LSBs */\n\t\tx = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter)); /* parameter < 32, so we can cast to 32-bit unsigned */\n\t\tif(parameter <= ucbits) {\n\t\t\tucbits -= parameter;\n\t\t\tb <<= parameter;\n\t\t} else {\n\t\t\t/* there are still bits left to read, they will all be in the next word */\n\t\t\tcrc16_update_word_(br, br->buffer[cwords++]);\n\t\t\tif (cwords >= words)\n\t\t\t\tgoto incomplete_lsbs;\n\t\t\tb = br->buffer[cwords];\n\t\t\tucbits += FLAC__BITS_PER_WORD - parameter;\n\t\t\tx |= (FLAC__uint32)(b >> ucbits);\n\t\t\tb <<= FLAC__BITS_PER_WORD - ucbits;\n\t\t}\n\t\tlsbs = x;\n\n\t\t/* compose the value */\n\t\tx = (msbs << parameter) | lsbs;\n\t\t*val++ = (int)(x >> 1) ^ -(int)(x & 1);\n\n\t\tcontinue;\n\n\t\t/* at this point we've eaten up all the whole words */\nprocess_tail:\n\t\tdo {\n\t\t\tif(0) {\nincomplete_msbs:\n\t\t\t\tbr->consumed_bits = 0;\n\t\t\t\tbr->consumed_words = cwords;\n\t\t\t}\n\n\t\t\t/* read the unary MSBs and end bit */\n\t\t\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n\t\t\t\treturn false;\n\t\t\tmsbs += x;\n\t\t\tx = ucbits = 0;\n\n\t\t\tif(0) {\nincomplete_lsbs:\n\t\t\t\tbr->consumed_bits = 0;\n\t\t\t\tbr->consumed_words = cwords;\n\t\t\t}\n\n\t\t\t/* read the binary LSBs */\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(br, &lsbs, parameter - ucbits))\n\t\t\t\treturn false;\n\t\t\tlsbs = x | lsbs;\n\n\t\t\t/* compose the value */\n\t\t\tx = (msbs << parameter) | lsbs;\n\t\t\t*val++ = (int)(x >> 1) ^ -(int)(x & 1);\n\t\t\tx = 0;\n\n\t\t\tcwords = br->consumed_words;\n\t\t\twords = br->words;\n\t\t\tucbits = FLAC__BITS_PER_WORD - br->consumed_bits;\n\t\t\tb = br->buffer[cwords] << br->consumed_bits;\n\t\t} while(cwords >= words && val < end);\n\t}\n\n\tif(ucbits == 0 && cwords < words) {\n\t\t/* don't leave the head word with no unconsumed bits */\n\t\tcrc16_update_word_(br, br->buffer[cwords++]);\n\t\tucbits = FLAC__BITS_PER_WORD;\n\t}\n\n\tbr->consumed_bits = FLAC__BITS_PER_WORD - ucbits;\n\tbr->consumed_words = cwords;\n\n\treturn true;\n}\n\n#if 0 /* UNUSED */\nFLAC__bool FLAC__bitreader_read_golomb_signed(FLAC__BitReader *br, int *val, unsigned parameter)\n{\n\tFLAC__uint32 lsbs = 0, msbs = 0;\n\tunsigned bit, uval, k;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\n\t/* read the unary MSBs and end bit */\n\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n\t\treturn false;\n\n\t/* read the binary LSBs */\n\tif(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))\n\t\treturn false;\n\n\tif(parameter == 1u<<k) {\n\t\t/* compose the value */\n\t\tuval = (msbs << k) | lsbs;\n\t}\n\telse {\n\t\tunsigned d = (1 << (k+1)) - parameter;\n\t\tif(lsbs >= d) {\n\t\t\tif(!FLAC__bitreader_read_bit(br, &bit))\n\t\t\t\treturn false;\n\t\t\tlsbs <<= 1;\n\t\t\tlsbs |= bit;\n\t\t\tlsbs -= d;\n\t\t}\n\t\t/* compose the value */\n\t\tuval = msbs * parameter + lsbs;\n\t}\n\n\t/* unfold unsigned to signed */\n\tif(uval & 1)\n\t\t*val = -((int)(uval >> 1)) - 1;\n\telse\n\t\t*val = (int)(uval >> 1);\n\n\treturn true;\n}\n\nFLAC__bool FLAC__bitreader_read_golomb_unsigned(FLAC__BitReader *br, unsigned *val, unsigned parameter)\n{\n\tFLAC__uint32 lsbs, msbs = 0;\n\tunsigned bit, k;\n\n\tFLAC__ASSERT(0 != br);\n\tFLAC__ASSERT(0 != br->buffer);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\n\t/* read the unary MSBs and end bit */\n\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n\t\treturn false;\n\n\t/* read the binary LSBs */\n\tif(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))\n\t\treturn false;\n\n\tif(parameter == 1u<<k) {\n\t\t/* compose the value */\n\t\t*val = (msbs << k) | lsbs;\n\t}\n\telse {\n\t\tunsigned d = (1 << (k+1)) - parameter;\n\t\tif(lsbs >= d) {\n\t\t\tif(!FLAC__bitreader_read_bit(br, &bit))\n\t\t\t\treturn false;\n\t\t\tlsbs <<= 1;\n\t\t\tlsbs |= bit;\n\t\t\tlsbs -= d;\n\t\t}\n\t\t/* compose the value */\n\t\t*val = msbs * parameter + lsbs;\n\t}\n\n\treturn true;\n}\n#endif /* UNUSED */\n\n/* on return, if *val == 0xffffffff then the utf-8 sequence was invalid, but the return value will be true */\nFLAC__bool FLAC__bitreader_read_utf8_uint32(FLAC__BitReader *br, FLAC__uint32 *val, FLAC__byte *raw, unsigned *rawlen)\n{\n\tFLAC__uint32 v = 0;\n\tFLAC__uint32 x;\n\tunsigned i;\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\treturn false;\n\tif(raw)\n\t\traw[(*rawlen)++] = (FLAC__byte)x;\n\tif(!(x & 0x80)) { /* 0xxxxxxx */\n\t\tv = x;\n\t\ti = 0;\n\t}\n\telse if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */\n\t\tv = x & 0x1F;\n\t\ti = 1;\n\t}\n\telse if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */\n\t\tv = x & 0x0F;\n\t\ti = 2;\n\t}\n\telse if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */\n\t\tv = x & 0x07;\n\t\ti = 3;\n\t}\n\telse if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */\n\t\tv = x & 0x03;\n\t\ti = 4;\n\t}\n\telse if(x & 0xFC && !(x & 0x02)) { /* 1111110x */\n\t\tv = x & 0x01;\n\t\ti = 5;\n\t}\n\telse {\n\t\t*val = 0xffffffff;\n\t\treturn true;\n\t}\n\tfor( ; i; i--) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\tif(raw)\n\t\t\traw[(*rawlen)++] = (FLAC__byte)x;\n\t\tif(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */\n\t\t\t*val = 0xffffffff;\n\t\t\treturn true;\n\t\t}\n\t\tv <<= 6;\n\t\tv |= (x & 0x3F);\n\t}\n\t*val = v;\n\treturn true;\n}\n\n/* on return, if *val == 0xffffffffffffffff then the utf-8 sequence was invalid, but the return value will be true */\nFLAC__bool FLAC__bitreader_read_utf8_uint64(FLAC__BitReader *br, FLAC__uint64 *val, FLAC__byte *raw, unsigned *rawlen)\n{\n\tFLAC__uint64 v = 0;\n\tFLAC__uint32 x;\n\tunsigned i;\n\n\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\treturn false;\n\tif(raw)\n\t\traw[(*rawlen)++] = (FLAC__byte)x;\n\tif(!(x & 0x80)) { /* 0xxxxxxx */\n\t\tv = x;\n\t\ti = 0;\n\t}\n\telse if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */\n\t\tv = x & 0x1F;\n\t\ti = 1;\n\t}\n\telse if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */\n\t\tv = x & 0x0F;\n\t\ti = 2;\n\t}\n\telse if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */\n\t\tv = x & 0x07;\n\t\ti = 3;\n\t}\n\telse if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */\n\t\tv = x & 0x03;\n\t\ti = 4;\n\t}\n\telse if(x & 0xFC && !(x & 0x02)) { /* 1111110x */\n\t\tv = x & 0x01;\n\t\ti = 5;\n\t}\n\telse if(x & 0xFE && !(x & 0x01)) { /* 11111110 */\n\t\tv = 0;\n\t\ti = 6;\n\t}\n\telse {\n\t\t*val = FLAC__U64L(0xffffffffffffffff);\n\t\treturn true;\n\t}\n\tfor( ; i; i--) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(br, &x, 8))\n\t\t\treturn false;\n\t\tif(raw)\n\t\t\traw[(*rawlen)++] = (FLAC__byte)x;\n\t\tif(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */\n\t\t\t*val = FLAC__U64L(0xffffffffffffffff);\n\t\t\treturn true;\n\t\t}\n\t\tv <<= 6;\n\t\tv |= (x & 0x3F);\n\t}\n\t*val = v;\n\treturn true;\n}\n\n/* These functions are declared inline in this file but are also callable as\n * externs from elsewhere.\n * According to the C99 spec, section 6.7.4, simply providing a function\n * prototype in a header file without 'inline' and making the function inline\n * in this file should be sufficient.\n * Unfortunately, the Microsoft VS compiler doesn't pick them up externally. To\n * fix that we add extern declarations here.\n */\nextern FLAC__bool FLAC__bitreader_is_consumed_byte_aligned(const FLAC__BitReader *br);\nextern unsigned FLAC__bitreader_bits_left_for_byte_alignment(const FLAC__BitReader *br);\nextern unsigned FLAC__bitreader_get_input_bits_unconsumed(const FLAC__BitReader *br);\nextern FLAC__bool FLAC__bitreader_read_uint32_little_endian(FLAC__BitReader *br, FLAC__uint32 *val);\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2001-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FLAC__PRIVATE__BITMATH_H\n#define FLAC__PRIVATE__BITMATH_H\n\n#include \"FLAC/ordinals.h\"\n#include \"FLAC/assert.h\"\n\n#include \"share/compat.h\"\n\n#if defined(_MSC_VER)\n#include <intrin.h> /* for _BitScanReverse* */\n#endif\n\n/* Will never be emitted for MSVC, GCC, Intel compilers */\nstatic inline unsigned int FLAC__clz_soft_uint32(FLAC__uint32 word)\n{\n\tstatic const unsigned char byte_to_unary_table[] = {\n\t8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t};\n\n\treturn word > 0xffffff ? byte_to_unary_table[word >> 24] :\n\t\tword > 0xffff ? byte_to_unary_table[word >> 16] + 8 :\n\t\tword > 0xff ? byte_to_unary_table[word >> 8] + 16 :\n\t\tbyte_to_unary_table[word] + 24;\n}\n\nstatic inline unsigned int FLAC__clz_uint32(FLAC__uint32 v)\n{\n/* Never used with input 0 */\n\tFLAC__ASSERT(v > 0);\n#if defined(__INTEL_COMPILER)\n\treturn _bit_scan_reverse(v) ^ 31U;\n#elif defined(__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n/* This will translate either to (bsr ^ 31U), clz , ctlz, cntlz, lzcnt depending on\n * -march= setting or to a software routine in exotic machines. */\n\treturn __builtin_clz(v);\n#elif defined(_MSC_VER)\n\t{\n\t\tunsigned long idx;\n\t\t_BitScanReverse(&idx, v);\n\t\treturn idx ^ 31U;\n\t}\n#else\n\treturn FLAC__clz_soft_uint32(v);\n#endif\n}\n\n/* Used when 64-bit bsr/clz is unavailable; can use 32-bit bsr/clz when possible */\nstatic inline unsigned int FLAC__clz_soft_uint64(FLAC__uint64 word)\n{\n\treturn (FLAC__uint32)(word>>32) ? FLAC__clz_uint32((FLAC__uint32)(word>>32)) :\n\t\tFLAC__clz_uint32((FLAC__uint32)word) + 32;\n}\n\nstatic inline unsigned int FLAC__clz_uint64(FLAC__uint64 v)\n{\n\t/* Never used with input 0 */\n\tFLAC__ASSERT(v > 0);\n#if defined(__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\treturn __builtin_clzll(v);\n#elif (defined(__INTEL_COMPILER) || defined(_MSC_VER)) && (defined(_M_IA64) || defined(_M_X64))\n\t{\n\t\tunsigned long idx;\n\t\t_BitScanReverse64(&idx, v);\n\t\treturn idx ^ 63U;\n\t}\n#else\n\treturn FLAC__clz_soft_uint64(v);\n#endif\n}\n\n/* These two functions work with input 0 */\nstatic inline unsigned int FLAC__clz2_uint32(FLAC__uint32 v)\n{\n\tif (!v)\n\t\treturn 32;\n\treturn FLAC__clz_uint32(v);\n}\n\nstatic inline unsigned int FLAC__clz2_uint64(FLAC__uint64 v)\n{\n\tif (!v)\n\t\treturn 64;\n\treturn FLAC__clz_uint64(v);\n}\n\n/* An example of what FLAC__bitmath_ilog2() computes:\n *\n * ilog2( 0) = assertion failure\n * ilog2( 1) = 0\n * ilog2( 2) = 1\n * ilog2( 3) = 1\n * ilog2( 4) = 2\n * ilog2( 5) = 2\n * ilog2( 6) = 2\n * ilog2( 7) = 2\n * ilog2( 8) = 3\n * ilog2( 9) = 3\n * ilog2(10) = 3\n * ilog2(11) = 3\n * ilog2(12) = 3\n * ilog2(13) = 3\n * ilog2(14) = 3\n * ilog2(15) = 3\n * ilog2(16) = 4\n * ilog2(17) = 4\n * ilog2(18) = 4\n */\n\nstatic inline unsigned FLAC__bitmath_ilog2(FLAC__uint32 v)\n{\n\tFLAC__ASSERT(v > 0);\n#if defined(__INTEL_COMPILER)\n\treturn _bit_scan_reverse(v);\n#elif defined(_MSC_VER)\n\t{\n\t\tunsigned long idx;\n\t\t_BitScanReverse(&idx, v);\n\t\treturn idx;\n\t}\n#else\n\treturn FLAC__clz_uint32(v) ^ 31U;\n#endif\n}\n\nstatic inline unsigned FLAC__bitmath_ilog2_wide(FLAC__uint64 v)\n{\n\tFLAC__ASSERT(v > 0);\n#if defined(__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))\n\treturn __builtin_clzll(v) ^ 63U;\n/* Sorry, only supported in x64/Itanium.. and both have fast FPU which makes integer-only encoder pointless */\n#elif (defined(__INTEL_COMPILER) || defined(_MSC_VER)) && (defined(_M_IA64) || defined(_M_X64))\n\t{\n\t\tunsigned long idx;\n\t\t_BitScanReverse64(&idx, v);\n\t\treturn idx;\n\t}\n#else\n/*  Brain-damaged compilers will use the fastest possible way that is,\n\tde Bruijn sequences (http://supertech.csail.mit.edu/papers/debruijn.pdf)\n\t(C) Timothy B. Terriberry (tterribe@xiph.org) 2001-2009 CC0 (Public domain).\n*/\n\t{\n\t\tstatic const unsigned char DEBRUIJN_IDX64[64]={\n\t\t\t0, 1, 2, 7, 3,13, 8,19, 4,25,14,28, 9,34,20,40,\n\t\t\t5,17,26,38,15,46,29,48,10,31,35,54,21,50,41,57,\n\t\t\t63, 6,12,18,24,27,33,39,16,37,45,47,30,53,49,56,\n\t\t\t62,11,23,32,36,44,52,55,61,22,43,51,60,42,59,58\n\t\t};\n\t\tv|= v>>1;\n\t\tv|= v>>2;\n\t\tv|= v>>4;\n\t\tv|= v>>8;\n\t\tv|= v>>16;\n\t\tv|= v>>32;\n\t\tv= (v>>1)+1;\n\t\treturn DEBRUIJN_IDX64[v*FLAC__U64L(0x218A392CD3D5DBF)>>58&0x3F];\n\t}\n#endif\n}\n\nunsigned FLAC__bitmath_silog2(FLAC__int64 v);\n\n#endif\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include \"private/bitwriter.h\"\n#include \"private/crc.h\"\n#include \"private/macros.h\"\n#include \"FLAC/assert.h\"\n#include \"share/alloc.h\"\n#include \"share/compat.h\"\n#include \"share/endswap.h\"\n\n/* Things should be fastest when this matches the machine word size */\n/* WATCHOUT: if you change this you must also change the following #defines down to SWAP_BE_WORD_TO_HOST below to match */\n/* WATCHOUT: there are a few places where the code will not work unless bwword is >= 32 bits wide */\n\n#if (ENABLE_64_BIT_WORDS == 0)\n\ntypedef FLAC__uint32 bwword;\n#define FLAC__BYTES_PER_WORD 4\t\t/* sizeof bwword */\n#define FLAC__BITS_PER_WORD 32\n/* SWAP_BE_WORD_TO_HOST swaps bytes in a bwword (which is always big-endian) if necessary to match host byte order */\n#if WORDS_BIGENDIAN\n#define SWAP_BE_WORD_TO_HOST(x) (x)\n#else\n#define SWAP_BE_WORD_TO_HOST(x) ENDSWAP_32(x)\n#endif\n\n#else\n\ntypedef FLAC__uint64 bwword;\n#define FLAC__BYTES_PER_WORD 8\t\t/* sizeof bwword */\n#define FLAC__BITS_PER_WORD 64\n/* SWAP_BE_WORD_TO_HOST swaps bytes in a bwword (which is always big-endian) if necessary to match host byte order */\n#if WORDS_BIGENDIAN\n#define SWAP_BE_WORD_TO_HOST(x) (x)\n#else\n#define SWAP_BE_WORD_TO_HOST(x) ENDSWAP_64(x)\n#endif\n\n#endif\n\n/*\n * The default capacity here doesn't matter too much.  The buffer always grows\n * to hold whatever is written to it.  Usually the encoder will stop adding at\n * a frame or metadata block, then write that out and clear the buffer for the\n * next one.\n */\nstatic const unsigned FLAC__BITWRITER_DEFAULT_CAPACITY = 32768u / sizeof(bwword); /* size in words */\n/* When growing, increment 4K at a time */\nstatic const unsigned FLAC__BITWRITER_DEFAULT_INCREMENT = 4096u / sizeof(bwword); /* size in words */\n\n#define FLAC__WORDS_TO_BITS(words) ((words) * FLAC__BITS_PER_WORD)\n#define FLAC__TOTAL_BITS(bw) (FLAC__WORDS_TO_BITS((bw)->words) + (bw)->bits)\n\nstruct FLAC__BitWriter {\n\tbwword *buffer;\n\tbwword accum; /* accumulator; bits are right-justified; when full, accum is appended to buffer */\n\tunsigned capacity; /* capacity of buffer in words */\n\tunsigned words; /* # of complete words in buffer */\n\tunsigned bits; /* # of used bits in accum */\n};\n\n/* * WATCHOUT: The current implementation only grows the buffer. */\n#ifndef __SUNPRO_C\nstatic\n#endif\nFLAC__bool bitwriter_grow_(FLAC__BitWriter *bw, unsigned bits_to_add)\n{\n\tunsigned new_capacity;\n\tbwword *new_buffer;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\t/* calculate total words needed to store 'bits_to_add' additional bits */\n\tnew_capacity = bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD);\n\n\t/* it's possible (due to pessimism in the growth estimation that\n\t * leads to this call) that we don't actually need to grow\n\t */\n\tif(bw->capacity >= new_capacity)\n\t\treturn true;\n\n\t/* round up capacity increase to the nearest FLAC__BITWRITER_DEFAULT_INCREMENT */\n\tif((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT)\n\t\tnew_capacity += FLAC__BITWRITER_DEFAULT_INCREMENT - ((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);\n\t/* make sure we got everything right */\n\tFLAC__ASSERT(0 == (new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);\n\tFLAC__ASSERT(new_capacity > bw->capacity);\n\tFLAC__ASSERT(new_capacity >= bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD));\n\n\tnew_buffer = safe_realloc_mul_2op_(bw->buffer, sizeof(bwword), /*times*/new_capacity);\n\tif(new_buffer == 0)\n\t\treturn false;\n\tbw->buffer = new_buffer;\n\tbw->capacity = new_capacity;\n\treturn true;\n}\n\n\n/***********************************************************************\n *\n * Class constructor/destructor\n *\n ***********************************************************************/\n\nFLAC__BitWriter *FLAC__bitwriter_new(void)\n{\n\tFLAC__BitWriter *bw = calloc(1, sizeof(FLAC__BitWriter));\n\t/* note that calloc() sets all members to 0 for us */\n\treturn bw;\n}\n\nvoid FLAC__bitwriter_delete(FLAC__BitWriter *bw)\n{\n\tFLAC__ASSERT(0 != bw);\n\n\tFLAC__bitwriter_free(bw);\n\tfree(bw);\n}\n\n/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n\nFLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw)\n{\n\tFLAC__ASSERT(0 != bw);\n\n\tbw->words = bw->bits = 0;\n\tbw->capacity = FLAC__BITWRITER_DEFAULT_CAPACITY;\n\tbw->buffer = malloc(sizeof(bwword) * bw->capacity);\n\tif(bw->buffer == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid FLAC__bitwriter_free(FLAC__BitWriter *bw)\n{\n\tFLAC__ASSERT(0 != bw);\n\n\tif(0 != bw->buffer)\n\t\tfree(bw->buffer);\n\tbw->buffer = 0;\n\tbw->capacity = 0;\n\tbw->words = bw->bits = 0;\n}\n\nvoid FLAC__bitwriter_clear(FLAC__BitWriter *bw)\n{\n\tbw->words = bw->bits = 0;\n}\n\nvoid FLAC__bitwriter_dump(const FLAC__BitWriter *bw, FILE *out)\n{\n\tunsigned i, j;\n\tif(bw == 0) {\n\t\tfprintf(out, \"bitwriter is NULL\\n\");\n\t}\n\telse {\n\t\tfprintf(out, \"bitwriter: capacity=%u words=%u bits=%u total_bits=%u\\n\", bw->capacity, bw->words, bw->bits, FLAC__TOTAL_BITS(bw));\n\n\t\tfor(i = 0; i < bw->words; i++) {\n\t\t\tfprintf(out, \"%08X: \", i);\n\t\t\tfor(j = 0; j < FLAC__BITS_PER_WORD; j++)\n\t\t\t\tfprintf(out, \"%01u\", bw->buffer[i] & ((bwword)1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t\tif(bw->bits > 0) {\n\t\t\tfprintf(out, \"%08X: \", i);\n\t\t\tfor(j = 0; j < bw->bits; j++)\n\t\t\t\tfprintf(out, \"%01u\", bw->accum & ((bwword)1 << (bw->bits-j-1)) ? 1:0);\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t}\n}\n\nFLAC__bool FLAC__bitwriter_get_write_crc16(FLAC__BitWriter *bw, FLAC__uint16 *crc)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\n\tFLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */\n\n\tif(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))\n\t\treturn false;\n\n\t*crc = (FLAC__uint16)FLAC__crc16(buffer, bytes);\n\tFLAC__bitwriter_release_buffer(bw);\n\treturn true;\n}\n\nFLAC__bool FLAC__bitwriter_get_write_crc8(FLAC__BitWriter *bw, FLAC__byte *crc)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\n\tFLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */\n\n\tif(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))\n\t\treturn false;\n\n\t*crc = FLAC__crc8(buffer, bytes);\n\tFLAC__bitwriter_release_buffer(bw);\n\treturn true;\n}\n\nFLAC__bool FLAC__bitwriter_is_byte_aligned(const FLAC__BitWriter *bw)\n{\n\treturn ((bw->bits & 7) == 0);\n}\n\nunsigned FLAC__bitwriter_get_input_bits_unconsumed(const FLAC__BitWriter *bw)\n{\n\treturn FLAC__TOTAL_BITS(bw);\n}\n\nFLAC__bool FLAC__bitwriter_get_buffer(FLAC__BitWriter *bw, const FLAC__byte **buffer, size_t *bytes)\n{\n\tFLAC__ASSERT((bw->bits & 7) == 0);\n\t/* double protection */\n\tif(bw->bits & 7)\n\t\treturn false;\n\t/* if we have bits in the accumulator we have to flush those to the buffer first */\n\tif(bw->bits) {\n\t\tFLAC__ASSERT(bw->words <= bw->capacity);\n\t\tif(bw->words == bw->capacity && !bitwriter_grow_(bw, FLAC__BITS_PER_WORD))\n\t\t\treturn false;\n\t\t/* append bits as complete word to buffer, but don't change bw->accum or bw->bits */\n\t\tbw->buffer[bw->words] = SWAP_BE_WORD_TO_HOST(bw->accum << (FLAC__BITS_PER_WORD-bw->bits));\n\t}\n\t/* now we can just return what we have */\n\t*buffer = (FLAC__byte*)bw->buffer;\n\t*bytes = (FLAC__BYTES_PER_WORD * bw->words) + (bw->bits >> 3);\n\treturn true;\n}\n\nvoid FLAC__bitwriter_release_buffer(FLAC__BitWriter *bw)\n{\n\t/* nothing to do.  in the future, strict checking of a 'writer-is-in-\n\t * get-mode' flag could be added everywhere and then cleared here\n\t */\n\t(void)bw;\n}\n\ninline FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, unsigned bits)\n{\n\tunsigned n;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\tif(bits == 0)\n\t\treturn true;\n\t/* slightly pessimistic size check but faster than \"<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD\" */\n\tif(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))\n\t\treturn false;\n\t/* first part gets to word alignment */\n\tif(bw->bits) {\n\t\tn = flac_min(FLAC__BITS_PER_WORD - bw->bits, bits);\n\t\tbw->accum <<= n;\n\t\tbits -= n;\n\t\tbw->bits += n;\n\t\tif(bw->bits == FLAC__BITS_PER_WORD) {\n\t\t\tbw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);\n\t\t\tbw->bits = 0;\n\t\t}\n\t\telse\n\t\t\treturn true;\n\t}\n\t/* do whole words */\n\twhile(bits >= FLAC__BITS_PER_WORD) {\n\t\tbw->buffer[bw->words++] = 0;\n\t\tbits -= FLAC__BITS_PER_WORD;\n\t}\n\t/* do any leftovers */\n\tif(bits > 0) {\n\t\tbw->accum = 0;\n\t\tbw->bits = bits;\n\t}\n\treturn true;\n}\n\nstatic inline FLAC__bool FLAC__bitwriter_write_raw_uint32_nocheck(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits)\n{\n\tregister unsigned left;\n\n\t/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */\n\tFLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);\n\n\tif(bw == 0 || bw->buffer == 0)\n\t\treturn false;\n\n\tif (bits > 32)\n\t\treturn false;\n\n\tif(bits == 0)\n\t\treturn true;\n\n\tFLAC__ASSERT((bits == 32) || (val>>bits == 0));\n\n\t/* slightly pessimistic size check but faster than \"<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD\" */\n\tif(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))\n\t\treturn false;\n\n\tleft = FLAC__BITS_PER_WORD - bw->bits;\n\tif(bits < left) {\n\t\tbw->accum <<= bits;\n\t\tbw->accum |= val;\n\t\tbw->bits += bits;\n\t}\n\telse if(bw->bits) { /* WATCHOUT: if bw->bits == 0, left==FLAC__BITS_PER_WORD and bw->accum<<=left is a NOP instead of setting to 0 */\n\t\tbw->accum <<= left;\n\t\tbw->accum |= val >> (bw->bits = bits - left);\n\t\tbw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);\n\t\tbw->accum = val; /* unused top bits can contain garbage */\n\t}\n\telse { /* at this point bits == FLAC__BITS_PER_WORD == 32  and  bw->bits == 0 */\n\t\tbw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST((bwword)val);\n\t}\n\n\treturn true;\n}\n\ninline FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits)\n{\n\t/* check that unused bits are unset */\n\tif((bits < 32) && (val>>bits != 0))\n\t\treturn false;\n\n\treturn FLAC__bitwriter_write_raw_uint32_nocheck(bw, val, bits);\n}\n\ninline FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, unsigned bits)\n{\n\t/* zero-out unused bits */\n\tif(bits < 32)\n\t\tval &= (~(0xffffffff << bits));\n\n\treturn FLAC__bitwriter_write_raw_uint32_nocheck(bw, (FLAC__uint32)val, bits);\n}\n\ninline FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, unsigned bits)\n{\n\t/* this could be a little faster but it's not used for much */\n\tif(bits > 32) {\n\t\treturn\n\t\t\tFLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)(val>>32), bits-32) &&\n\t\t\tFLAC__bitwriter_write_raw_uint32_nocheck(bw, (FLAC__uint32)val, 32);\n\t}\n\telse\n\t\treturn FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, bits);\n}\n\ninline FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val)\n{\n\t/* this doesn't need to be that fast as currently it is only used for vorbis comments */\n\n\tif(!FLAC__bitwriter_write_raw_uint32_nocheck(bw, val & 0xff, 8))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_uint32_nocheck(bw, (val>>8) & 0xff, 8))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_uint32_nocheck(bw, (val>>16) & 0xff, 8))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_uint32_nocheck(bw, val>>24, 8))\n\t\treturn false;\n\n\treturn true;\n}\n\ninline FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], unsigned nvals)\n{\n\tunsigned i;\n\n\t/* this could be faster but currently we don't need it to be since it's only used for writing metadata */\n\tfor(i = 0; i < nvals; i++) {\n\t\tif(!FLAC__bitwriter_write_raw_uint32_nocheck(bw, (FLAC__uint32)(vals[i]), 8))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__bitwriter_write_unary_unsigned(FLAC__BitWriter *bw, unsigned val)\n{\n\tif(val < 32)\n\t\treturn FLAC__bitwriter_write_raw_uint32_nocheck(bw, 1, ++val);\n\telse\n\t\treturn\n\t\t\tFLAC__bitwriter_write_zeroes(bw, val) &&\n\t\t\tFLAC__bitwriter_write_raw_uint32_nocheck(bw, 1, 1);\n}\n\nunsigned FLAC__bitwriter_rice_bits(FLAC__int32 val, unsigned parameter)\n{\n\tFLAC__uint32 uval;\n\n\tFLAC__ASSERT(parameter < 32);\n\n\t/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */\n\tuval = val;\n\tuval <<= 1;\n\tuval ^= (val>>31);\n\n\treturn 1 + parameter + (uval >> parameter);\n}\n\n#if 0 /* UNUSED */\nunsigned FLAC__bitwriter_golomb_bits_signed(int val, unsigned parameter)\n{\n\tunsigned bits, msbs, uval;\n\tunsigned k;\n\n\tFLAC__ASSERT(parameter > 0);\n\n\t/* fold signed to unsigned */\n\tif(val < 0)\n\t\tuval = (unsigned)(((-(++val)) << 1) + 1);\n\telse\n\t\tuval = (unsigned)(val << 1);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\tbits = 1 + k + msbs;\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\n\t\tbits = 1 + q + k;\n\t\tif(r >= d)\n\t\t\tbits++;\n\t}\n\treturn bits;\n}\n\nunsigned FLAC__bitwriter_golomb_bits_unsigned(unsigned uval, unsigned parameter)\n{\n\tunsigned bits, msbs;\n\tunsigned k;\n\n\tFLAC__ASSERT(parameter > 0);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\tbits = 1 + k + msbs;\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\n\t\tbits = 1 + q + k;\n\t\tif(r >= d)\n\t\t\tbits++;\n\t}\n\treturn bits;\n}\n#endif /* UNUSED */\n\nFLAC__bool FLAC__bitwriter_write_rice_signed(FLAC__BitWriter *bw, FLAC__int32 val, unsigned parameter)\n{\n\tunsigned total_bits, interesting_bits, msbs;\n\tFLAC__uint32 uval, pattern;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter < 32);\n\n\t/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */\n\tuval = val;\n\tuval <<= 1;\n\tuval ^= (val>>31);\n\n\tmsbs = uval >> parameter;\n\tinteresting_bits = 1 + parameter;\n\ttotal_bits = interesting_bits + msbs;\n\tpattern = 1 << parameter; /* the unary end bit */\n\tpattern |= (uval & ((1<<parameter)-1)); /* the binary LSBs */\n\n\tif(total_bits <= 32)\n\t\treturn FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits);\n\telse\n\t\treturn\n\t\t\tFLAC__bitwriter_write_zeroes(bw, msbs) && /* write the unary MSBs */\n\t\t\tFLAC__bitwriter_write_raw_uint32(bw, pattern, interesting_bits); /* write the unary end bit and binary LSBs */\n}\n\nFLAC__bool FLAC__bitwriter_write_rice_signed_block(FLAC__BitWriter *bw, const FLAC__int32 *vals, unsigned nvals, unsigned parameter)\n{\n\tconst FLAC__uint32 mask1 = (FLAC__uint32)0xffffffff << parameter; /* we val|=mask1 to set the stop bit above it... */\n\tconst FLAC__uint32 mask2 = (FLAC__uint32)0xffffffff >> (31-parameter); /* ...then mask off the bits above the stop bit with val&=mask2 */\n\tFLAC__uint32 uval;\n\tunsigned left;\n\tconst unsigned lsbits = 1 + parameter;\n\tunsigned msbits, total_bits;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter < 31);\n\t/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */\n\tFLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);\n\n\twhile(nvals) {\n\t\t/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */\n\t\tuval = *vals;\n\t\tuval <<= 1;\n\t\tuval ^= (*vals>>31);\n\n\t\tmsbits = uval >> parameter;\n\t\ttotal_bits = lsbits + msbits;\n\n\t\tif(bw->bits && bw->bits + total_bits < FLAC__BITS_PER_WORD) { /* i.e. if the whole thing fits in the current bwword */\n\t\t\t/* ^^^ if bw->bits is 0 then we may have filled the buffer and have no free bwword to work in */\n\t\t\tbw->bits += total_bits;\n\t\t\tuval |= mask1; /* set stop bit */\n\t\t\tuval &= mask2; /* mask off unused top bits */\n\t\t\tbw->accum <<= total_bits;\n\t\t\tbw->accum |= uval;\n\t\t}\n\t\telse {\n\t\t\t/* slightly pessimistic size check but faster than \"<= bw->words + (bw->bits+msbits+lsbits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD\" */\n\t\t\t/* OPT: pessimism may cause flurry of false calls to grow_ which eat up all savings before it */\n\t\t\tif(bw->capacity <= bw->words + bw->bits + msbits + 1 /* lsbits always fit in 1 bwword */ && !bitwriter_grow_(bw, total_bits))\n\t\t\t\treturn false;\n\n\t\t\tif(msbits) {\n\t\t\t\t/* first part gets to word alignment */\n\t\t\t\tif(bw->bits) {\n\t\t\t\t\tleft = FLAC__BITS_PER_WORD - bw->bits;\n\t\t\t\t\tif(msbits < left) {\n\t\t\t\t\t\tbw->accum <<= msbits;\n\t\t\t\t\t\tbw->bits += msbits;\n\t\t\t\t\t\tgoto break1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbw->accum <<= left;\n\t\t\t\t\t\tmsbits -= left;\n\t\t\t\t\t\tbw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);\n\t\t\t\t\t\tbw->bits = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* do whole words */\n\t\t\t\twhile(msbits >= FLAC__BITS_PER_WORD) {\n\t\t\t\t\tbw->buffer[bw->words++] = 0;\n\t\t\t\t\tmsbits -= FLAC__BITS_PER_WORD;\n\t\t\t\t}\n\t\t\t\t/* do any leftovers */\n\t\t\t\tif(msbits > 0) {\n\t\t\t\t\tbw->accum = 0;\n\t\t\t\t\tbw->bits = msbits;\n\t\t\t\t}\n\t\t\t}\nbreak1:\n\t\t\tuval |= mask1; /* set stop bit */\n\t\t\tuval &= mask2; /* mask off unused top bits */\n\n\t\t\tleft = FLAC__BITS_PER_WORD - bw->bits;\n\t\t\tif(lsbits < left) {\n\t\t\t\tbw->accum <<= lsbits;\n\t\t\t\tbw->accum |= uval;\n\t\t\t\tbw->bits += lsbits;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* if bw->bits == 0, left==FLAC__BITS_PER_WORD which will always\n\t\t\t\t * be > lsbits (because of previous assertions) so it would have\n\t\t\t\t * triggered the (lsbits<left) case above.\n\t\t\t\t */\n\t\t\t\tFLAC__ASSERT(bw->bits);\n\t\t\t\tFLAC__ASSERT(left < FLAC__BITS_PER_WORD);\n\t\t\t\tbw->accum <<= left;\n\t\t\t\tbw->accum |= uval >> (bw->bits = lsbits - left);\n\t\t\t\tbw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);\n\t\t\t\tbw->accum = uval; /* unused top bits can contain garbage */\n\t\t\t}\n\t\t}\n\t\tvals++;\n\t\tnvals--;\n\t}\n\treturn true;\n}\n\n#if 0 /* UNUSED */\nFLAC__bool FLAC__bitwriter_write_golomb_signed(FLAC__BitWriter *bw, int val, unsigned parameter)\n{\n\tunsigned total_bits, msbs, uval;\n\tunsigned k;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter > 0);\n\n\t/* fold signed to unsigned */\n\tif(val < 0)\n\t\tuval = (unsigned)(((-(++val)) << 1) + 1);\n\telse\n\t\tuval = (unsigned)(val << 1);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tunsigned pattern;\n\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\ttotal_bits = 1 + k + msbs;\n\t\tpattern = 1 << k; /* the unary end bit */\n\t\tpattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */\n\n\t\tif(total_bits <= 32) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t/* write the unary MSBs */\n\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, msbs))\n\t\t\t\treturn false;\n\t\t\t/* write the unary end bit and binary LSBs */\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\t\t/* write the unary MSBs */\n\t\tif(!FLAC__bitwriter_write_zeroes(bw, q))\n\t\t\treturn false;\n\t\t/* write the unary end bit */\n\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))\n\t\t\treturn false;\n\t\t/* write the binary LSBs */\n\t\tif(r >= d) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r, k))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nFLAC__bool FLAC__bitwriter_write_golomb_unsigned(FLAC__BitWriter *bw, unsigned uval, unsigned parameter)\n{\n\tunsigned total_bits, msbs;\n\tunsigned k;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\tFLAC__ASSERT(parameter > 0);\n\n\tk = FLAC__bitmath_ilog2(parameter);\n\tif(parameter == 1u<<k) {\n\t\tunsigned pattern;\n\n\t\tFLAC__ASSERT(k <= 30);\n\n\t\tmsbs = uval >> k;\n\t\ttotal_bits = 1 + k + msbs;\n\t\tpattern = 1 << k; /* the unary end bit */\n\t\tpattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */\n\n\t\tif(total_bits <= 32) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t/* write the unary MSBs */\n\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, msbs))\n\t\t\t\treturn false;\n\t\t\t/* write the unary end bit and binary LSBs */\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\tunsigned q, r, d;\n\n\t\td = (1 << (k+1)) - parameter;\n\t\tq = uval / parameter;\n\t\tr = uval - (q * parameter);\n\t\t/* write the unary MSBs */\n\t\tif(!FLAC__bitwriter_write_zeroes(bw, q))\n\t\t\treturn false;\n\t\t/* write the unary end bit */\n\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))\n\t\t\treturn false;\n\t\t/* write the binary LSBs */\n\t\tif(r >= d) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, r, k))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n#endif /* UNUSED */\n\nFLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val)\n{\n\tFLAC__bool ok = 1;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\tif((val & 0x80000000) != 0) /* this version only handles 31 bits */\n\t\treturn false;\n\n\tif(val < 0x80) {\n\t\treturn FLAC__bitwriter_write_raw_uint32_nocheck(bw, val, 8);\n\t}\n\telse if(val < 0x800) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xC0 | (val>>6), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x10000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xE0 | (val>>12), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x200000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xF0 | (val>>18), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse if(val < 0x4000000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xF8 | (val>>24), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (val&0x3F), 8);\n\t}\n\telse {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xFC | (val>>30), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>24)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | ((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (val&0x3F), 8);\n\t}\n\n\treturn ok;\n}\n\nFLAC__bool FLAC__bitwriter_write_utf8_uint64(FLAC__BitWriter *bw, FLAC__uint64 val)\n{\n\tFLAC__bool ok = 1;\n\n\tFLAC__ASSERT(0 != bw);\n\tFLAC__ASSERT(0 != bw->buffer);\n\n\tif((val & FLAC__U64L(0xFFFFFFF000000000)) != 0) /* this version only handles 36 bits */\n\t\treturn false;\n\n\tif(val < 0x80) {\n\t\treturn FLAC__bitwriter_write_raw_uint32_nocheck(bw, (FLAC__uint32)val, 8);\n\t}\n\telse if(val < 0x800) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xC0 | (FLAC__uint32)(val>>6), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\telse if(val < 0x10000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xE0 | (FLAC__uint32)(val>>12), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\telse if(val < 0x200000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xF0 | (FLAC__uint32)(val>>18), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\telse if(val < 0x4000000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xF8 | (FLAC__uint32)(val>>24), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\telse if(val < 0x80000000) {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xFC | (FLAC__uint32)(val>>30), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\telse {\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0xFE, 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>30)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);\n\t\tok &= FLAC__bitwriter_write_raw_uint32_nocheck(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);\n\t}\n\n\treturn ok;\n}\n\nFLAC__bool FLAC__bitwriter_zero_pad_to_byte_boundary(FLAC__BitWriter *bw)\n{\n\t/* 0-pad to byte boundary */\n\tif(bw->bits & 7u)\n\t\treturn FLAC__bitwriter_write_zeroes(bw, 8 - (bw->bits & 7u));\n\telse\n\t\treturn true;\n}\n\n/* These functions are declared inline in this file but are also callable as\n * externs from elsewhere.\n * According to the C99 spec, section 6.7.4, simply providing a function\n * prototype in a header file without 'inline' and making the function inline\n * in this file should be sufficient.\n * Unfortunately, the Microsoft VS compiler doesn't pick them up externally. To\n * fix that we add extern declarations here.\n */\nextern FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, unsigned bits);\nextern FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits);\nextern FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, unsigned bits);\nextern FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, unsigned bits);\nextern FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val);\nextern FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], unsigned nvals);\n","/* alloc - Convenience routines for safely allocating memory\n * Copyright (C) 2007-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FLAC__SHARE__ALLOC_H\n#define FLAC__SHARE__ALLOC_H\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n/* WATCHOUT: for c++ you may have to #define __STDC_LIMIT_MACROS 1 real early\n * before #including this file,  otherwise SIZE_MAX might not be defined\n */\n\n#include <limits.h> /* for SIZE_MAX */\n#if HAVE_STDINT_H\n#include <stdint.h> /* for SIZE_MAX in case limits.h didn't get it */\n#endif\n#include <stdlib.h> /* for size_t, malloc(), etc */\n#include \"share/compat.h\"\n\n#ifndef SIZE_MAX\n# ifndef SIZE_T_MAX\n#  ifdef _MSC_VER\n#   ifdef _WIN64\n#    define SIZE_T_MAX FLAC__U64L(0xffffffffffffffff)\n#   else\n#    define SIZE_T_MAX 0xffffffff\n#   endif\n#  else\n#   error\n#  endif\n# endif\n# define SIZE_MAX SIZE_T_MAX\n#endif\n\n/* avoid malloc()ing 0 bytes, see:\n * https://www.securecoding.cert.org/confluence/display/seccode/MEM04-A.+Do+not+make+assumptions+about+the+result+of+allocating+0+bytes?focusedCommentId=5407003\n*/\nstatic inline void *safe_malloc_(size_t size)\n{\n\t/* malloc(0) is undefined; FLAC src convention is to always allocate */\n\tif(!size)\n\t\tsize++;\n\treturn malloc(size);\n}\n\nstatic inline void *safe_calloc_(size_t nmemb, size_t size)\n{\n\tif(!nmemb || !size)\n\t\treturn malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */\n\treturn calloc(nmemb, size);\n}\n\n/*@@@@ there's probably a better way to prevent overflows when allocating untrusted sums but this works for now */\n\nstatic inline void *safe_malloc_add_2op_(size_t size1, size_t size2)\n{\n\tsize2 += size1;\n\tif(size2 < size1)\n\t\treturn 0;\n\treturn safe_malloc_(size2);\n}\n\nstatic inline void *safe_malloc_add_3op_(size_t size1, size_t size2, size_t size3)\n{\n\tsize2 += size1;\n\tif(size2 < size1)\n\t\treturn 0;\n\tsize3 += size2;\n\tif(size3 < size2)\n\t\treturn 0;\n\treturn safe_malloc_(size3);\n}\n\nstatic inline void *safe_malloc_add_4op_(size_t size1, size_t size2, size_t size3, size_t size4)\n{\n\tsize2 += size1;\n\tif(size2 < size1)\n\t\treturn 0;\n\tsize3 += size2;\n\tif(size3 < size2)\n\t\treturn 0;\n\tsize4 += size3;\n\tif(size4 < size3)\n\t\treturn 0;\n\treturn safe_malloc_(size4);\n}\n\nvoid *safe_malloc_mul_2op_(size_t size1, size_t size2) ;\n\nstatic inline void *safe_malloc_mul_3op_(size_t size1, size_t size2, size_t size3)\n{\n\tif(!size1 || !size2 || !size3)\n\t\treturn malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */\n\tif(size1 > SIZE_MAX / size2)\n\t\treturn 0;\n\tsize1 *= size2;\n\tif(size1 > SIZE_MAX / size3)\n\t\treturn 0;\n\treturn malloc(size1*size3);\n}\n\n/* size1*size2 + size3 */\nstatic inline void *safe_malloc_mul2add_(size_t size1, size_t size2, size_t size3)\n{\n\tif(!size1 || !size2)\n\t\treturn safe_malloc_(size3);\n\tif(size1 > SIZE_MAX / size2)\n\t\treturn 0;\n\treturn safe_malloc_add_2op_(size1*size2, size3);\n}\n\n/* size1 * (size2 + size3) */\nstatic inline void *safe_malloc_muladd2_(size_t size1, size_t size2, size_t size3)\n{\n\tif(!size1 || (!size2 && !size3))\n\t\treturn malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */\n\tsize2 += size3;\n\tif(size2 < size3)\n\t\treturn 0;\n\tif(size1 > SIZE_MAX / size2)\n\t\treturn 0;\n\treturn malloc(size1*size2);\n}\n\nstatic inline void *safe_realloc_(void *ptr, size_t size)\n{\n\tvoid *oldptr = ptr;\n\tvoid *newptr = realloc(ptr, size);\n\tif(size > 0 && newptr == 0)\n\t\tfree(oldptr);\n\treturn newptr;\n}\nstatic inline void *safe_realloc_add_2op_(void *ptr, size_t size1, size_t size2)\n{\n\tsize2 += size1;\n\tif(size2 < size1) {\n\t\tfree(ptr);\n\t\treturn 0;\n\t}\n\treturn realloc(ptr, size2);\n}\n\nstatic inline void *safe_realloc_add_3op_(void *ptr, size_t size1, size_t size2, size_t size3)\n{\n\tsize2 += size1;\n\tif(size2 < size1)\n\t\treturn 0;\n\tsize3 += size2;\n\tif(size3 < size2)\n\t\treturn 0;\n\treturn realloc(ptr, size3);\n}\n\nstatic inline void *safe_realloc_add_4op_(void *ptr, size_t size1, size_t size2, size_t size3, size_t size4)\n{\n\tsize2 += size1;\n\tif(size2 < size1)\n\t\treturn 0;\n\tsize3 += size2;\n\tif(size3 < size2)\n\t\treturn 0;\n\tsize4 += size3;\n\tif(size4 < size3)\n\t\treturn 0;\n\treturn realloc(ptr, size4);\n}\n\nstatic inline void *safe_realloc_mul_2op_(void *ptr, size_t size1, size_t size2)\n{\n\tif(!size1 || !size2)\n\t\treturn realloc(ptr, 0); /* preserve POSIX realloc(ptr, 0) semantics */\n\tif(size1 > SIZE_MAX / size2)\n\t\treturn 0;\n\treturn safe_realloc_(ptr, size1*size2);\n}\n\n/* size1 * (size2 + size3) */\nstatic inline void *safe_realloc_muladd2_(void *ptr, size_t size1, size_t size2, size_t size3)\n{\n\tif(!size1 || (!size2 && !size3))\n\t\treturn realloc(ptr, 0); /* preserve POSIX realloc(ptr, 0) semantics */\n\tsize2 += size3;\n\tif(size2 < size3)\n\t\treturn 0;\n\treturn safe_realloc_mul_2op_(ptr, size1, size2);\n}\n\n#endif\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2001-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include \"private/cpu.h\"\n#include \"share/compat.h\"\n#include <stdlib.h>\n#include <memory.h>\n\n#if defined(_MSC_VER)\n#  include <intrin.h> /* for __cpuid() and _xgetbv() */\n#endif\n\n#if defined __GNUC__ && defined HAVE_CPUID_H\n#  include <cpuid.h> /* for __get_cpuid() and __get_cpuid_max() */\n#endif\n\n#ifdef DEBUG\n#include <stdio.h>\n\n#define dfprintf fprintf\n#else\n/* This is bad practice, it should be a static void empty function */\n#define dfprintf(file, format, ...)\n#endif\n\n\n#if defined FLAC__CPU_IA32\n/* these are flags in EDX of CPUID AX=00000001 */\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_CMOV = 0x00008000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_MMX = 0x00800000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSE = 0x02000000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSE2 = 0x04000000;\n#endif\n\n#if FLAC__HAS_X86INTRIN || FLAC__AVX_SUPPORTED\n/* these are flags in ECX of CPUID AX=00000001 */\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSE3 = 0x00000001;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSSE3 = 0x00000200;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSE41 = 0x00080000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_SSE42 = 0x00100000;\n\n/* these are flags in ECX of CPUID AX=00000001 */\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_OSXSAVE = 0x08000000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_AVX = 0x10000000;\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_FMA = 0x00001000;\n/* these are flags in EBX of CPUID AX=00000007 */\nstatic const unsigned FLAC__CPUINFO_IA32_CPUID_AVX2 = 0x00000020;\n#endif\n\n#if defined FLAC__CPU_IA32 || defined FLAC__CPU_X86_64\nstatic uint32_t\ncpu_xgetbv_x86(void)\n{\n#if (defined _MSC_VER || defined __INTEL_COMPILER) && FLAC__HAS_X86INTRIN && FLAC__AVX_SUPPORTED\n\treturn (uint32_t)_xgetbv(0);\n#elif defined __GNUC__\n\tuint32_t lo, hi;\n\tasm volatile (\".byte 0x0f, 0x01, 0xd0\" : \"=a\"(lo), \"=d\"(hi) : \"c\" (0));\n\treturn lo;\n#else\n\treturn 0;\n#endif\n}\n#endif\n\nstatic void\nia32_cpu_info (FLAC__CPUInfo *info)\n{\n#if !defined FLAC__CPU_IA32\n\t(void) info;\n#else\n\tFLAC__bool ia32_osxsave = false;\n\tFLAC__uint32 flags_eax, flags_ebx, flags_ecx, flags_edx;\n\n#if !defined FLAC__NO_ASM && (defined FLAC__HAS_NASM || FLAC__HAS_X86INTRIN)\n\tinfo->use_asm = true; /* we assume a minimum of 80386 with FLAC__CPU_IA32 */\n#if defined FLAC__HAS_NASM\n\tif(!FLAC__cpu_have_cpuid_asm_ia32())\n\t\treturn;\n#endif\n\t/* http://www.sandpile.org/x86/cpuid.htm */\n\tif (FLAC__HAS_X86INTRIN) {\n\t\tFLAC__cpu_info_x86(0, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\t\tinfo->ia32.intel = (flags_ebx == 0x756E6547 && flags_edx == 0x49656E69 && flags_ecx == 0x6C65746E) ? true : false; /* GenuineIntel */\n\t\tFLAC__cpu_info_x86(1, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\t}\n\telse {\n\t\tFLAC__cpu_info_asm_ia32(&flags_edx, &flags_ecx);\n\t}\n\n\tinfo->ia32.cmov  = (flags_edx & FLAC__CPUINFO_IA32_CPUID_CMOV ) ? true : false;\n\tinfo->ia32.mmx   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_MMX  ) ? true : false;\n\tinfo->ia32.sse   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_SSE  ) ? true : false;\n\tinfo->ia32.sse2  = (flags_edx & FLAC__CPUINFO_IA32_CPUID_SSE2 ) ? true : false;\n\tinfo->ia32.sse3  = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE3 ) ? true : false;\n\tinfo->ia32.ssse3 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSSE3) ? true : false;\n\tinfo->ia32.sse41 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE41) ? true : false;\n\tinfo->ia32.sse42 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE42) ? true : false;\n\n\tif (FLAC__HAS_X86INTRIN && FLAC__AVX_SUPPORTED) {\n\t\tia32_osxsave = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_OSXSAVE) ? true : false;\n\t\tinfo->ia32.avx   = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_AVX    ) ? true : false;\n\t\tinfo->ia32.fma   = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_FMA    ) ? true : false;\n\t\tFLAC__cpu_info_x86(7, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\t\tinfo->ia32.avx2  = (flags_ebx & FLAC__CPUINFO_IA32_CPUID_AVX2   ) ? true : false;\n\t}\n\n\tdfprintf(stderr, \"CPU info (IA-32):\\n\");\n\tdfprintf(stderr, \"  CMOV ....... %c\\n\", info->ia32.cmov    ? 'Y' : 'n');\n\tdfprintf(stderr, \"  MMX ........ %c\\n\", info->ia32.mmx     ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE ........ %c\\n\", info->ia32.sse     ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE2 ....... %c\\n\", info->ia32.sse2    ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE3 ....... %c\\n\", info->ia32.sse3    ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSSE3 ...... %c\\n\", info->ia32.ssse3   ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE41 ...... %c\\n\", info->ia32.sse41   ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE42 ...... %c\\n\", info->ia32.sse42   ? 'Y' : 'n');\n\n\tif (FLAC__HAS_X86INTRIN && FLAC__AVX_SUPPORTED) {\n\t\tdfprintf(stderr, \"  AVX ........ %c\\n\", info->ia32.avx     ? 'Y' : 'n');\n\t\tdfprintf(stderr, \"  FMA ........ %c\\n\", info->ia32.fma     ? 'Y' : 'n');\n\t\tdfprintf(stderr, \"  AVX2 ....... %c\\n\", info->ia32.avx2    ? 'Y' : 'n');\n\t}\n\n\t/*\n\t * now have to check for OS support of AVX instructions\n\t */\n\tif (!FLAC__HAS_X86INTRIN || !info->ia32.avx || !ia32_osxsave || (cpu_xgetbv_x86() & 0x6) != 0x6) {\n\t\t/* no OS AVX support */\n\t\tinfo->ia32.avx     = false;\n\t\tinfo->ia32.avx2    = false;\n\t\tinfo->ia32.fma     = false;\n\t}\n\n\tif (FLAC__HAS_X86INTRIN && FLAC__AVX_SUPPORTED) {\n\t\tdfprintf(stderr, \"  AVX OS sup . %c\\n\", info->ia32.avx ? 'Y' : 'n');\n\t}\n#else\n\tinfo->use_asm = false;\n#endif\n#endif\n}\n\nstatic void\nx86_64_cpu_info (FLAC__CPUInfo *info)\n{\n#if !defined FLAC__NO_ASM && FLAC__HAS_X86INTRIN\n\tFLAC__bool x86_osxsave = false;\n\tFLAC__uint32 flags_eax, flags_ebx, flags_ecx, flags_edx;\n\n\tinfo->use_asm = true;\n\n\t/* http://www.sandpile.org/x86/cpuid.htm */\n\tFLAC__cpu_info_x86(0, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\tinfo->x86.intel = (flags_ebx == 0x756E6547 && flags_edx == 0x49656E69 && flags_ecx == 0x6C65746E) ? true : false; /* GenuineIntel */\n\tFLAC__cpu_info_x86(1, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\tinfo->x86.sse3  = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE3 ) ? true : false;\n\tinfo->x86.ssse3 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSSE3) ? true : false;\n\tinfo->x86.sse41 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE41) ? true : false;\n\tinfo->x86.sse42 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE42) ? true : false;\n\n\tif (FLAC__AVX_SUPPORTED) {\n\t\tx86_osxsave = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_OSXSAVE) ? true : false;\n\t\tinfo->x86.avx   = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_AVX    ) ? true : false;\n\t\tinfo->x86.fma   = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_FMA    ) ? true : false;\n\t\tFLAC__cpu_info_x86(7, &flags_eax, &flags_ebx, &flags_ecx, &flags_edx);\n\t\tinfo->x86.avx2  = (flags_ebx & FLAC__CPUINFO_IA32_CPUID_AVX2   ) ? true : false;\n\t}\n\n\tdfprintf(stderr, \"CPU info (x86-64):\\n\");\n\tdfprintf(stderr, \"  SSE3 ....... %c\\n\", info->x86.sse3  ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSSE3 ...... %c\\n\", info->x86.ssse3 ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE41 ...... %c\\n\", info->x86.sse41 ? 'Y' : 'n');\n\tdfprintf(stderr, \"  SSE42 ...... %c\\n\", info->x86.sse42 ? 'Y' : 'n');\n\n\tif (FLAC__AVX_SUPPORTED) {\n\t\tdfprintf(stderr, \"  AVX ........ %c\\n\", info->x86.avx   ? 'Y' : 'n');\n\t\tdfprintf(stderr, \"  FMA ........ %c\\n\", info->x86.fma   ? 'Y' : 'n');\n\t\tdfprintf(stderr, \"  AVX2 ....... %c\\n\", info->x86.avx2  ? 'Y' : 'n');\n\t}\n\n\t/*\n\t * now have to check for OS support of AVX instructions\n\t */\n\tif (!info->x86.avx || !x86_osxsave || (cpu_xgetbv_x86() & 0x6) != 0x6) {\n\t\t/* no OS AVX support */\n\t\tinfo->x86.avx     = false;\n\t\tinfo->x86.avx2    = false;\n\t\tinfo->x86.fma     = false;\n\t}\n\n\tif (FLAC__AVX_SUPPORTED) {\n\t\tdfprintf(stderr, \"  AVX OS sup . %c\\n\", info->x86.avx ? 'Y' : 'n');\n\t}\n#else\n\t/* Silence compiler warnings. */\n\t(void) info;\n#if defined FLAC__CPU_IA32 || defined FLAC__CPU_X86_64\n\tif (0) cpu_xgetbv_x86 ();\n#endif\n#endif\n}\n\nvoid FLAC__cpu_info (FLAC__CPUInfo *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\n#ifdef FLAC__CPU_IA32\n\tinfo->type = FLAC__CPUINFO_TYPE_IA32;\n#elif defined FLAC__CPU_X86_64\n\tinfo->type = FLAC__CPUINFO_TYPE_X86_64;\n#else\n\tinfo->type = FLAC__CPUINFO_TYPE_UNKNOWN;\n\tinfo->use_asm = false;\n#endif\n\n\tswitch (info->type) {\n\tcase FLAC__CPUINFO_TYPE_IA32:\n\t\tia32_cpu_info (info);\n\t\tbreak;\n\tcase FLAC__CPUINFO_TYPE_X86_64:\n\t\tx86_64_cpu_info (info);\n\t\tbreak;\n\tdefault:\n\t\tinfo->use_asm = false;\n\t\tbreak;\n\t}\n}\n\n#if (defined FLAC__CPU_IA32 || defined FLAC__CPU_X86_64) && FLAC__HAS_X86INTRIN\n\nvoid FLAC__cpu_info_x86(FLAC__uint32 level, FLAC__uint32 *eax, FLAC__uint32 *ebx, FLAC__uint32 *ecx, FLAC__uint32 *edx)\n{\n#if defined _MSC_VER || defined __INTEL_COMPILER\n\tint cpuinfo[4];\n\tint ext = level & 0x80000000;\n\t__cpuid(cpuinfo, ext);\n\tif((unsigned)cpuinfo[0] >= level) {\n#if FLAC__AVX_SUPPORTED\n\t\t__cpuidex(cpuinfo, ext, 0); /* for AVX2 detection */\n#else\n\t\t__cpuid(cpuinfo, ext); /* some old compilers don't support __cpuidex */\n#endif\n\n\t\t*eax = cpuinfo[0]; *ebx = cpuinfo[1]; *ecx = cpuinfo[2]; *edx = cpuinfo[3];\n\n\t\treturn;\n\t}\n#elif defined __GNUC__ && defined HAVE_CPUID_H\n\tFLAC__uint32 ext = level & 0x80000000;\n\t__cpuid(ext, *eax, *ebx, *ecx, *edx);\n\tif (*eax >= level) {\n\t\t__cpuid_count(level, 0, *eax, *ebx, *ecx, *edx);\n\n\t\treturn;\n\t}\n#endif\n\t*eax = *ebx = *ecx = *edx = 0;\n}\n\n#endif /* (FLAC__CPU_IA32 || FLAC__CPU_X86_64) && FLAC__HAS_X86INTRIN */\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include \"private/crc.h\"\n\n/* CRC-8, poly = x^8 + x^2 + x^1 + x^0, init = 0 */\n\nFLAC__byte const FLAC__crc8_table[256] = {\n\t0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,\n\t0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,\n\t0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,\n\t0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,\n\t0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,\n\t0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,\n\t0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,\n\t0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,\n\t0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,\n\t0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,\n\t0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,\n\t0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,\n\t0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,\n\t0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,\n\t0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,\n\t0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,\n\t0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,\n\t0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,\n\t0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,\n\t0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,\n\t0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,\n\t0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,\n\t0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,\n\t0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,\n\t0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,\n\t0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,\n\t0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,\n\t0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,\n\t0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,\n\t0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,\n\t0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,\n\t0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3\n};\n\n/* CRC-16, poly = x^16 + x^15 + x^2 + x^0, init = 0 */\n\nunsigned const FLAC__crc16_table[256] = {\n\t0x0000,  0x8005,  0x800f,  0x000a,  0x801b,  0x001e,  0x0014,  0x8011,\n\t0x8033,  0x0036,  0x003c,  0x8039,  0x0028,  0x802d,  0x8027,  0x0022,\n\t0x8063,  0x0066,  0x006c,  0x8069,  0x0078,  0x807d,  0x8077,  0x0072,\n\t0x0050,  0x8055,  0x805f,  0x005a,  0x804b,  0x004e,  0x0044,  0x8041,\n\t0x80c3,  0x00c6,  0x00cc,  0x80c9,  0x00d8,  0x80dd,  0x80d7,  0x00d2,\n\t0x00f0,  0x80f5,  0x80ff,  0x00fa,  0x80eb,  0x00ee,  0x00e4,  0x80e1,\n\t0x00a0,  0x80a5,  0x80af,  0x00aa,  0x80bb,  0x00be,  0x00b4,  0x80b1,\n\t0x8093,  0x0096,  0x009c,  0x8099,  0x0088,  0x808d,  0x8087,  0x0082,\n\t0x8183,  0x0186,  0x018c,  0x8189,  0x0198,  0x819d,  0x8197,  0x0192,\n\t0x01b0,  0x81b5,  0x81bf,  0x01ba,  0x81ab,  0x01ae,  0x01a4,  0x81a1,\n\t0x01e0,  0x81e5,  0x81ef,  0x01ea,  0x81fb,  0x01fe,  0x01f4,  0x81f1,\n\t0x81d3,  0x01d6,  0x01dc,  0x81d9,  0x01c8,  0x81cd,  0x81c7,  0x01c2,\n\t0x0140,  0x8145,  0x814f,  0x014a,  0x815b,  0x015e,  0x0154,  0x8151,\n\t0x8173,  0x0176,  0x017c,  0x8179,  0x0168,  0x816d,  0x8167,  0x0162,\n\t0x8123,  0x0126,  0x012c,  0x8129,  0x0138,  0x813d,  0x8137,  0x0132,\n\t0x0110,  0x8115,  0x811f,  0x011a,  0x810b,  0x010e,  0x0104,  0x8101,\n\t0x8303,  0x0306,  0x030c,  0x8309,  0x0318,  0x831d,  0x8317,  0x0312,\n\t0x0330,  0x8335,  0x833f,  0x033a,  0x832b,  0x032e,  0x0324,  0x8321,\n\t0x0360,  0x8365,  0x836f,  0x036a,  0x837b,  0x037e,  0x0374,  0x8371,\n\t0x8353,  0x0356,  0x035c,  0x8359,  0x0348,  0x834d,  0x8347,  0x0342,\n\t0x03c0,  0x83c5,  0x83cf,  0x03ca,  0x83db,  0x03de,  0x03d4,  0x83d1,\n\t0x83f3,  0x03f6,  0x03fc,  0x83f9,  0x03e8,  0x83ed,  0x83e7,  0x03e2,\n\t0x83a3,  0x03a6,  0x03ac,  0x83a9,  0x03b8,  0x83bd,  0x83b7,  0x03b2,\n\t0x0390,  0x8395,  0x839f,  0x039a,  0x838b,  0x038e,  0x0384,  0x8381,\n\t0x0280,  0x8285,  0x828f,  0x028a,  0x829b,  0x029e,  0x0294,  0x8291,\n\t0x82b3,  0x02b6,  0x02bc,  0x82b9,  0x02a8,  0x82ad,  0x82a7,  0x02a2,\n\t0x82e3,  0x02e6,  0x02ec,  0x82e9,  0x02f8,  0x82fd,  0x82f7,  0x02f2,\n\t0x02d0,  0x82d5,  0x82df,  0x02da,  0x82cb,  0x02ce,  0x02c4,  0x82c1,\n\t0x8243,  0x0246,  0x024c,  0x8249,  0x0258,  0x825d,  0x8257,  0x0252,\n\t0x0270,  0x8275,  0x827f,  0x027a,  0x826b,  0x026e,  0x0264,  0x8261,\n\t0x0220,  0x8225,  0x822f,  0x022a,  0x823b,  0x023e,  0x0234,  0x8231,\n\t0x8213,  0x0216,  0x021c,  0x8219,  0x0208,  0x820d,  0x8207,  0x0202\n};\n\n\nvoid FLAC__crc8_update(const FLAC__byte data, FLAC__uint8 *crc)\n{\n\t*crc = FLAC__crc8_table[*crc ^ data];\n}\n\nvoid FLAC__crc8_update_block(const FLAC__byte *data, unsigned len, FLAC__uint8 *crc)\n{\n\twhile(len--)\n\t\t*crc = FLAC__crc8_table[*crc ^ *data++];\n}\n\nFLAC__uint8 FLAC__crc8(const FLAC__byte *data, unsigned len)\n{\n\tFLAC__uint8 crc = 0;\n\n\twhile(len--)\n\t\tcrc = FLAC__crc8_table[crc ^ *data++];\n\n\treturn crc;\n}\n\nunsigned FLAC__crc16(const FLAC__byte *data, unsigned len)\n{\n\tunsigned crc = 0;\n\n\twhile(len--)\n\t\tcrc = ((crc<<8) ^ FLAC__crc16_table[(crc>>8) ^ *data++]) & 0xffff;\n\n\treturn crc;\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <math.h>\n#include <string.h>\n#include \"share/compat.h\"\n#include \"private/bitmath.h\"\n#include \"private/fixed.h\"\n#include \"private/macros.h\"\n#include \"FLAC/assert.h\"\n\n#ifdef local_abs\n#undef local_abs\n#endif\n#define local_abs(x) ((unsigned)((x)<0? -(x) : (x)))\n\n#ifdef FLAC__INTEGER_ONLY_LIBRARY\n/* rbps stands for residual bits per sample\n *\n *             (ln(2) * err)\n * rbps = log  (-----------)\n *           2 (     n     )\n */\nstatic FLAC__fixedpoint local__compute_rbps_integerized(FLAC__uint32 err, FLAC__uint32 n)\n{\n\tFLAC__uint32 rbps;\n\tunsigned bits; /* the number of bits required to represent a number */\n\tint fracbits; /* the number of bits of rbps that comprise the fractional part */\n\n\tFLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));\n\tFLAC__ASSERT(err > 0);\n\tFLAC__ASSERT(n > 0);\n\n\tFLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);\n\tif(err <= n)\n\t\treturn 0;\n\t/*\n\t * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.\n\t * These allow us later to know we won't lose too much precision in the\n\t * fixed-point division (err<<fracbits)/n.\n\t */\n\n\tfracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2(err)+1);\n\n\terr <<= fracbits;\n\terr /= n;\n\t/* err now holds err/n with fracbits fractional bits */\n\n\t/*\n\t * Whittle err down to 16 bits max.  16 significant bits is enough for\n\t * our purposes.\n\t */\n\tFLAC__ASSERT(err > 0);\n\tbits = FLAC__bitmath_ilog2(err)+1;\n\tif(bits > 16) {\n\t\terr >>= (bits-16);\n\t\tfracbits -= (bits-16);\n\t}\n\trbps = (FLAC__uint32)err;\n\n\t/* Multiply by fixed-point version of ln(2), with 16 fractional bits */\n\trbps *= FLAC__FP_LN2;\n\tfracbits += 16;\n\tFLAC__ASSERT(fracbits >= 0);\n\n\t/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */\n\t{\n\t\tconst int f = fracbits & 3;\n\t\tif(f) {\n\t\t\trbps >>= f;\n\t\t\tfracbits -= f;\n\t\t}\n\t}\n\n\trbps = FLAC__fixedpoint_log2(rbps, fracbits, (unsigned)(-1));\n\n\tif(rbps == 0)\n\t\treturn 0;\n\n\t/*\n\t * The return value must have 16 fractional bits.  Since the whole part\n\t * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits\n\t * must be >= -3, these assertion allows us to be able to shift rbps\n\t * left if necessary to get 16 fracbits without losing any bits of the\n\t * whole part of rbps.\n\t *\n\t * There is a slight chance due to accumulated error that the whole part\n\t * will require 6 bits, so we use 6 in the assertion.  Really though as\n\t * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.\n\t */\n\tFLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);\n\tFLAC__ASSERT(fracbits >= -3);\n\n\t/* now shift the decimal point into place */\n\tif(fracbits < 16)\n\t\treturn rbps << (16-fracbits);\n\telse if(fracbits > 16)\n\t\treturn rbps >> (fracbits-16);\n\telse\n\t\treturn rbps;\n}\n\nstatic FLAC__fixedpoint local__compute_rbps_wide_integerized(FLAC__uint64 err, FLAC__uint32 n)\n{\n\tFLAC__uint32 rbps;\n\tunsigned bits; /* the number of bits required to represent a number */\n\tint fracbits; /* the number of bits of rbps that comprise the fractional part */\n\n\tFLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));\n\tFLAC__ASSERT(err > 0);\n\tFLAC__ASSERT(n > 0);\n\n\tFLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);\n\tif(err <= n)\n\t\treturn 0;\n\t/*\n\t * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.\n\t * These allow us later to know we won't lose too much precision in the\n\t * fixed-point division (err<<fracbits)/n.\n\t */\n\n\tfracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2_wide(err)+1);\n\n\terr <<= fracbits;\n\terr /= n;\n\t/* err now holds err/n with fracbits fractional bits */\n\n\t/*\n\t * Whittle err down to 16 bits max.  16 significant bits is enough for\n\t * our purposes.\n\t */\n\tFLAC__ASSERT(err > 0);\n\tbits = FLAC__bitmath_ilog2_wide(err)+1;\n\tif(bits > 16) {\n\t\terr >>= (bits-16);\n\t\tfracbits -= (bits-16);\n\t}\n\trbps = (FLAC__uint32)err;\n\n\t/* Multiply by fixed-point version of ln(2), with 16 fractional bits */\n\trbps *= FLAC__FP_LN2;\n\tfracbits += 16;\n\tFLAC__ASSERT(fracbits >= 0);\n\n\t/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */\n\t{\n\t\tconst int f = fracbits & 3;\n\t\tif(f) {\n\t\t\trbps >>= f;\n\t\t\tfracbits -= f;\n\t\t}\n\t}\n\n\trbps = FLAC__fixedpoint_log2(rbps, fracbits, (unsigned)(-1));\n\n\tif(rbps == 0)\n\t\treturn 0;\n\n\t/*\n\t * The return value must have 16 fractional bits.  Since the whole part\n\t * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits\n\t * must be >= -3, these assertion allows us to be able to shift rbps\n\t * left if necessary to get 16 fracbits without losing any bits of the\n\t * whole part of rbps.\n\t *\n\t * There is a slight chance due to accumulated error that the whole part\n\t * will require 6 bits, so we use 6 in the assertion.  Really though as\n\t * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.\n\t */\n\tFLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);\n\tFLAC__ASSERT(fracbits >= -3);\n\n\t/* now shift the decimal point into place */\n\tif(fracbits < 16)\n\t\treturn rbps << (16-fracbits);\n\telse if(fracbits > 16)\n\t\treturn rbps >> (fracbits-16);\n\telse\n\t\treturn rbps;\n}\n#endif\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\nunsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])\n#else\nunsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])\n#endif\n{\n\tFLAC__int32 last_error_0 = data[-1];\n\tFLAC__int32 last_error_1 = data[-1] - data[-2];\n\tFLAC__int32 last_error_2 = last_error_1 - (data[-2] - data[-3]);\n\tFLAC__int32 last_error_3 = last_error_2 - (data[-2] - 2*data[-3] + data[-4]);\n\tFLAC__int32 error, save;\n\tFLAC__uint32 total_error_0 = 0, total_error_1 = 0, total_error_2 = 0, total_error_3 = 0, total_error_4 = 0;\n\tunsigned i, order;\n\n\tfor(i = 0; i < data_len; i++) {\n\t\terror  = data[i]     ; total_error_0 += local_abs(error);                      save = error;\n\t\terror -= last_error_0; total_error_1 += local_abs(error); last_error_0 = save; save = error;\n\t\terror -= last_error_1; total_error_2 += local_abs(error); last_error_1 = save; save = error;\n\t\terror -= last_error_2; total_error_3 += local_abs(error); last_error_2 = save; save = error;\n\t\terror -= last_error_3; total_error_4 += local_abs(error); last_error_3 = save;\n\t}\n\n\tif(total_error_0 < flac_min(flac_min(flac_min(total_error_1, total_error_2), total_error_3), total_error_4))\n\t\torder = 0;\n\telse if(total_error_1 < flac_min(flac_min(total_error_2, total_error_3), total_error_4))\n\t\torder = 1;\n\telse if(total_error_2 < flac_min(total_error_3, total_error_4))\n\t\torder = 2;\n\telse if(total_error_3 < total_error_4)\n\t\torder = 3;\n\telse\n\t\torder = 4;\n\n\t/* Estimate the expected number of bits per residual signal sample. */\n\t/* 'total_error*' is linearly related to the variance of the residual */\n\t/* signal, so we use it directly to compute E(|x|) */\n\tFLAC__ASSERT(data_len > 0 || total_error_0 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_1 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_2 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_3 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_4 == 0);\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tresidual_bits_per_sample[0] = (float)((total_error_0 > 0) ? log(M_LN2 * (double)total_error_0 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[1] = (float)((total_error_1 > 0) ? log(M_LN2 * (double)total_error_1 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[2] = (float)((total_error_2 > 0) ? log(M_LN2 * (double)total_error_2 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[3] = (float)((total_error_3 > 0) ? log(M_LN2 * (double)total_error_3 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[4] = (float)((total_error_4 > 0) ? log(M_LN2 * (double)total_error_4 / (double)data_len) / M_LN2 : 0.0);\n#else\n\tresidual_bits_per_sample[0] = (total_error_0 > 0) ? local__compute_rbps_integerized(total_error_0, data_len) : 0;\n\tresidual_bits_per_sample[1] = (total_error_1 > 0) ? local__compute_rbps_integerized(total_error_1, data_len) : 0;\n\tresidual_bits_per_sample[2] = (total_error_2 > 0) ? local__compute_rbps_integerized(total_error_2, data_len) : 0;\n\tresidual_bits_per_sample[3] = (total_error_3 > 0) ? local__compute_rbps_integerized(total_error_3, data_len) : 0;\n\tresidual_bits_per_sample[4] = (total_error_4 > 0) ? local__compute_rbps_integerized(total_error_4, data_len) : 0;\n#endif\n\n\treturn order;\n}\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\nunsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])\n#else\nunsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])\n#endif\n{\n\tFLAC__int32 last_error_0 = data[-1];\n\tFLAC__int32 last_error_1 = data[-1] - data[-2];\n\tFLAC__int32 last_error_2 = last_error_1 - (data[-2] - data[-3]);\n\tFLAC__int32 last_error_3 = last_error_2 - (data[-2] - 2*data[-3] + data[-4]);\n\tFLAC__int32 error, save;\n\t/* total_error_* are 64-bits to avoid overflow when encoding\n\t * erratic signals when the bits-per-sample and blocksize are\n\t * large.\n\t */\n\tFLAC__uint64 total_error_0 = 0, total_error_1 = 0, total_error_2 = 0, total_error_3 = 0, total_error_4 = 0;\n\tunsigned i, order;\n\n\tfor(i = 0; i < data_len; i++) {\n\t\terror  = data[i]     ; total_error_0 += local_abs(error);                      save = error;\n\t\terror -= last_error_0; total_error_1 += local_abs(error); last_error_0 = save; save = error;\n\t\terror -= last_error_1; total_error_2 += local_abs(error); last_error_1 = save; save = error;\n\t\terror -= last_error_2; total_error_3 += local_abs(error); last_error_2 = save; save = error;\n\t\terror -= last_error_3; total_error_4 += local_abs(error); last_error_3 = save;\n\t}\n\n\tif(total_error_0 < flac_min(flac_min(flac_min(total_error_1, total_error_2), total_error_3), total_error_4))\n\t\torder = 0;\n\telse if(total_error_1 < flac_min(flac_min(total_error_2, total_error_3), total_error_4))\n\t\torder = 1;\n\telse if(total_error_2 < flac_min(total_error_3, total_error_4))\n\t\torder = 2;\n\telse if(total_error_3 < total_error_4)\n\t\torder = 3;\n\telse\n\t\torder = 4;\n\n\t/* Estimate the expected number of bits per residual signal sample. */\n\t/* 'total_error*' is linearly related to the variance of the residual */\n\t/* signal, so we use it directly to compute E(|x|) */\n\tFLAC__ASSERT(data_len > 0 || total_error_0 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_1 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_2 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_3 == 0);\n\tFLAC__ASSERT(data_len > 0 || total_error_4 == 0);\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tresidual_bits_per_sample[0] = (float)((total_error_0 > 0) ? log(M_LN2 * (double)total_error_0 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[1] = (float)((total_error_1 > 0) ? log(M_LN2 * (double)total_error_1 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[2] = (float)((total_error_2 > 0) ? log(M_LN2 * (double)total_error_2 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[3] = (float)((total_error_3 > 0) ? log(M_LN2 * (double)total_error_3 / (double)data_len) / M_LN2 : 0.0);\n\tresidual_bits_per_sample[4] = (float)((total_error_4 > 0) ? log(M_LN2 * (double)total_error_4 / (double)data_len) / M_LN2 : 0.0);\n#else\n\tresidual_bits_per_sample[0] = (total_error_0 > 0) ? local__compute_rbps_wide_integerized(total_error_0, data_len) : 0;\n\tresidual_bits_per_sample[1] = (total_error_1 > 0) ? local__compute_rbps_wide_integerized(total_error_1, data_len) : 0;\n\tresidual_bits_per_sample[2] = (total_error_2 > 0) ? local__compute_rbps_wide_integerized(total_error_2, data_len) : 0;\n\tresidual_bits_per_sample[3] = (total_error_3 > 0) ? local__compute_rbps_wide_integerized(total_error_3, data_len) : 0;\n\tresidual_bits_per_sample[4] = (total_error_4 > 0) ? local__compute_rbps_wide_integerized(total_error_4, data_len) : 0;\n#endif\n\n\treturn order;\n}\n\nvoid FLAC__fixed_compute_residual(const FLAC__int32 data[], unsigned data_len, unsigned order, FLAC__int32 residual[])\n{\n\tconst int idata_len = (int)data_len;\n\tint i;\n\n\tswitch(order) {\n\t\tcase 0:\n\t\t\tFLAC__ASSERT(sizeof(residual[0]) == sizeof(data[0]));\n\t\t\tmemcpy(residual, data, sizeof(residual[0])*data_len);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tresidual[i] = data[i] - data[i-1];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tresidual[i] = data[i] - 2*data[i-1] + data[i-2];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tresidual[i] = data[i] - 3*data[i-1] + 3*data[i-2] - data[i-3];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tresidual[i] = data[i] - 4*data[i-1] + 6*data[i-2] - 4*data[i-3] + data[i-4];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n}\n\nvoid FLAC__fixed_restore_signal(const FLAC__int32 residual[], unsigned data_len, unsigned order, FLAC__int32 data[])\n{\n\tint i, idata_len = (int)data_len;\n\n\tswitch(order) {\n\t\tcase 0:\n\t\t\tFLAC__ASSERT(sizeof(residual[0]) == sizeof(data[0]));\n\t\t\tmemcpy(data, residual, sizeof(residual[0])*data_len);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tdata[i] = residual[i] + data[i-1];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tdata[i] = residual[i] + 2*data[i-1] - data[i-2];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tdata[i] = residual[i] + 3*data[i-1] - 3*data[i-2] + data[i-3];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfor(i = 0; i < idata_len; i++)\n\t\t\t\tdata[i] = residual[i] + 4*data[i-1] - 6*data[i-2] + 4*data[i-3] - data[i-4];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h> /* for qsort() */\n#include <string.h> /* for memset() */\n#include \"FLAC/assert.h\"\n#include \"FLAC/format.h\"\n#include \"share/alloc.h\"\n#include \"share/compat.h\"\n#include \"private/format.h\"\n#include \"private/macros.h\"\n\n#define PACKAGE_VERSION \"1.3.2\"\n\n/* PACKAGE_VERSION should come from configure */\nFLAC_API const char *FLAC__VERSION_STRING = PACKAGE_VERSION;\n\nFLAC_API const char *FLAC__VENDOR_STRING = \"reference libFLAC \" PACKAGE_VERSION \" 20170101\";\n\nFLAC_API const FLAC__byte FLAC__STREAM_SYNC_STRING[4] = { 'f','L','a','C' };\nFLAC_API const unsigned FLAC__STREAM_SYNC = 0x664C6143;\nFLAC_API const unsigned FLAC__STREAM_SYNC_LEN = 32; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_APPLICATION_ID_LEN = 32; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN = 64; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN = 64; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN = 16; /* bits */\n\nFLAC_API const FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER = FLAC__U64L(0xffffffffffffffff);\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN = 32; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN = 64; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN = 8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN = 3*8; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN = 64; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN = 8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN = 12*8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN = 1; /* bit */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN = 1; /* bit */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN = 6+13*8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN = 8; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN = 128*8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN = 64; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN = 1; /* bit */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN = 7+258*8; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN = 8; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_TYPE_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_COLORS_LEN = 32; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN = 32; /* bits */\n\nFLAC_API const unsigned FLAC__STREAM_METADATA_IS_LAST_LEN = 1; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_TYPE_LEN = 7; /* bits */\nFLAC_API const unsigned FLAC__STREAM_METADATA_LENGTH_LEN = 24; /* bits */\n\nFLAC_API const unsigned FLAC__FRAME_HEADER_SYNC = 0x3ffe;\nFLAC_API const unsigned FLAC__FRAME_HEADER_SYNC_LEN = 14; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_RESERVED_LEN = 1; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN = 1; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_BLOCK_SIZE_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_SAMPLE_RATE_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN = 3; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_ZERO_PAD_LEN = 1; /* bits */\nFLAC_API const unsigned FLAC__FRAME_HEADER_CRC_LEN = 8; /* bits */\n\nFLAC_API const unsigned FLAC__FRAME_FOOTER_CRC_LEN = 16; /* bits */\n\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_TYPE_LEN = 2; /* bits */\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN = 5; /* bits */\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN = 5; /* bits */\n\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER = 15; /* == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN)-1 */\nFLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER = 31; /* == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN)-1 */\n\nFLAC_API const char * const FLAC__EntropyCodingMethodTypeString[] = {\n\t\"PARTITIONED_RICE\",\n\t\"PARTITIONED_RICE2\"\n};\n\nFLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN = 4; /* bits */\nFLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN = 5; /* bits */\n\nFLAC_API const unsigned FLAC__SUBFRAME_ZERO_PAD_LEN = 1; /* bits */\nFLAC_API const unsigned FLAC__SUBFRAME_TYPE_LEN = 6; /* bits */\nFLAC_API const unsigned FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN = 1; /* bits */\n\nFLAC_API const unsigned FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK = 0x00;\nFLAC_API const unsigned FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK = 0x02;\nFLAC_API const unsigned FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK = 0x10;\nFLAC_API const unsigned FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK = 0x40;\n\nFLAC_API const char * const FLAC__SubframeTypeString[] = {\n\t\"CONSTANT\",\n\t\"VERBATIM\",\n\t\"FIXED\",\n\t\"LPC\"\n};\n\nFLAC_API const char * const FLAC__ChannelAssignmentString[] = {\n\t\"INDEPENDENT\",\n\t\"LEFT_SIDE\",\n\t\"RIGHT_SIDE\",\n\t\"MID_SIDE\"\n};\n\nFLAC_API const char * const FLAC__FrameNumberTypeString[] = {\n\t\"FRAME_NUMBER_TYPE_FRAME_NUMBER\",\n\t\"FRAME_NUMBER_TYPE_SAMPLE_NUMBER\"\n};\n\nFLAC_API const char * const FLAC__MetadataTypeString[] = {\n\t\"STREAMINFO\",\n\t\"PADDING\",\n\t\"APPLICATION\",\n\t\"SEEKTABLE\",\n\t\"VORBIS_COMMENT\",\n\t\"CUESHEET\",\n\t\"PICTURE\"\n};\n\nFLAC_API const char * const FLAC__StreamMetadata_Picture_TypeString[] = {\n\t\"Other\",\n\t\"32x32 pixels 'file icon' (PNG only)\",\n\t\"Other file icon\",\n\t\"Cover (front)\",\n\t\"Cover (back)\",\n\t\"Leaflet page\",\n\t\"Media (e.g. label side of CD)\",\n\t\"Lead artist/lead performer/soloist\",\n\t\"Artist/performer\",\n\t\"Conductor\",\n\t\"Band/Orchestra\",\n\t\"Composer\",\n\t\"Lyricist/text writer\",\n\t\"Recording Location\",\n\t\"During recording\",\n\t\"During performance\",\n\t\"Movie/video screen capture\",\n\t\"A bright coloured fish\",\n\t\"Illustration\",\n\t\"Band/artist logotype\",\n\t\"Publisher/Studio logotype\"\n};\n\nFLAC_API FLAC__bool FLAC__format_sample_rate_is_valid(unsigned sample_rate)\n{\n\tif(sample_rate == 0 || sample_rate > FLAC__MAX_SAMPLE_RATE) {\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__format_blocksize_is_subset(unsigned blocksize, unsigned sample_rate)\n{\n\tif(blocksize > 16384)\n\t\treturn false;\n\telse if(sample_rate <= 48000 && blocksize > 4608)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__format_sample_rate_is_subset(unsigned sample_rate)\n{\n\tif(\n\t\t!FLAC__format_sample_rate_is_valid(sample_rate) ||\n\t\t(\n\t\t\tsample_rate >= (1u << 16) &&\n\t\t\t!(sample_rate % 1000 == 0 || sample_rate % 10 == 0)\n\t\t)\n\t) {\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\n/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\nFLAC_API FLAC__bool FLAC__format_seektable_is_legal(const FLAC__StreamMetadata_SeekTable *seek_table)\n{\n\tunsigned i;\n\tFLAC__uint64 prev_sample_number = 0;\n\tFLAC__bool got_prev = false;\n\n\tFLAC__ASSERT(0 != seek_table);\n\n\tfor(i = 0; i < seek_table->num_points; i++) {\n\t\tif(got_prev) {\n\t\t\tif(\n\t\t\t\tseek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&\n\t\t\t\tseek_table->points[i].sample_number <= prev_sample_number\n\t\t\t)\n\t\t\t\treturn false;\n\t\t}\n\t\tprev_sample_number = seek_table->points[i].sample_number;\n\t\tgot_prev = true;\n\t}\n\n\treturn true;\n}\n\n/* used as the sort predicate for qsort() */\nstatic int seekpoint_compare_(const FLAC__StreamMetadata_SeekPoint *l, const FLAC__StreamMetadata_SeekPoint *r)\n{\n\t/* we don't just 'return l->sample_number - r->sample_number' since the result (FLAC__int64) might overflow an 'int' */\n\tif(l->sample_number == r->sample_number)\n\t\treturn 0;\n\telse if(l->sample_number < r->sample_number)\n\t\treturn -1;\n\telse\n\t\treturn 1;\n}\n\n/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\nFLAC_API unsigned FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table)\n{\n\tunsigned i, j;\n\tFLAC__bool first;\n\n\tFLAC__ASSERT(0 != seek_table);\n\n\tif (seek_table->num_points == 0)\n\t\treturn 0;\n\n\t/* sort the seekpoints */\n\tqsort(seek_table->points, seek_table->num_points, sizeof(FLAC__StreamMetadata_SeekPoint), (int (*)(const void *, const void *))seekpoint_compare_);\n\n\t/* uniquify the seekpoints */\n\tfirst = true;\n\tfor(i = j = 0; i < seek_table->num_points; i++) {\n\t\tif(seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER) {\n\t\t\tif(!first) {\n\t\t\t\tif(seek_table->points[i].sample_number == seek_table->points[j-1].sample_number)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfirst = false;\n\t\tseek_table->points[j++] = seek_table->points[i];\n\t}\n\n\tfor(i = j; i < seek_table->num_points; i++) {\n\t\tseek_table->points[i].sample_number = FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER;\n\t\tseek_table->points[i].stream_offset = 0;\n\t\tseek_table->points[i].frame_samples = 0;\n\t}\n\n\treturn j;\n}\n\n/*\n * also disallows non-shortest-form encodings, c.f.\n *   http://www.unicode.org/versions/corrigendum1.html\n * and a more clear explanation at the end of this section:\n *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8\n */\nstatic unsigned utf8len_(const FLAC__byte *utf8)\n{\n\tFLAC__ASSERT(0 != utf8);\n\tif ((utf8[0] & 0x80) == 0) {\n\t\treturn 1;\n\t}\n\telse if ((utf8[0] & 0xE0) == 0xC0 && (utf8[1] & 0xC0) == 0x80) {\n\t\tif ((utf8[0] & 0xFE) == 0xC0) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 2;\n\t}\n\telse if ((utf8[0] & 0xF0) == 0xE0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xE0 && (utf8[1] & 0xE0) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\t/* illegal surrogates check (U+D800...U+DFFF and U+FFFE...U+FFFF) */\n\t\tif (utf8[0] == 0xED && (utf8[1] & 0xE0) == 0xA0) /* D800-DFFF */\n\t\t\treturn 0;\n\t\tif (utf8[0] == 0xEF && utf8[1] == 0xBF && (utf8[2] & 0xFE) == 0xBE) /* FFFE-FFFF */\n\t\t\treturn 0;\n\t\treturn 3;\n\t}\n\telse if ((utf8[0] & 0xF8) == 0xF0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xF0 && (utf8[1] & 0xF0) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 4;\n\t}\n\telse if ((utf8[0] & 0xFC) == 0xF8 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xF8 && (utf8[1] & 0xF8) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 5;\n\t}\n\telse if ((utf8[0] & 0xFE) == 0xFC && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80 && (utf8[5] & 0xC0) == 0x80) {\n\t\tif (utf8[0] == 0xFC && (utf8[1] & 0xFC) == 0x80) /* overlong sequence check */\n\t\t\treturn 0;\n\t\treturn 6;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n\nFLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(const char *name)\n{\n\tchar c;\n\tfor(c = *name; c; c = *(++name))\n\t\tif(c < 0x20 || c == 0x3d || c > 0x7d)\n\t\t\treturn false;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(const FLAC__byte *value, unsigned length)\n{\n\tif(length == (unsigned)(-1)) {\n\t\twhile(*value) {\n\t\t\tunsigned n = utf8len_(value);\n\t\t\tif(n == 0)\n\t\t\t\treturn false;\n\t\t\tvalue += n;\n\t\t}\n\t}\n\telse {\n\t\tconst FLAC__byte *end = value + length;\n\t\twhile(value < end) {\n\t\t\tunsigned n = utf8len_(value);\n\t\t\tif(n == 0)\n\t\t\t\treturn false;\n\t\t\tvalue += n;\n\t\t}\n\t\tif(value != end)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(const FLAC__byte *entry, unsigned length)\n{\n\tconst FLAC__byte *s, *end;\n\n\tfor(s = entry, end = s + length; s < end && *s != '='; s++) {\n\t\tif(*s < 0x20 || *s > 0x7D)\n\t\t\treturn false;\n\t}\n\tif(s == end)\n\t\treturn false;\n\n\ts++; /* skip '=' */\n\n\twhile(s < end) {\n\t\tunsigned n = utf8len_(s);\n\t\tif(n == 0)\n\t\t\treturn false;\n\t\ts += n;\n\t}\n\tif(s != end)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\nFLAC_API FLAC__bool FLAC__format_cuesheet_is_legal(const FLAC__StreamMetadata_CueSheet *cue_sheet, FLAC__bool check_cd_da_subset, const char **violation)\n{\n\tunsigned i, j;\n\n\tif(check_cd_da_subset) {\n\t\tif(cue_sheet->lead_in < 2 * 44100) {\n\t\t\tif(violation) *violation = \"CD-DA cue sheet must have a lead-in length of at least 2 seconds\";\n\t\t\treturn false;\n\t\t}\n\t\tif(cue_sheet->lead_in % 588 != 0) {\n\t\t\tif(violation) *violation = \"CD-DA cue sheet lead-in length must be evenly divisible by 588 samples\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif(cue_sheet->num_tracks == 0) {\n\t\tif(violation) *violation = \"cue sheet must have at least one track (the lead-out)\";\n\t\treturn false;\n\t}\n\n\tif(check_cd_da_subset && cue_sheet->tracks[cue_sheet->num_tracks-1].number != 170) {\n\t\tif(violation) *violation = \"CD-DA cue sheet must have a lead-out track number 170 (0xAA)\";\n\t\treturn false;\n\t}\n\n\tfor(i = 0; i < cue_sheet->num_tracks; i++) {\n\t\tif(cue_sheet->tracks[i].number == 0) {\n\t\t\tif(violation) *violation = \"cue sheet may not have a track number 0\";\n\t\t\treturn false;\n\t\t}\n\n\t\tif(check_cd_da_subset) {\n\t\t\tif(!((cue_sheet->tracks[i].number >= 1 && cue_sheet->tracks[i].number <= 99) || cue_sheet->tracks[i].number == 170)) {\n\t\t\t\tif(violation) *violation = \"CD-DA cue sheet track number must be 1-99 or 170\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif(check_cd_da_subset && cue_sheet->tracks[i].offset % 588 != 0) {\n\t\t\tif(violation) {\n\t\t\t\tif(i == cue_sheet->num_tracks-1) /* the lead-out track... */\n\t\t\t\t\t*violation = \"CD-DA cue sheet lead-out offset must be evenly divisible by 588 samples\";\n\t\t\t\telse\n\t\t\t\t\t*violation = \"CD-DA cue sheet track offset must be evenly divisible by 588 samples\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif(i < cue_sheet->num_tracks - 1) {\n\t\t\tif(cue_sheet->tracks[i].num_indices == 0) {\n\t\t\t\tif(violation) *violation = \"cue sheet track must have at least one index point\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(cue_sheet->tracks[i].indices[0].number > 1) {\n\t\t\t\tif(violation) *violation = \"cue sheet track's first index number must be 0 or 1\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor(j = 0; j < cue_sheet->tracks[i].num_indices; j++) {\n\t\t\tif(check_cd_da_subset && cue_sheet->tracks[i].indices[j].offset % 588 != 0) {\n\t\t\t\tif(violation) *violation = \"CD-DA cue sheet track index offset must be evenly divisible by 588 samples\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(j > 0) {\n\t\t\t\tif(cue_sheet->tracks[i].indices[j].number != cue_sheet->tracks[i].indices[j-1].number + 1) {\n\t\t\t\t\tif(violation) *violation = \"cue sheet track index numbers must increase by 1\";\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */\nFLAC_API FLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation)\n{\n\tchar *p;\n\tFLAC__byte *b;\n\n\tfor(p = picture->mime_type; *p; p++) {\n\t\tif(*p < 0x20 || *p > 0x7e) {\n\t\t\tif(violation) *violation = \"MIME type string must contain only printable ASCII characters (0x20-0x7e)\";\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor(b = picture->description; *b; ) {\n\t\tunsigned n = utf8len_(b);\n\t\tif(n == 0) {\n\t\t\tif(violation) *violation = \"description string must be valid UTF-8\";\n\t\t\treturn false;\n\t\t}\n\t\tb += n;\n\t}\n\n\treturn true;\n}\n\n/*\n * These routines are private to libFLAC\n */\nunsigned FLAC__format_get_max_rice_partition_order(unsigned blocksize, unsigned predictor_order)\n{\n\treturn\n\t\tFLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(\n\t\t\tFLAC__format_get_max_rice_partition_order_from_blocksize(blocksize),\n\t\t\tblocksize,\n\t\t\tpredictor_order\n\t\t);\n}\n\nunsigned FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned blocksize)\n{\n\tunsigned max_rice_partition_order = 0;\n\twhile(!(blocksize & 1)) {\n\t\tmax_rice_partition_order++;\n\t\tblocksize >>= 1;\n\t}\n\treturn flac_min(FLAC__MAX_RICE_PARTITION_ORDER, max_rice_partition_order);\n}\n\nunsigned FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(unsigned limit, unsigned blocksize, unsigned predictor_order)\n{\n\tunsigned max_rice_partition_order = limit;\n\n\twhile(max_rice_partition_order > 0 && (blocksize >> max_rice_partition_order) <= predictor_order)\n\t\tmax_rice_partition_order--;\n\n\tFLAC__ASSERT(\n\t\t(max_rice_partition_order == 0 && blocksize >= predictor_order) ||\n\t\t(max_rice_partition_order > 0 && blocksize >> max_rice_partition_order > predictor_order)\n\t);\n\n\treturn max_rice_partition_order;\n}\n\nvoid FLAC__format_entropy_coding_method_partitioned_rice_contents_init(FLAC__EntropyCodingMethod_PartitionedRiceContents *object)\n{\n\tFLAC__ASSERT(0 != object);\n\n\tobject->parameters = 0;\n\tobject->raw_bits = 0;\n\tobject->capacity_by_order = 0;\n}\n\nvoid FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(FLAC__EntropyCodingMethod_PartitionedRiceContents *object)\n{\n\tFLAC__ASSERT(0 != object);\n\n\tif(0 != object->parameters)\n\t\tfree(object->parameters);\n\tif(0 != object->raw_bits)\n\t\tfree(object->raw_bits);\n\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(object);\n}\n\nFLAC__bool FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(FLAC__EntropyCodingMethod_PartitionedRiceContents *object, unsigned max_partition_order)\n{\n\tFLAC__ASSERT(0 != object);\n\n\tFLAC__ASSERT(object->capacity_by_order > 0 || (0 == object->parameters && 0 == object->raw_bits));\n\n\tif(object->capacity_by_order < max_partition_order) {\n\t\tif(0 == (object->parameters = safe_realloc_(object->parameters, sizeof(unsigned)*(1 << max_partition_order))))\n\t\t\treturn false;\n\t\tif(0 == (object->raw_bits = safe_realloc_(object->raw_bits, sizeof(unsigned)*(1 << max_partition_order))))\n\t\t\treturn false;\n\t\tmemset(object->raw_bits, 0, sizeof(unsigned)*(1 << max_partition_order));\n\t\tobject->capacity_by_order = max_partition_order;\n\t}\n\n\treturn true;\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <math.h>\n\n#include \"FLAC/assert.h\"\n#include \"FLAC/format.h\"\n#include \"share/compat.h\"\n#include \"private/bitmath.h\"\n#include \"private/lpc.h\"\n#include \"private/macros.h\"\n#if defined DEBUG || defined FLAC__OVERFLOW_DETECT || defined FLAC__OVERFLOW_DETECT_VERBOSE\n#include <stdio.h>\n#endif\n\n/* OPT: #undef'ing this may improve the speed on some architectures */\n#define FLAC__LPC_UNROLLED_FILTER_LOOPS\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\n#if defined(_MSC_VER) && (_MSC_VER < 1800)\n#include <float.h>\nstatic inline long int lround(double x) {\n\treturn (long)(x + _copysign(0.5, x));\n}\n#elif !defined(HAVE_LROUND) && defined(__GNUC__)\nstatic inline long int lround(double x) {\n\treturn (long)(x + __builtin_copysign(0.5, x));\n}\n/* If this fails, we are in the presence of a mid 90's compiler, move along... */\n#endif\n\nvoid FLAC__lpc_window_data(const FLAC__int32 in[], const FLAC__real window[], FLAC__real out[], unsigned data_len)\n{\n\tunsigned i;\n\tfor(i = 0; i < data_len; i++)\n\t\tout[i] = in[i] * window[i];\n}\n\nvoid FLAC__lpc_compute_autocorrelation(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[])\n{\n\t/* a readable, but slower, version */\n#if 0\n\tFLAC__real d;\n\tunsigned i;\n\n\tFLAC__ASSERT(lag > 0);\n\tFLAC__ASSERT(lag <= data_len);\n\n\t/*\n\t * Technically we should subtract the mean first like so:\n\t *   for(i = 0; i < data_len; i++)\n\t *     data[i] -= mean;\n\t * but it appears not to make enough of a difference to matter, and\n\t * most signals are already closely centered around zero\n\t */\n\twhile(lag--) {\n\t\tfor(i = lag, d = 0.0; i < data_len; i++)\n\t\t\td += data[i] * data[i - lag];\n\t\tautoc[lag] = d;\n\t}\n#endif\n\n\t/*\n\t * this version tends to run faster because of better data locality\n\t * ('data_len' is usually much larger than 'lag')\n\t */\n\tFLAC__real d;\n\tunsigned sample, coeff;\n\tconst unsigned limit = data_len - lag;\n\n\tFLAC__ASSERT(lag > 0);\n\tFLAC__ASSERT(lag <= data_len);\n\n\tfor(coeff = 0; coeff < lag; coeff++)\n\t\tautoc[coeff] = 0.0;\n\tfor(sample = 0; sample <= limit; sample++) {\n\t\td = data[sample];\n\t\tfor(coeff = 0; coeff < lag; coeff++)\n\t\t\tautoc[coeff] += d * data[sample+coeff];\n\t}\n\tfor(; sample < data_len; sample++) {\n\t\td = data[sample];\n\t\tfor(coeff = 0; coeff < data_len - sample; coeff++)\n\t\t\tautoc[coeff] += d * data[sample+coeff];\n\t}\n}\n\nvoid FLAC__lpc_compute_lp_coefficients(const FLAC__real autoc[], unsigned *max_order, FLAC__real lp_coeff[][FLAC__MAX_LPC_ORDER], double error[])\n{\n\tunsigned i, j;\n\tdouble r, err, lpc[FLAC__MAX_LPC_ORDER];\n\n\tFLAC__ASSERT(0 != max_order);\n\tFLAC__ASSERT(0 < *max_order);\n\tFLAC__ASSERT(*max_order <= FLAC__MAX_LPC_ORDER);\n\tFLAC__ASSERT(autoc[0] != 0.0);\n\n\terr = autoc[0];\n\n\tfor(i = 0; i < *max_order; i++) {\n\t\t/* Sum up this iteration's reflection coefficient. */\n\t\tr = -autoc[i+1];\n\t\tfor(j = 0; j < i; j++)\n\t\t\tr -= lpc[j] * autoc[i-j];\n\t\tr /= err;\n\n\t\t/* Update LPC coefficients and total error. */\n\t\tlpc[i]=r;\n\t\tfor(j = 0; j < (i>>1); j++) {\n\t\t\tdouble tmp = lpc[j];\n\t\t\tlpc[j] += r * lpc[i-1-j];\n\t\t\tlpc[i-1-j] += r * tmp;\n\t\t}\n\t\tif(i & 1)\n\t\t\tlpc[j] += lpc[j] * r;\n\n\t\terr *= (1.0 - r * r);\n\n\t\t/* save this order */\n\t\tfor(j = 0; j <= i; j++)\n\t\t\tlp_coeff[i][j] = (FLAC__real)(-lpc[j]); /* negate FIR filter coeff to get predictor coeff */\n\t\terror[i] = err;\n\n\t\t/* see SF bug https://sourceforge.net/p/flac/bugs/234/ */\n\t\tif(err == 0.0) {\n\t\t\t*max_order = i+1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint FLAC__lpc_quantize_coefficients(const FLAC__real lp_coeff[], unsigned order, unsigned precision, FLAC__int32 qlp_coeff[], int *shift)\n{\n\tunsigned i;\n\tdouble cmax;\n\tFLAC__int32 qmax, qmin;\n\n\tFLAC__ASSERT(precision > 0);\n\tFLAC__ASSERT(precision >= FLAC__MIN_QLP_COEFF_PRECISION);\n\n\t/* drop one bit for the sign; from here on out we consider only |lp_coeff[i]| */\n\tprecision--;\n\tqmax = 1 << precision;\n\tqmin = -qmax;\n\tqmax--;\n\n\t/* calc cmax = max( |lp_coeff[i]| ) */\n\tcmax = 0.0;\n\tfor(i = 0; i < order; i++) {\n\t\tconst double d = fabs(lp_coeff[i]);\n\t\tif(d > cmax)\n\t\t\tcmax = d;\n\t}\n\n\tif(cmax <= 0.0) {\n\t\t/* => coefficients are all 0, which means our constant-detect didn't work */\n\t\treturn 2;\n\t}\n\telse {\n\t\tconst int max_shiftlimit = (1 << (FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN-1)) - 1;\n\t\tconst int min_shiftlimit = -max_shiftlimit - 1;\n\t\tint log2cmax;\n\n\t\t(void)frexp(cmax, &log2cmax);\n\t\tlog2cmax--;\n\t\t*shift = (int)precision - log2cmax - 1;\n\n\t\tif(*shift > max_shiftlimit)\n\t\t\t*shift = max_shiftlimit;\n\t\telse if(*shift < min_shiftlimit)\n\t\t\treturn 1;\n\t}\n\n\tif(*shift >= 0) {\n\t\tdouble error = 0.0;\n\t\tFLAC__int32 q;\n\t\tfor(i = 0; i < order; i++) {\n\t\t\terror += lp_coeff[i] * (1 << *shift);\n\t\t\tq = lround(error);\n\n#ifdef FLAC__OVERFLOW_DETECT\n\t\t\tif(q > qmax+1) /* we expect q==qmax+1 occasionally due to rounding */\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_quantize_coefficients: quantizer overflow: q>qmax %d>%d shift=%d cmax=%f precision=%u lpc[%u]=%f\\n\",q,qmax,*shift,cmax,precision+1,i,lp_coeff[i]);\n\t\t\telse if(q < qmin)\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_quantize_coefficients: quantizer overflow: q<qmin %d<%d shift=%d cmax=%f precision=%u lpc[%u]=%f\\n\",q,qmin,*shift,cmax,precision+1,i,lp_coeff[i]);\n#endif\n\t\t\tif(q > qmax)\n\t\t\t\tq = qmax;\n\t\t\telse if(q < qmin)\n\t\t\t\tq = qmin;\n\t\t\terror -= q;\n\t\t\tqlp_coeff[i] = q;\n\t\t}\n\t}\n\t/* negative shift is very rare but due to design flaw, negative shift is\n\t * not allowed in the decoder, so it must be handled specially by scaling\n\t * down coeffs\n\t */\n\telse {\n\t\tconst int nshift = -(*shift);\n\t\tdouble error = 0.0;\n\t\tFLAC__int32 q;\n#ifdef DEBUG\n\t\tfprintf(stderr,\"FLAC__lpc_quantize_coefficients: negative shift=%d order=%u cmax=%f\\n\", *shift, order, cmax);\n#endif\n\t\tfor(i = 0; i < order; i++) {\n\t\t\terror += lp_coeff[i] / (1 << nshift);\n\t\t\tq = lround(error);\n#ifdef FLAC__OVERFLOW_DETECT\n\t\t\tif(q > qmax+1) /* we expect q==qmax+1 occasionally due to rounding */\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_quantize_coefficients: quantizer overflow: q>qmax %d>%d shift=%d cmax=%f precision=%u lpc[%u]=%f\\n\",q,qmax,*shift,cmax,precision+1,i,lp_coeff[i]);\n\t\t\telse if(q < qmin)\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_quantize_coefficients: quantizer overflow: q<qmin %d<%d shift=%d cmax=%f precision=%u lpc[%u]=%f\\n\",q,qmin,*shift,cmax,precision+1,i,lp_coeff[i]);\n#endif\n\t\t\tif(q > qmax)\n\t\t\t\tq = qmax;\n\t\t\telse if(q < qmin)\n\t\t\t\tq = qmin;\n\t\t\terror -= q;\n\t\t\tqlp_coeff[i] = q;\n\t\t}\n\t\t*shift = 0;\n\t}\n\n\treturn 0;\n}\n\n#if defined(_MSC_VER)\n// silence MSVC warnings about __restrict modifier\n#pragma warning ( disable : 4028 )\n#endif\n\nvoid FLAC__lpc_compute_residual_from_qlp_coefficients(const FLAC__int32 * flac_restrict data, unsigned data_len, const FLAC__int32 * flac_restrict qlp_coeff, unsigned order, int lp_quantization, FLAC__int32 * flac_restrict residual)\n#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)\n{\n\tFLAC__int64 sumo;\n\tunsigned i, j;\n\tFLAC__int32 sum;\n\tconst FLAC__int32 *history;\n\n#ifdef FLAC__OVERFLOW_DETECT_VERBOSE\n\tfprintf(stderr,\"FLAC__lpc_compute_residual_from_qlp_coefficients: data_len=%d, order=%u, lpq=%d\",data_len,order,lp_quantization);\n\tfor(i=0;i<order;i++)\n\t\tfprintf(stderr,\", q[%u]=%d\",i,qlp_coeff[i]);\n\tfprintf(stderr,\"\\n\");\n#endif\n\tFLAC__ASSERT(order > 0);\n\n\tfor(i = 0; i < data_len; i++) {\n\t\tsumo = 0;\n\t\tsum = 0;\n\t\thistory = data;\n\t\tfor(j = 0; j < order; j++) {\n\t\t\tsum += qlp_coeff[j] * (*(--history));\n\t\t\tsumo += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*history);\n\t\t\tif(sumo > 2147483647ll || sumo < -2147483648ll)\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_compute_residual_from_qlp_coefficients: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%\" PRId64 \"\\n\",i,j,qlp_coeff[j],*history,sumo);\n\t\t}\n\t\t*(residual++) = *(data++) - (sum >> lp_quantization);\n\t}\n\n\t/* Here's a slower but clearer version:\n\tfor(i = 0; i < data_len; i++) {\n\t\tsum = 0;\n\t\tfor(j = 0; j < order; j++)\n\t\t\tsum += qlp_coeff[j] * data[i-j-1];\n\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t}\n\t*/\n}\n#else /* fully unrolled version for normal use */\n{\n\tint i;\n\tFLAC__int32 sum;\n\n\tFLAC__ASSERT(order > 0);\n\tFLAC__ASSERT(order <= 32);\n\n\t/*\n\t * We do unique versions up to 12th order since that's the subset limit.\n\t * Also they are roughly ordered to match frequency of occurrence to\n\t * minimize branching.\n\t */\n\tif(order <= 12) {\n\t\tif(order > 8) {\n\t\t\tif(order > 10) {\n\t\t\t\tif(order == 12) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[11] * data[i-12];\n\t\t\t\t\t\tsum += qlp_coeff[10] * data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 11 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[10] * data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 10) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 9 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(order > 4) {\n\t\t\tif(order > 6) {\n\t\t\t\tif(order == 8) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 7 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 6) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 5 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(order > 2) {\n\t\t\t\tif(order == 4) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 3 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 2) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 1 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++)\n\t\t\t\t\t\tresidual[i] = data[i] - ((qlp_coeff[0] * data[i-1]) >> lp_quantization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse { /* order > 12 */\n\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\tsum = 0;\n\t\t\tswitch(order) {\n\t\t\t\tcase 32: sum += qlp_coeff[31] * data[i-32];\n\t\t\t\tcase 31: sum += qlp_coeff[30] * data[i-31];\n\t\t\t\tcase 30: sum += qlp_coeff[29] * data[i-30];\n\t\t\t\tcase 29: sum += qlp_coeff[28] * data[i-29];\n\t\t\t\tcase 28: sum += qlp_coeff[27] * data[i-28];\n\t\t\t\tcase 27: sum += qlp_coeff[26] * data[i-27];\n\t\t\t\tcase 26: sum += qlp_coeff[25] * data[i-26];\n\t\t\t\tcase 25: sum += qlp_coeff[24] * data[i-25];\n\t\t\t\tcase 24: sum += qlp_coeff[23] * data[i-24];\n\t\t\t\tcase 23: sum += qlp_coeff[22] * data[i-23];\n\t\t\t\tcase 22: sum += qlp_coeff[21] * data[i-22];\n\t\t\t\tcase 21: sum += qlp_coeff[20] * data[i-21];\n\t\t\t\tcase 20: sum += qlp_coeff[19] * data[i-20];\n\t\t\t\tcase 19: sum += qlp_coeff[18] * data[i-19];\n\t\t\t\tcase 18: sum += qlp_coeff[17] * data[i-18];\n\t\t\t\tcase 17: sum += qlp_coeff[16] * data[i-17];\n\t\t\t\tcase 16: sum += qlp_coeff[15] * data[i-16];\n\t\t\t\tcase 15: sum += qlp_coeff[14] * data[i-15];\n\t\t\t\tcase 14: sum += qlp_coeff[13] * data[i-14];\n\t\t\t\tcase 13: sum += qlp_coeff[12] * data[i-13];\n\t\t\t\t         sum += qlp_coeff[11] * data[i-12];\n\t\t\t\t         sum += qlp_coeff[10] * data[i-11];\n\t\t\t\t         sum += qlp_coeff[ 9] * data[i-10];\n\t\t\t\t         sum += qlp_coeff[ 8] * data[i- 9];\n\t\t\t\t         sum += qlp_coeff[ 7] * data[i- 8];\n\t\t\t\t         sum += qlp_coeff[ 6] * data[i- 7];\n\t\t\t\t         sum += qlp_coeff[ 5] * data[i- 6];\n\t\t\t\t         sum += qlp_coeff[ 4] * data[i- 5];\n\t\t\t\t         sum += qlp_coeff[ 3] * data[i- 4];\n\t\t\t\t         sum += qlp_coeff[ 2] * data[i- 3];\n\t\t\t\t         sum += qlp_coeff[ 1] * data[i- 2];\n\t\t\t\t         sum += qlp_coeff[ 0] * data[i- 1];\n\t\t\t}\n\t\t\tresidual[i] = data[i] - (sum >> lp_quantization);\n\t\t}\n\t}\n}\n#endif\n\nvoid FLAC__lpc_compute_residual_from_qlp_coefficients_wide(const FLAC__int32 * flac_restrict data, unsigned data_len, const FLAC__int32 * flac_restrict qlp_coeff, unsigned order, int lp_quantization, FLAC__int32 * flac_restrict residual)\n#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)\n{\n\tunsigned i, j;\n\tFLAC__int64 sum;\n\tconst FLAC__int32 *history;\n\n#ifdef FLAC__OVERFLOW_DETECT_VERBOSE\n\tfprintf(stderr,\"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: data_len=%d, order=%u, lpq=%d\",data_len,order,lp_quantization);\n\tfor(i=0;i<order;i++)\n\t\tfprintf(stderr,\", q[%u]=%d\",i,qlp_coeff[i]);\n\tfprintf(stderr,\"\\n\");\n#endif\n\tFLAC__ASSERT(order > 0);\n\n\tfor(i = 0; i < data_len; i++) {\n\t\tsum = 0;\n\t\thistory = data;\n\t\tfor(j = 0; j < order; j++)\n\t\t\tsum += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*(--history));\n\t\tif(FLAC__bitmath_silog2(sum >> lp_quantization) > 32) {\n\t\t\tfprintf(stderr,\"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, sum=%\" PRId64 \"\\n\", i, (sum >> lp_quantization));\n\t\t\tbreak;\n\t\t}\n\t\tif(FLAC__bitmath_silog2((FLAC__int64)(*data) - (sum >> lp_quantization)) > 32) {\n\t\t\tfprintf(stderr,\"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, data=%d, sum=%\" PRId64 \", residual=%\" PRId64 \"\\n\", i, *data, (int64_t)(sum >> lp_quantization), ((FLAC__int64)(*data) - (sum >> lp_quantization)));\n\t\t\tbreak;\n\t\t}\n\t\t*(residual++) = *(data++) - (FLAC__int32)(sum >> lp_quantization);\n\t}\n}\n#else /* fully unrolled version for normal use */\n{\n\tint i;\n\tFLAC__int64 sum;\n\n\tFLAC__ASSERT(order > 0);\n\tFLAC__ASSERT(order <= 32);\n\n\t/*\n\t * We do unique versions up to 12th order since that's the subset limit.\n\t * Also they are roughly ordered to match frequency of occurrence to\n\t * minimize branching.\n\t */\n\tif(order <= 12) {\n\t\tif(order > 8) {\n\t\t\tif(order > 10) {\n\t\t\t\tif(order == 12) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[11] * (FLAC__int64)data[i-12];\n\t\t\t\t\t\tsum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 11 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 10) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 9 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(order > 4) {\n\t\t\tif(order > 6) {\n\t\t\t\tif(order == 8) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 7 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 6) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 5 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(order > 2) {\n\t\t\t\tif(order == 4) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 3 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 2) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 1 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++)\n\t\t\t\t\t\tresidual[i] = data[i] - (FLAC__int32)((qlp_coeff[0] * (FLAC__int64)data[i-1]) >> lp_quantization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse { /* order > 12 */\n\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\tsum = 0;\n\t\t\tswitch(order) {\n\t\t\t\tcase 32: sum += qlp_coeff[31] * (FLAC__int64)data[i-32];\n\t\t\t\tcase 31: sum += qlp_coeff[30] * (FLAC__int64)data[i-31];\n\t\t\t\tcase 30: sum += qlp_coeff[29] * (FLAC__int64)data[i-30];\n\t\t\t\tcase 29: sum += qlp_coeff[28] * (FLAC__int64)data[i-29];\n\t\t\t\tcase 28: sum += qlp_coeff[27] * (FLAC__int64)data[i-28];\n\t\t\t\tcase 27: sum += qlp_coeff[26] * (FLAC__int64)data[i-27];\n\t\t\t\tcase 26: sum += qlp_coeff[25] * (FLAC__int64)data[i-26];\n\t\t\t\tcase 25: sum += qlp_coeff[24] * (FLAC__int64)data[i-25];\n\t\t\t\tcase 24: sum += qlp_coeff[23] * (FLAC__int64)data[i-24];\n\t\t\t\tcase 23: sum += qlp_coeff[22] * (FLAC__int64)data[i-23];\n\t\t\t\tcase 22: sum += qlp_coeff[21] * (FLAC__int64)data[i-22];\n\t\t\t\tcase 21: sum += qlp_coeff[20] * (FLAC__int64)data[i-21];\n\t\t\t\tcase 20: sum += qlp_coeff[19] * (FLAC__int64)data[i-20];\n\t\t\t\tcase 19: sum += qlp_coeff[18] * (FLAC__int64)data[i-19];\n\t\t\t\tcase 18: sum += qlp_coeff[17] * (FLAC__int64)data[i-18];\n\t\t\t\tcase 17: sum += qlp_coeff[16] * (FLAC__int64)data[i-17];\n\t\t\t\tcase 16: sum += qlp_coeff[15] * (FLAC__int64)data[i-16];\n\t\t\t\tcase 15: sum += qlp_coeff[14] * (FLAC__int64)data[i-15];\n\t\t\t\tcase 14: sum += qlp_coeff[13] * (FLAC__int64)data[i-14];\n\t\t\t\tcase 13: sum += qlp_coeff[12] * (FLAC__int64)data[i-13];\n\t\t\t\t         sum += qlp_coeff[11] * (FLAC__int64)data[i-12];\n\t\t\t\t         sum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t         sum += qlp_coeff[ 9] * (FLAC__int64)data[i-10];\n\t\t\t\t         sum += qlp_coeff[ 8] * (FLAC__int64)data[i- 9];\n\t\t\t\t         sum += qlp_coeff[ 7] * (FLAC__int64)data[i- 8];\n\t\t\t\t         sum += qlp_coeff[ 6] * (FLAC__int64)data[i- 7];\n\t\t\t\t         sum += qlp_coeff[ 5] * (FLAC__int64)data[i- 6];\n\t\t\t\t         sum += qlp_coeff[ 4] * (FLAC__int64)data[i- 5];\n\t\t\t\t         sum += qlp_coeff[ 3] * (FLAC__int64)data[i- 4];\n\t\t\t\t         sum += qlp_coeff[ 2] * (FLAC__int64)data[i- 3];\n\t\t\t\t         sum += qlp_coeff[ 1] * (FLAC__int64)data[i- 2];\n\t\t\t\t         sum += qlp_coeff[ 0] * (FLAC__int64)data[i- 1];\n\t\t\t}\n\t\t\tresidual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);\n\t\t}\n\t}\n}\n#endif\n\n#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */\n\nvoid FLAC__lpc_restore_signal(const FLAC__int32 * flac_restrict residual, unsigned data_len, const FLAC__int32 * flac_restrict qlp_coeff, unsigned order, int lp_quantization, FLAC__int32 * flac_restrict data)\n#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)\n{\n\tFLAC__int64 sumo;\n\tunsigned i, j;\n\tFLAC__int32 sum;\n\tconst FLAC__int32 *r = residual, *history;\n\n#ifdef FLAC__OVERFLOW_DETECT_VERBOSE\n\tfprintf(stderr,\"FLAC__lpc_restore_signal: data_len=%d, order=%u, lpq=%d\",data_len,order,lp_quantization);\n\tfor(i=0;i<order;i++)\n\t\tfprintf(stderr,\", q[%u]=%d\",i,qlp_coeff[i]);\n\tfprintf(stderr,\"\\n\");\n#endif\n\tFLAC__ASSERT(order > 0);\n\n\tfor(i = 0; i < data_len; i++) {\n\t\tsumo = 0;\n\t\tsum = 0;\n\t\thistory = data;\n\t\tfor(j = 0; j < order; j++) {\n\t\t\tsum += qlp_coeff[j] * (*(--history));\n\t\t\tsumo += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*history);\n\t\t\tif(sumo > 2147483647ll || sumo < -2147483648ll)\n\t\t\t\tfprintf(stderr,\"FLAC__lpc_restore_signal: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%\" PRId64 \"\\n\",i,j,qlp_coeff[j],*history,sumo);\n\t\t}\n\t\t*(data++) = *(r++) + (sum >> lp_quantization);\n\t}\n\n\t/* Here's a slower but clearer version:\n\tfor(i = 0; i < data_len; i++) {\n\t\tsum = 0;\n\t\tfor(j = 0; j < order; j++)\n\t\t\tsum += qlp_coeff[j] * data[i-j-1];\n\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t}\n\t*/\n}\n#else /* fully unrolled version for normal use */\n{\n\tint i;\n\tFLAC__int32 sum;\n\n\tFLAC__ASSERT(order > 0);\n\tFLAC__ASSERT(order <= 32);\n\n\t/*\n\t * We do unique versions up to 12th order since that's the subset limit.\n\t * Also they are roughly ordered to match frequency of occurrence to\n\t * minimize branching.\n\t */\n\tif(order <= 12) {\n\t\tif(order > 8) {\n\t\t\tif(order > 10) {\n\t\t\t\tif(order == 12) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[11] * data[i-12];\n\t\t\t\t\t\tsum += qlp_coeff[10] * data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 11 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[10] * data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 10) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[9] * data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 9 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[8] * data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(order > 4) {\n\t\t\tif(order > 6) {\n\t\t\t\tif(order == 8) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[7] * data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 7 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[6] * data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 6) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[5] * data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 5 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[4] * data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(order > 2) {\n\t\t\t\tif(order == 4) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[3] * data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 3 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[2] * data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 2) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[1] * data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 1 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++)\n\t\t\t\t\t\tdata[i] = residual[i] + ((qlp_coeff[0] * data[i-1]) >> lp_quantization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse { /* order > 12 */\n\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\tsum = 0;\n\t\t\tswitch(order) {\n\t\t\t\tcase 32: sum += qlp_coeff[31] * data[i-32];\n\t\t\t\tcase 31: sum += qlp_coeff[30] * data[i-31];\n\t\t\t\tcase 30: sum += qlp_coeff[29] * data[i-30];\n\t\t\t\tcase 29: sum += qlp_coeff[28] * data[i-29];\n\t\t\t\tcase 28: sum += qlp_coeff[27] * data[i-28];\n\t\t\t\tcase 27: sum += qlp_coeff[26] * data[i-27];\n\t\t\t\tcase 26: sum += qlp_coeff[25] * data[i-26];\n\t\t\t\tcase 25: sum += qlp_coeff[24] * data[i-25];\n\t\t\t\tcase 24: sum += qlp_coeff[23] * data[i-24];\n\t\t\t\tcase 23: sum += qlp_coeff[22] * data[i-23];\n\t\t\t\tcase 22: sum += qlp_coeff[21] * data[i-22];\n\t\t\t\tcase 21: sum += qlp_coeff[20] * data[i-21];\n\t\t\t\tcase 20: sum += qlp_coeff[19] * data[i-20];\n\t\t\t\tcase 19: sum += qlp_coeff[18] * data[i-19];\n\t\t\t\tcase 18: sum += qlp_coeff[17] * data[i-18];\n\t\t\t\tcase 17: sum += qlp_coeff[16] * data[i-17];\n\t\t\t\tcase 16: sum += qlp_coeff[15] * data[i-16];\n\t\t\t\tcase 15: sum += qlp_coeff[14] * data[i-15];\n\t\t\t\tcase 14: sum += qlp_coeff[13] * data[i-14];\n\t\t\t\tcase 13: sum += qlp_coeff[12] * data[i-13];\n\t\t\t\t         sum += qlp_coeff[11] * data[i-12];\n\t\t\t\t         sum += qlp_coeff[10] * data[i-11];\n\t\t\t\t         sum += qlp_coeff[ 9] * data[i-10];\n\t\t\t\t         sum += qlp_coeff[ 8] * data[i- 9];\n\t\t\t\t         sum += qlp_coeff[ 7] * data[i- 8];\n\t\t\t\t         sum += qlp_coeff[ 6] * data[i- 7];\n\t\t\t\t         sum += qlp_coeff[ 5] * data[i- 6];\n\t\t\t\t         sum += qlp_coeff[ 4] * data[i- 5];\n\t\t\t\t         sum += qlp_coeff[ 3] * data[i- 4];\n\t\t\t\t         sum += qlp_coeff[ 2] * data[i- 3];\n\t\t\t\t         sum += qlp_coeff[ 1] * data[i- 2];\n\t\t\t\t         sum += qlp_coeff[ 0] * data[i- 1];\n\t\t\t}\n\t\t\tdata[i] = residual[i] + (sum >> lp_quantization);\n\t\t}\n\t}\n}\n#endif\n\nvoid FLAC__lpc_restore_signal_wide(const FLAC__int32 * flac_restrict residual, unsigned data_len, const FLAC__int32 * flac_restrict qlp_coeff, unsigned order, int lp_quantization, FLAC__int32 * flac_restrict data)\n#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)\n{\n\tunsigned i, j;\n\tFLAC__int64 sum;\n\tconst FLAC__int32 *r = residual, *history;\n\n#ifdef FLAC__OVERFLOW_DETECT_VERBOSE\n\tfprintf(stderr,\"FLAC__lpc_restore_signal_wide: data_len=%d, order=%u, lpq=%d\",data_len,order,lp_quantization);\n\tfor(i=0;i<order;i++)\n\t\tfprintf(stderr,\", q[%u]=%d\",i,qlp_coeff[i]);\n\tfprintf(stderr,\"\\n\");\n#endif\n\tFLAC__ASSERT(order > 0);\n\n\tfor(i = 0; i < data_len; i++) {\n\t\tsum = 0;\n\t\thistory = data;\n\t\tfor(j = 0; j < order; j++)\n\t\t\tsum += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*(--history));\n\t\tif(FLAC__bitmath_silog2(sum >> lp_quantization) > 32) {\n\t\t\tfprintf(stderr,\"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, sum=%\" PRId64 \"\\n\", i, (sum >> lp_quantization));\n\t\t\tbreak;\n\t\t}\n\t\tif(FLAC__bitmath_silog2((FLAC__int64)(*r) + (sum >> lp_quantization)) > 32) {\n\t\t\tfprintf(stderr,\"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, residual=%d, sum=%\" PRId64 \", data=%\" PRId64 \"\\n\", i, *r, (sum >> lp_quantization), ((FLAC__int64)(*r) + (sum >> lp_quantization)));\n\t\t\tbreak;\n\t\t}\n\t\t*(data++) = *(r++) + (FLAC__int32)(sum >> lp_quantization);\n\t}\n}\n#else /* fully unrolled version for normal use */\n{\n\tint i;\n\tFLAC__int64 sum;\n\n\tFLAC__ASSERT(order > 0);\n\tFLAC__ASSERT(order <= 32);\n\n\t/*\n\t * We do unique versions up to 12th order since that's the subset limit.\n\t * Also they are roughly ordered to match frequency of occurrence to\n\t * minimize branching.\n\t */\n\tif(order <= 12) {\n\t\tif(order > 8) {\n\t\t\tif(order > 10) {\n\t\t\t\tif(order == 12) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[11] * (FLAC__int64)data[i-12];\n\t\t\t\t\t\tsum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 11 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 10) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[9] * (FLAC__int64)data[i-10];\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 9 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[8] * (FLAC__int64)data[i-9];\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(order > 4) {\n\t\t\tif(order > 6) {\n\t\t\t\tif(order == 8) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[7] * (FLAC__int64)data[i-8];\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 7 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[6] * (FLAC__int64)data[i-7];\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 6) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[5] * (FLAC__int64)data[i-6];\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 5 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[4] * (FLAC__int64)data[i-5];\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(order > 2) {\n\t\t\t\tif(order == 4) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[3] * (FLAC__int64)data[i-4];\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 3 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[2] * (FLAC__int64)data[i-3];\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(order == 2) {\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t\tsum += qlp_coeff[1] * (FLAC__int64)data[i-2];\n\t\t\t\t\t\tsum += qlp_coeff[0] * (FLAC__int64)data[i-1];\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { /* order == 1 */\n\t\t\t\t\tfor(i = 0; i < (int)data_len; i++)\n\t\t\t\t\t\tdata[i] = residual[i] + (FLAC__int32)((qlp_coeff[0] * (FLAC__int64)data[i-1]) >> lp_quantization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse { /* order > 12 */\n\t\tfor(i = 0; i < (int)data_len; i++) {\n\t\t\tsum = 0;\n\t\t\tswitch(order) {\n\t\t\t\tcase 32: sum += qlp_coeff[31] * (FLAC__int64)data[i-32];\n\t\t\t\tcase 31: sum += qlp_coeff[30] * (FLAC__int64)data[i-31];\n\t\t\t\tcase 30: sum += qlp_coeff[29] * (FLAC__int64)data[i-30];\n\t\t\t\tcase 29: sum += qlp_coeff[28] * (FLAC__int64)data[i-29];\n\t\t\t\tcase 28: sum += qlp_coeff[27] * (FLAC__int64)data[i-28];\n\t\t\t\tcase 27: sum += qlp_coeff[26] * (FLAC__int64)data[i-27];\n\t\t\t\tcase 26: sum += qlp_coeff[25] * (FLAC__int64)data[i-26];\n\t\t\t\tcase 25: sum += qlp_coeff[24] * (FLAC__int64)data[i-25];\n\t\t\t\tcase 24: sum += qlp_coeff[23] * (FLAC__int64)data[i-24];\n\t\t\t\tcase 23: sum += qlp_coeff[22] * (FLAC__int64)data[i-23];\n\t\t\t\tcase 22: sum += qlp_coeff[21] * (FLAC__int64)data[i-22];\n\t\t\t\tcase 21: sum += qlp_coeff[20] * (FLAC__int64)data[i-21];\n\t\t\t\tcase 20: sum += qlp_coeff[19] * (FLAC__int64)data[i-20];\n\t\t\t\tcase 19: sum += qlp_coeff[18] * (FLAC__int64)data[i-19];\n\t\t\t\tcase 18: sum += qlp_coeff[17] * (FLAC__int64)data[i-18];\n\t\t\t\tcase 17: sum += qlp_coeff[16] * (FLAC__int64)data[i-17];\n\t\t\t\tcase 16: sum += qlp_coeff[15] * (FLAC__int64)data[i-16];\n\t\t\t\tcase 15: sum += qlp_coeff[14] * (FLAC__int64)data[i-15];\n\t\t\t\tcase 14: sum += qlp_coeff[13] * (FLAC__int64)data[i-14];\n\t\t\t\tcase 13: sum += qlp_coeff[12] * (FLAC__int64)data[i-13];\n\t\t\t\t         sum += qlp_coeff[11] * (FLAC__int64)data[i-12];\n\t\t\t\t         sum += qlp_coeff[10] * (FLAC__int64)data[i-11];\n\t\t\t\t         sum += qlp_coeff[ 9] * (FLAC__int64)data[i-10];\n\t\t\t\t         sum += qlp_coeff[ 8] * (FLAC__int64)data[i- 9];\n\t\t\t\t         sum += qlp_coeff[ 7] * (FLAC__int64)data[i- 8];\n\t\t\t\t         sum += qlp_coeff[ 6] * (FLAC__int64)data[i- 7];\n\t\t\t\t         sum += qlp_coeff[ 5] * (FLAC__int64)data[i- 6];\n\t\t\t\t         sum += qlp_coeff[ 4] * (FLAC__int64)data[i- 5];\n\t\t\t\t         sum += qlp_coeff[ 3] * (FLAC__int64)data[i- 4];\n\t\t\t\t         sum += qlp_coeff[ 2] * (FLAC__int64)data[i- 3];\n\t\t\t\t         sum += qlp_coeff[ 1] * (FLAC__int64)data[i- 2];\n\t\t\t\t         sum += qlp_coeff[ 0] * (FLAC__int64)data[i- 1];\n\t\t\t}\n\t\t\tdata[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);\n\t\t}\n\t}\n}\n#endif\n\n#if defined(_MSC_VER)\n#pragma warning ( default : 4028 )\n#endif\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\ndouble FLAC__lpc_compute_expected_bits_per_residual_sample(double lpc_error, unsigned total_samples)\n{\n\tdouble error_scale;\n\n\tFLAC__ASSERT(total_samples > 0);\n\n\terror_scale = 0.5 / (double)total_samples;\n\n\treturn FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error, error_scale);\n}\n\ndouble FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(double lpc_error, double error_scale)\n{\n\tif(lpc_error > 0.0) {\n\t\tdouble bps = (double)0.5 * log(error_scale * lpc_error) / M_LN2;\n\t\tif(bps >= 0.0)\n\t\t\treturn bps;\n\t\telse\n\t\t\treturn 0.0;\n\t}\n\telse if(lpc_error < 0.0) { /* error should not be negative but can happen due to inadequate floating-point resolution */\n\t\treturn 1e32;\n\t}\n\telse {\n\t\treturn 0.0;\n\t}\n}\n\nunsigned FLAC__lpc_compute_best_order(const double lpc_error[], unsigned max_order, unsigned total_samples, unsigned overhead_bits_per_order)\n{\n\tunsigned order, indx, best_index; /* 'index' the index into lpc_error; index==order-1 since lpc_error[0] is for order==1, lpc_error[1] is for order==2, etc */\n\tdouble bits, best_bits, error_scale;\n\n\tFLAC__ASSERT(max_order > 0);\n\tFLAC__ASSERT(total_samples > 0);\n\n\terror_scale = 0.5 / (double)total_samples;\n\n\tbest_index = 0;\n\tbest_bits = (unsigned)(-1);\n\n\tfor(indx = 0, order = 1; indx < max_order; indx++, order++) {\n\t\tbits = FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error[indx], error_scale) * (double)(total_samples - order) + (double)(order * overhead_bits_per_order);\n\t\tif(bits < best_bits) {\n\t\t\tbest_index = indx;\n\t\t\tbest_bits = bits;\n\t\t}\n\t}\n\n\treturn best_index+1; /* +1 since indx of lpc_error[] is order-1 */\n}\n\n#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */\n","#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdlib.h>\t\t/* for malloc() */\n#include <string.h>\t\t/* for memcpy() */\n\n#include \"private/md5.h\"\n#include \"share/alloc.h\"\n#include \"share/endswap.h\"\n\n/*\n * This code implements the MD5 message-digest algorithm.\n * The algorithm is due to Ron Rivest.  This code was\n * written by Colin Plumb in 1993, no copyright is claimed.\n * This code is in the public domain; do with it what you wish.\n *\n * Equivalent code is available from RSA Data Security, Inc.\n * This code has been tested against that, and is equivalent,\n * except that you don't need to include two pages of legalese\n * with every copy.\n *\n * To compute the message digest of a chunk of bytes, declare an\n * MD5Context structure, pass it to MD5Init, call MD5Update as\n * needed on buffers full of bytes, and then call MD5Final, which\n * will fill a supplied 16-byte array with the digest.\n *\n * Changed so as no longer to depend on Colin Plumb's `usual.h' header\n * definitions; now uses stuff from dpkg's config.h.\n *  - Ian Jackson <ijackson@nyx.cs.du.edu>.\n * Still in the public domain.\n *\n * Josh Coalson: made some changes to integrate with libFLAC.\n * Still in the public domain.\n */\n\n/* The four core functions - F1 is optimized somewhat */\n\n/* #define F1(x, y, z) (x & y | ~x & z) */\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n/* This is the central step in the MD5 algorithm. */\n#define MD5STEP(f,w,x,y,z,in,s) \\\n\t (w += f(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)\n\n/*\n * The core of the MD5 algorithm, this alters an existing MD5 hash to\n * reflect the addition of 16 longwords of new data.  MD5Update blocks\n * the data and converts bytes into longwords for this routine.\n */\nstatic void FLAC__MD5Transform(FLAC__uint32 buf[4], FLAC__uint32 const in[16])\n{\n\tregister FLAC__uint32 a, b, c, d;\n\n\ta = buf[0];\n\tb = buf[1];\n\tc = buf[2];\n\td = buf[3];\n\n\tMD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n\tMD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n\tMD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n\tMD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n\tMD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n\tMD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n\tMD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n\tMD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n\tMD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n\tMD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n\tMD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n\tMD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n\tMD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n\tMD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n\tMD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n\tMD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n\tMD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n\tMD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n\tMD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n\tMD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n\tMD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n\tMD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n\tMD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n\tMD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n\tMD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n\tMD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n\tMD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n\tMD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n\tMD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n\tMD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n\tMD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n\tMD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n\tMD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n\tMD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n\tMD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n\tMD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n\tMD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n\tMD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n\tMD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n\tMD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n\tMD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n\tMD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n\tMD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n\tMD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n\tMD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n\tMD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n\tMD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n\tMD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n\tMD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n\tMD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n\tMD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n\tMD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n\tMD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n\tMD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n\tMD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n\tMD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n\tMD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n\tMD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n\tMD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n\tMD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n\tMD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n\tMD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n\tMD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n\tMD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n\tbuf[0] += a;\n\tbuf[1] += b;\n\tbuf[2] += c;\n\tbuf[3] += d;\n}\n\n#if WORDS_BIGENDIAN\n//@@@@@@ OPT: use bswap/intrinsics\nstatic void byteSwap(FLAC__uint32 *buf, unsigned words)\n{\n\tregister FLAC__uint32 x;\n\tdo {\n\t\tx = *buf;\n\t\tx = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff);\n\t\t*buf++ = (x >> 16) | (x << 16);\n\t} while (--words);\n}\nstatic void byteSwapX16(FLAC__uint32 *buf)\n{\n\tregister FLAC__uint32 x;\n\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);\n\tx = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf   = (x >> 16) | (x << 16);\n}\n#else\n#define byteSwap(buf, words)\n#define byteSwapX16(buf)\n#endif\n\n/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\nstatic void FLAC__MD5Update(FLAC__MD5Context *ctx, FLAC__byte const *buf, unsigned len)\n{\n\tFLAC__uint32 t;\n\n\t/* Update byte count */\n\n\tt = ctx->bytes[0];\n\tif ((ctx->bytes[0] = t + len) < t)\n\t\tctx->bytes[1]++;\t/* Carry from low to high */\n\n\tt = 64 - (t & 0x3f);\t/* Space available in ctx->in (at least 1) */\n\tif (t > len) {\n\t\tmemcpy((FLAC__byte *)ctx->in + 64 - t, buf, len);\n\t\treturn;\n\t}\n\t/* First chunk is an odd size */\n\tmemcpy((FLAC__byte *)ctx->in + 64 - t, buf, t);\n\tbyteSwapX16(ctx->in);\n\tFLAC__MD5Transform(ctx->buf, ctx->in);\n\tbuf += t;\n\tlen -= t;\n\n\t/* Process data in 64-byte chunks */\n\twhile (len >= 64) {\n\t\tmemcpy(ctx->in, buf, 64);\n\t\tbyteSwapX16(ctx->in);\n\t\tFLAC__MD5Transform(ctx->buf, ctx->in);\n\t\tbuf += 64;\n\t\tlen -= 64;\n\t}\n\n\t/* Handle any remaining bytes of data. */\n\tmemcpy(ctx->in, buf, len);\n}\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid FLAC__MD5Init(FLAC__MD5Context *ctx)\n{\n\tctx->buf[0] = 0x67452301;\n\tctx->buf[1] = 0xefcdab89;\n\tctx->buf[2] = 0x98badcfe;\n\tctx->buf[3] = 0x10325476;\n\n\tctx->bytes[0] = 0;\n\tctx->bytes[1] = 0;\n\n\tctx->internal_buf.p8 = 0;\n\tctx->capacity = 0;\n}\n\n/*\n * Final wrapup - pad to 64-byte boundary with the bit pattern\n * 1 0* (64-bit count of bits processed, MSB-first)\n */\nvoid FLAC__MD5Final(FLAC__byte digest[16], FLAC__MD5Context *ctx)\n{\n\tint count = ctx->bytes[0] & 0x3f;\t/* Number of bytes in ctx->in */\n\tFLAC__byte *p = (FLAC__byte *)ctx->in + count;\n\n\t/* Set the first char of padding to 0x80.  There is always room. */\n\t*p++ = 0x80;\n\n\t/* Bytes of padding needed to make 56 bytes (-8..55) */\n\tcount = 56 - 1 - count;\n\n\tif (count < 0) {\t/* Padding forces an extra block */\n\t\tmemset(p, 0, count + 8);\n\t\tbyteSwapX16(ctx->in);\n\t\tFLAC__MD5Transform(ctx->buf, ctx->in);\n\t\tp = (FLAC__byte *)ctx->in;\n\t\tcount = 56;\n\t}\n\tmemset(p, 0, count);\n\tbyteSwap(ctx->in, 14);\n\n\t/* Append length in bits and transform */\n\tctx->in[14] = ctx->bytes[0] << 3;\n\tctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;\n\tFLAC__MD5Transform(ctx->buf, ctx->in);\n\n\tbyteSwap(ctx->buf, 4);\n\tmemcpy(digest, ctx->buf, 16);\n\tif (0 != ctx->internal_buf.p8) {\n\t\tfree(ctx->internal_buf.p8);\n\t\tctx->internal_buf.p8 = 0;\n\t\tctx->capacity = 0;\n\t}\n\tmemset(ctx, 0, sizeof(*ctx));\t/* In case it's sensitive */\n}\n\n/*\n * Convert the incoming audio signal to a byte stream\n */\nstatic void format_input_(FLAC__multibyte *mbuf, const FLAC__int32 * const signal[], unsigned channels, unsigned samples, unsigned bytes_per_sample)\n{\n\tFLAC__byte *buf_ = mbuf->p8;\n\tFLAC__int16 *buf16 = mbuf->p16;\n\tFLAC__int32 *buf32 = mbuf->p32;\n\tFLAC__int32 a_word;\n\tunsigned channel, sample;\n\n\t/* Storage in the output buffer, buf, is little endian. */\n\n#define BYTES_CHANNEL_SELECTOR(bytes, channels)   (bytes * 100 + channels)\n\n\t/* First do the most commonly used combinations. */\n\tswitch (BYTES_CHANNEL_SELECTOR (bytes_per_sample, channels)) {\n\t\t/* One byte per sample. */\n\t\tcase (BYTES_CHANNEL_SELECTOR (1, 1)):\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\t*buf_++ = signal[0][sample];\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (1, 2)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf_++ = signal[0][sample];\n\t\t\t\t*buf_++ = signal[1][sample];\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (1, 4)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf_++ = signal[0][sample];\n\t\t\t\t*buf_++ = signal[1][sample];\n\t\t\t\t*buf_++ = signal[2][sample];\n\t\t\t\t*buf_++ = signal[3][sample];\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (1, 6)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf_++ = signal[0][sample];\n\t\t\t\t*buf_++ = signal[1][sample];\n\t\t\t\t*buf_++ = signal[2][sample];\n\t\t\t\t*buf_++ = signal[3][sample];\n\t\t\t\t*buf_++ = signal[4][sample];\n\t\t\t\t*buf_++ = signal[5][sample];\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (1, 8)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf_++ = signal[0][sample];\n\t\t\t\t*buf_++ = signal[1][sample];\n\t\t\t\t*buf_++ = signal[2][sample];\n\t\t\t\t*buf_++ = signal[3][sample];\n\t\t\t\t*buf_++ = signal[4][sample];\n\t\t\t\t*buf_++ = signal[5][sample];\n\t\t\t\t*buf_++ = signal[6][sample];\n\t\t\t\t*buf_++ = signal[7][sample];\n\t\t\t}\n\t\t\treturn;\n\n\t\t/* Two bytes per sample. */\n\t\tcase (BYTES_CHANNEL_SELECTOR (2, 1)):\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\t*buf16++ = H2LE_16(signal[0][sample]);\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (2, 2)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf16++ = H2LE_16(signal[0][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[1][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (2, 4)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf16++ = H2LE_16(signal[0][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[1][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[2][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[3][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (2, 6)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf16++ = H2LE_16(signal[0][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[1][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[2][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[3][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[4][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[5][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (2, 8)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf16++ = H2LE_16(signal[0][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[1][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[2][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[3][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[4][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[5][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[6][sample]);\n\t\t\t\t*buf16++ = H2LE_16(signal[7][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\t/* Three bytes per sample. */\n\t\tcase (BYTES_CHANNEL_SELECTOR (3, 1)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\ta_word = signal[0][sample];\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word;\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (3, 2)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\ta_word = signal[0][sample];\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word;\n\t\t\t\ta_word = signal[1][sample];\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t*buf_++ = (FLAC__byte)a_word;\n\t\t\t}\n\t\t\treturn;\n\n\t\t/* Four bytes per sample. */\n\t\tcase (BYTES_CHANNEL_SELECTOR (4, 1)):\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\t*buf32++ = H2LE_32(signal[0][sample]);\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (4, 2)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf32++ = H2LE_32(signal[0][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[1][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (4, 4)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf32++ = H2LE_32(signal[0][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[1][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[2][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[3][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (4, 6)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf32++ = H2LE_32(signal[0][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[1][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[2][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[3][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[4][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[5][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase (BYTES_CHANNEL_SELECTOR (4, 8)):\n\t\t\tfor (sample = 0; sample < samples; sample++) {\n\t\t\t\t*buf32++ = H2LE_32(signal[0][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[1][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[2][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[3][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[4][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[5][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[6][sample]);\n\t\t\t\t*buf32++ = H2LE_32(signal[7][sample]);\n\t\t\t}\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/* General version. */\n\tswitch (bytes_per_sample) {\n\t\tcase 1:\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\tfor (channel = 0; channel < channels; channel++)\n\t\t\t\t\t*buf_++ = signal[channel][sample];\n\t\t\treturn;\n\n\t\tcase 2:\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\tfor (channel = 0; channel < channels; channel++)\n\t\t\t\t\t*buf16++ = H2LE_16(signal[channel][sample]);\n\t\t\treturn;\n\n\t\tcase 3:\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\tfor (channel = 0; channel < channels; channel++) {\n\t\t\t\t\ta_word = signal[channel][sample];\n\t\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t\t*buf_++ = (FLAC__byte)a_word; a_word >>= 8;\n\t\t\t\t\t*buf_++ = (FLAC__byte)a_word;\n\t\t\t\t}\n\t\t\treturn;\n\n\t\tcase 4:\n\t\t\tfor (sample = 0; sample < samples; sample++)\n\t\t\t\tfor (channel = 0; channel < channels; channel++)\n\t\t\t\t\t*buf32++ = H2LE_32(signal[channel][sample]);\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\n/*\n * Convert the incoming audio signal to a byte stream and FLAC__MD5Update it.\n */\nFLAC__bool FLAC__MD5Accumulate(FLAC__MD5Context *ctx, const FLAC__int32 * const signal[], unsigned channels, unsigned samples, unsigned bytes_per_sample)\n{\n\tconst size_t bytes_needed = (size_t)channels * (size_t)samples * (size_t)bytes_per_sample;\n\n\t/* overflow check */\n\tif ((size_t)channels > SIZE_MAX / (size_t)bytes_per_sample)\n\t\treturn false;\n\tif ((size_t)channels * (size_t)bytes_per_sample > SIZE_MAX / (size_t)samples)\n\t\treturn false;\n\n\tif (ctx->capacity < bytes_needed) {\n\t\tif (0 == (ctx->internal_buf.p8 = safe_realloc_(ctx->internal_buf.p8, bytes_needed))) {\n\t\t\tif (0 == (ctx->internal_buf.p8 = safe_malloc_(bytes_needed))) {\n\t\t\t\tctx->capacity = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tctx->capacity = bytes_needed;\n\t}\n\n\tformat_input_(&ctx->internal_buf, signal, channels, samples, bytes_per_sample);\n\n\tFLAC__MD5Update(ctx, ctx->internal_buf.p8, bytes_needed);\n\n\treturn true;\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2001-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n\n#include \"private/memory.h\"\n#include \"FLAC/assert.h\"\n#include \"share/alloc.h\"\n\nvoid *FLAC__memory_alloc_aligned(size_t bytes, void **aligned_address)\n{\n\tvoid *x;\n\n\tFLAC__ASSERT(0 != aligned_address);\n\n#ifdef FLAC__ALIGN_MALLOC_DATA\n\t/* align on 32-byte (256-bit) boundary */\n\tx = safe_malloc_add_2op_(bytes, /*+*/31L);\n\t*aligned_address = (void*)(((uintptr_t)x + 31L) & -32L);\n#else\n\tx = safe_malloc_(bytes);\n\t*aligned_address = x;\n#endif\n\treturn x;\n}\n\nFLAC__bool FLAC__memory_alloc_aligned_int32_array(size_t elements, FLAC__int32 **unaligned_pointer, FLAC__int32 **aligned_pointer)\n{\n\tFLAC__int32 *pu; /* unaligned pointer */\n\tunion { /* union needed to comply with C99 pointer aliasing rules */\n\t\tFLAC__int32 *pa; /* aligned pointer */\n\t\tvoid        *pv; /* aligned pointer alias */\n\t} u;\n\n\tFLAC__ASSERT(elements > 0);\n\tFLAC__ASSERT(0 != unaligned_pointer);\n\tFLAC__ASSERT(0 != aligned_pointer);\n\tFLAC__ASSERT(unaligned_pointer != aligned_pointer);\n\n\tif(elements > SIZE_MAX / sizeof(*pu)) /* overflow check */\n\t\treturn false;\n\n\tpu = FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);\n\tif(0 == pu) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif(*unaligned_pointer != 0)\n\t\t\tfree(*unaligned_pointer);\n\t\t*unaligned_pointer = pu;\n\t\t*aligned_pointer = u.pa;\n\t\treturn true;\n\t}\n}\n\nFLAC__bool FLAC__memory_alloc_aligned_uint32_array(size_t elements, FLAC__uint32 **unaligned_pointer, FLAC__uint32 **aligned_pointer)\n{\n\tFLAC__uint32 *pu; /* unaligned pointer */\n\tunion { /* union needed to comply with C99 pointer aliasing rules */\n\t\tFLAC__uint32 *pa; /* aligned pointer */\n\t\tvoid         *pv; /* aligned pointer alias */\n\t} u;\n\n\tFLAC__ASSERT(elements > 0);\n\tFLAC__ASSERT(0 != unaligned_pointer);\n\tFLAC__ASSERT(0 != aligned_pointer);\n\tFLAC__ASSERT(unaligned_pointer != aligned_pointer);\n\n\tif(elements > SIZE_MAX / sizeof(*pu)) /* overflow check */\n\t\treturn false;\n\n\tpu = FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);\n\tif(0 == pu) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif(*unaligned_pointer != 0)\n\t\t\tfree(*unaligned_pointer);\n\t\t*unaligned_pointer = pu;\n\t\t*aligned_pointer = u.pa;\n\t\treturn true;\n\t}\n}\n\nFLAC__bool FLAC__memory_alloc_aligned_uint64_array(size_t elements, FLAC__uint64 **unaligned_pointer, FLAC__uint64 **aligned_pointer)\n{\n\tFLAC__uint64 *pu; /* unaligned pointer */\n\tunion { /* union needed to comply with C99 pointer aliasing rules */\n\t\tFLAC__uint64 *pa; /* aligned pointer */\n\t\tvoid         *pv; /* aligned pointer alias */\n\t} u;\n\n\tFLAC__ASSERT(elements > 0);\n\tFLAC__ASSERT(0 != unaligned_pointer);\n\tFLAC__ASSERT(0 != aligned_pointer);\n\tFLAC__ASSERT(unaligned_pointer != aligned_pointer);\n\n\tif(elements > SIZE_MAX / sizeof(*pu)) /* overflow check */\n\t\treturn false;\n\n\tpu = FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);\n\tif(0 == pu) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif(*unaligned_pointer != 0)\n\t\t\tfree(*unaligned_pointer);\n\t\t*unaligned_pointer = pu;\n\t\t*aligned_pointer = u.pa;\n\t\treturn true;\n\t}\n}\n\nFLAC__bool FLAC__memory_alloc_aligned_unsigned_array(size_t elements, unsigned **unaligned_pointer, unsigned **aligned_pointer)\n{\n\tunsigned *pu; /* unaligned pointer */\n\tunion { /* union needed to comply with C99 pointer aliasing rules */\n\t\tunsigned *pa; /* aligned pointer */\n\t\tvoid     *pv; /* aligned pointer alias */\n\t} u;\n\n\tFLAC__ASSERT(elements > 0);\n\tFLAC__ASSERT(0 != unaligned_pointer);\n\tFLAC__ASSERT(0 != aligned_pointer);\n\tFLAC__ASSERT(unaligned_pointer != aligned_pointer);\n\n\tif(elements > SIZE_MAX / sizeof(*pu)) /* overflow check */\n\t\treturn false;\n\n\tpu = FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);\n\tif(0 == pu) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif(*unaligned_pointer != 0)\n\t\t\tfree(*unaligned_pointer);\n\t\t*unaligned_pointer = pu;\n\t\t*aligned_pointer = u.pa;\n\t\treturn true;\n\t}\n}\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\nFLAC__bool FLAC__memory_alloc_aligned_real_array(size_t elements, FLAC__real **unaligned_pointer, FLAC__real **aligned_pointer)\n{\n\tFLAC__real *pu; /* unaligned pointer */\n\tunion { /* union needed to comply with C99 pointer aliasing rules */\n\t\tFLAC__real *pa; /* aligned pointer */\n\t\tvoid       *pv; /* aligned pointer alias */\n\t} u;\n\n\tFLAC__ASSERT(elements > 0);\n\tFLAC__ASSERT(0 != unaligned_pointer);\n\tFLAC__ASSERT(0 != aligned_pointer);\n\tFLAC__ASSERT(unaligned_pointer != aligned_pointer);\n\n\tif(elements > SIZE_MAX / sizeof(*pu)) /* overflow check */\n\t\treturn false;\n\n\tpu = FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);\n\tif(0 == pu) {\n\t\treturn false;\n\t}\n\telse {\n\t\tif(*unaligned_pointer != 0)\n\t\t\tfree(*unaligned_pointer);\n\t\t*unaligned_pointer = pu;\n\t\t*aligned_pointer = u.pa;\n\t\treturn true;\n\t}\n}\n\n#endif\n\nvoid *safe_malloc_mul_2op_p(size_t size1, size_t size2)\n{\n\tif(!size1 || !size2)\n\t\treturn malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */\n\tif(size1 > SIZE_MAX / size2)\n\t\treturn 0;\n\treturn malloc(size1*size2);\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h> /* for malloc() */\n#include <string.h> /* for memset/memcpy() */\n#include <sys/stat.h> /* for stat() */\n#include <sys/types.h> /* for off_t */\n#include \"share/compat.h\"\n#include \"FLAC/assert.h\"\n#include \"share/alloc.h\"\n#include \"protected/stream_decoder.h\"\n#include \"private/bitreader.h\"\n#include \"private/bitmath.h\"\n#include \"private/cpu.h\"\n#include \"private/crc.h\"\n#include \"private/fixed.h\"\n#include \"private/format.h\"\n#include \"private/lpc.h\"\n#include \"private/md5.h\"\n#include \"private/memory.h\"\n#include \"private/macros.h\"\n\n\n/* technically this should be in an \"export.c\" but this is convenient enough */\nFLAC_API int FLAC_API_SUPPORTS_OGG_FLAC = FLAC__HAS_OGG;\n\n\n/***********************************************************************\n *\n * Private static data\n *\n ***********************************************************************/\n\nstatic const FLAC__byte ID3V2_TAG_[3] = { 'I', 'D', '3' };\n\n/***********************************************************************\n *\n * Private class method prototypes\n *\n ***********************************************************************/\n\nstatic void set_defaults_(FLAC__StreamDecoder *decoder);\nstatic FILE *get_binary_stdin_(void);\nstatic FLAC__bool allocate_output_(FLAC__StreamDecoder *decoder, unsigned size, unsigned channels);\nstatic FLAC__bool has_id_filtered_(FLAC__StreamDecoder *decoder, FLAC__byte *id);\nstatic FLAC__bool find_metadata_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool read_metadata_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool read_metadata_streaminfo_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length);\nstatic FLAC__bool read_metadata_seektable_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length);\nstatic FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj, unsigned length);\nstatic FLAC__bool read_metadata_cuesheet_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_CueSheet *obj);\nstatic FLAC__bool read_metadata_picture_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_Picture *obj);\nstatic FLAC__bool skip_id3v2_tag_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool frame_sync_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool read_frame_(FLAC__StreamDecoder *decoder, FLAC__bool *got_a_frame, FLAC__bool do_full_decode);\nstatic FLAC__bool read_frame_header_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool read_subframe_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);\nstatic FLAC__bool read_subframe_constant_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);\nstatic FLAC__bool read_subframe_fixed_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode);\nstatic FLAC__bool read_subframe_lpc_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode);\nstatic FLAC__bool read_subframe_verbatim_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);\nstatic FLAC__bool read_residual_partitioned_rice_(FLAC__StreamDecoder *decoder, unsigned predictor_order, unsigned partition_order, FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents, FLAC__int32 *residual, FLAC__bool is_extended);\nstatic FLAC__bool read_zero_padding_(FLAC__StreamDecoder *decoder);\nstatic FLAC__bool read_callback_(FLAC__byte buffer[], size_t *bytes, void *client_data);\n#if FLAC__HAS_OGG\nstatic FLAC__StreamDecoderReadStatus read_callback_ogg_aspect_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes);\nstatic FLAC__OggDecoderAspectReadStatus read_callback_proxy_(const void *void_decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);\n#endif\nstatic FLAC__StreamDecoderWriteStatus write_audio_frame_to_client_(FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[]);\nstatic void send_error_to_client_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status);\nstatic FLAC__bool seek_to_absolute_sample_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample);\n#if FLAC__HAS_OGG\nstatic FLAC__bool seek_to_absolute_sample_ogg_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample);\n#endif\nstatic FLAC__StreamDecoderReadStatus file_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);\nstatic FLAC__StreamDecoderSeekStatus file_seek_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data);\nstatic FLAC__StreamDecoderTellStatus file_tell_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data);\nstatic FLAC__StreamDecoderLengthStatus file_length_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data);\nstatic FLAC__bool file_eof_callback_(const FLAC__StreamDecoder *decoder, void *client_data);\n\n/***********************************************************************\n *\n * Private class data\n *\n ***********************************************************************/\n\ntypedef struct FLAC__StreamDecoderPrivate {\n\tFLAC__bool is_ogg;\n\tFLAC__StreamDecoderReadCallback read_callback;\n\tFLAC__StreamDecoderSeekCallback seek_callback;\n\tFLAC__StreamDecoderTellCallback tell_callback;\n\tFLAC__StreamDecoderLengthCallback length_callback;\n\tFLAC__StreamDecoderEofCallback eof_callback;\n\tFLAC__StreamDecoderWriteCallback write_callback;\n\tFLAC__StreamDecoderMetadataCallback metadata_callback;\n\tFLAC__StreamDecoderErrorCallback error_callback;\n\t/* generic 32-bit datapath: */\n\tvoid (*local_lpc_restore_signal)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);\n\t/* generic 64-bit datapath: */\n\tvoid (*local_lpc_restore_signal_64bit)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);\n\t/* for use when the signal is <= 16 bits-per-sample, or <= 15 bits-per-sample on a side channel (which requires 1 extra bit): */\n\tvoid (*local_lpc_restore_signal_16bit)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);\n\tvoid *client_data;\n\tFILE *file; /* only used if FLAC__stream_decoder_init_file()/FLAC__stream_decoder_init_file() called, else NULL */\n\tFLAC__BitReader *input;\n\tFLAC__int32 *output[FLAC__MAX_CHANNELS];\n\tFLAC__int32 *residual[FLAC__MAX_CHANNELS]; /* WATCHOUT: these are the aligned pointers; the real pointers that should be free()'d are residual_unaligned[] below */\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents[FLAC__MAX_CHANNELS];\n\tunsigned output_capacity, output_channels;\n\tFLAC__uint32 fixed_block_size, next_fixed_block_size;\n\tFLAC__uint64 samples_decoded;\n\tFLAC__bool has_stream_info, has_seek_table;\n\tFLAC__StreamMetadata stream_info;\n\tFLAC__StreamMetadata seek_table;\n\tFLAC__bool metadata_filter[128]; /* MAGIC number 128 == total number of metadata block types == 1 << 7 */\n\tFLAC__byte *metadata_filter_ids;\n\tsize_t metadata_filter_ids_count, metadata_filter_ids_capacity; /* units for both are IDs, not bytes */\n\tFLAC__Frame frame;\n\tFLAC__bool cached; /* true if there is a byte in lookahead */\n\tFLAC__CPUInfo cpuinfo;\n\tFLAC__byte header_warmup[2]; /* contains the sync code and reserved bits */\n\tFLAC__byte lookahead; /* temp storage when we need to look ahead one byte in the stream */\n\t/* unaligned (original) pointers to allocated data */\n\tFLAC__int32 *residual_unaligned[FLAC__MAX_CHANNELS];\n\tFLAC__bool do_md5_checking; /* initially gets protected_->md5_checking but is turned off after a seek or if the metadata has a zero MD5 */\n\tFLAC__bool internal_reset_hack; /* used only during init() so we can call reset to set up the decoder without rewinding the input */\n\tFLAC__bool is_seeking;\n\tFLAC__MD5Context md5context;\n\tFLAC__byte computed_md5sum[16]; /* this is the sum we computed from the decoded data */\n\t/* (the rest of these are only used for seeking) */\n\tFLAC__Frame last_frame; /* holds the info of the last frame we seeked to */\n\tFLAC__uint64 first_frame_offset; /* hint to the seek routine of where in the stream the first audio frame starts */\n\tFLAC__uint64 target_sample;\n\tunsigned unparseable_frame_count; /* used to tell whether we're decoding a future version of FLAC or just got a bad sync */\n\tFLAC__bool got_a_frame; /* hack needed in Ogg FLAC seek routine to check when process_single() actually writes a frame */\n} FLAC__StreamDecoderPrivate;\n\n/***********************************************************************\n *\n * Public static class data\n *\n ***********************************************************************/\n\nFLAC_API const char * const FLAC__StreamDecoderStateString[] = {\n\t\"FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\",\n\t\"FLAC__STREAM_DECODER_READ_METADATA\",\n\t\"FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC\",\n\t\"FLAC__STREAM_DECODER_READ_FRAME\",\n\t\"FLAC__STREAM_DECODER_END_OF_STREAM\",\n\t\"FLAC__STREAM_DECODER_OGG_ERROR\",\n\t\"FLAC__STREAM_DECODER_SEEK_ERROR\",\n\t\"FLAC__STREAM_DECODER_ABORTED\",\n\t\"FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR\",\n\t\"FLAC__STREAM_DECODER_UNINITIALIZED\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderInitStatusString[] = {\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_OK\",\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER\",\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS\",\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR\",\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE\",\n\t\"FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderReadStatusString[] = {\n\t\"FLAC__STREAM_DECODER_READ_STATUS_CONTINUE\",\n\t\"FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM\",\n\t\"FLAC__STREAM_DECODER_READ_STATUS_ABORT\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderSeekStatusString[] = {\n\t\"FLAC__STREAM_DECODER_SEEK_STATUS_OK\",\n\t\"FLAC__STREAM_DECODER_SEEK_STATUS_ERROR\",\n\t\"FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderTellStatusString[] = {\n\t\"FLAC__STREAM_DECODER_TELL_STATUS_OK\",\n\t\"FLAC__STREAM_DECODER_TELL_STATUS_ERROR\",\n\t\"FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderLengthStatusString[] = {\n\t\"FLAC__STREAM_DECODER_LENGTH_STATUS_OK\",\n\t\"FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR\",\n\t\"FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderWriteStatusString[] = {\n\t\"FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE\",\n\t\"FLAC__STREAM_DECODER_WRITE_STATUS_ABORT\"\n};\n\nFLAC_API const char * const FLAC__StreamDecoderErrorStatusString[] = {\n\t\"FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC\",\n\t\"FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER\",\n\t\"FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH\",\n\t\"FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM\"\n};\n\n/***********************************************************************\n *\n * Class constructor/destructor\n *\n ***********************************************************************/\nFLAC_API FLAC__StreamDecoder *FLAC__stream_decoder_new(void)\n{\n\tFLAC__StreamDecoder *decoder;\n\tunsigned i;\n\n\tFLAC__ASSERT(sizeof(int) >= 4); /* we want to die right away if this is not true */\n\n\tdecoder = calloc(1, sizeof(FLAC__StreamDecoder));\n\tif(decoder == 0) {\n\t\treturn 0;\n\t}\n\n\tdecoder->protected_ = calloc(1, sizeof(FLAC__StreamDecoderProtected));\n\tif(decoder->protected_ == 0) {\n\t\tfree(decoder);\n\t\treturn 0;\n\t}\n\n\tdecoder->private_ = calloc(1, sizeof(FLAC__StreamDecoderPrivate));\n\tif(decoder->private_ == 0) {\n\t\tfree(decoder->protected_);\n\t\tfree(decoder);\n\t\treturn 0;\n\t}\n\n\tdecoder->private_->input = FLAC__bitreader_new();\n\tif(decoder->private_->input == 0) {\n\t\tfree(decoder->private_);\n\t\tfree(decoder->protected_);\n\t\tfree(decoder);\n\t\treturn 0;\n\t}\n\n\tdecoder->private_->metadata_filter_ids_capacity = 16;\n\tif(0 == (decoder->private_->metadata_filter_ids = malloc((FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8) * decoder->private_->metadata_filter_ids_capacity))) {\n\t\tFLAC__bitreader_delete(decoder->private_->input);\n\t\tfree(decoder->private_);\n\t\tfree(decoder->protected_);\n\t\tfree(decoder);\n\t\treturn 0;\n\t}\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tdecoder->private_->output[i] = 0;\n\t\tdecoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;\n\t}\n\n\tdecoder->private_->output_capacity = 0;\n\tdecoder->private_->output_channels = 0;\n\tdecoder->private_->has_seek_table = false;\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++)\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&decoder->private_->partitioned_rice_contents[i]);\n\n\tdecoder->private_->file = 0;\n\n\tset_defaults_(decoder);\n\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_UNINITIALIZED;\n\n\treturn decoder;\n}\n\nFLAC_API void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder)\n{\n\tunsigned i;\n\n\tif (decoder == NULL)\n\t\treturn ;\n\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->private_->input);\n\n\t(void)FLAC__stream_decoder_finish(decoder);\n\n\tif(0 != decoder->private_->metadata_filter_ids)\n\t\tfree(decoder->private_->metadata_filter_ids);\n\n\tFLAC__bitreader_delete(decoder->private_->input);\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++)\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&decoder->private_->partitioned_rice_contents[i]);\n\n\tfree(decoder->private_);\n\tfree(decoder->protected_);\n\tfree(decoder);\n}\n\n/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n\nstatic FLAC__StreamDecoderInitStatus init_stream_internal_(\n\tFLAC__StreamDecoder *decoder,\n\tFLAC__StreamDecoderReadCallback read_callback,\n\tFLAC__StreamDecoderSeekCallback seek_callback,\n\tFLAC__StreamDecoderTellCallback tell_callback,\n\tFLAC__StreamDecoderLengthCallback length_callback,\n\tFLAC__StreamDecoderEofCallback eof_callback,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tFLAC__ASSERT(0 != decoder);\n\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\tif(FLAC__HAS_OGG == 0 && is_ogg)\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER;\n\n\tif(\n\t\t0 == read_callback ||\n\t\t0 == write_callback ||\n\t\t0 == error_callback ||\n\t\t(seek_callback && (0 == tell_callback || 0 == length_callback || 0 == eof_callback))\n\t)\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;\n\n#if FLAC__HAS_OGG\n\tdecoder->private_->is_ogg = is_ogg;\n\tif(is_ogg && !FLAC__ogg_decoder_aspect_init(&decoder->protected_->ogg_decoder_aspect))\n\t\treturn decoder->protected_->initstate = FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE;\n#endif\n\n\t/*\n\t * get the CPU info and set the function pointers\n\t */\n\tFLAC__cpu_info(&decoder->private_->cpuinfo);\n\t/* first default to the non-asm routines */\n\tdecoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal;\n\tdecoder->private_->local_lpc_restore_signal_64bit = FLAC__lpc_restore_signal_wide;\n\tdecoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal;\n\t/* now override with asm where appropriate */\n#ifndef FLAC__NO_ASM\n\tif(decoder->private_->cpuinfo.use_asm) {\n#ifdef FLAC__CPU_IA32\n\t\tFLAC__ASSERT(decoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_IA32);\n#ifdef FLAC__HAS_NASM\n\t\tdecoder->private_->local_lpc_restore_signal_64bit = FLAC__lpc_restore_signal_wide_asm_ia32; /* OPT_IA32: was really necessary for GCC < 4.9 */\n\t\tif(decoder->private_->cpuinfo.ia32.mmx) {\n\t\t\tdecoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal_asm_ia32;\n\t\t\tdecoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_asm_ia32_mmx;\n\t\t}\n\t\telse {\n\t\t\tdecoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal_asm_ia32;\n\t\t\tdecoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_asm_ia32;\n\t\t}\n#endif\n#if FLAC__HAS_X86INTRIN && ! defined FLAC__INTEGER_ONLY_LIBRARY\n# if defined FLAC__SSE2_SUPPORTED && !defined FLAC__HAS_NASM /* OPT_SSE: not better than MMX asm */\n\t\tif(decoder->private_->cpuinfo.ia32.sse2) {\n\t\t\tdecoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_16_intrin_sse2;\n\t\t}\n# endif\n# if defined FLAC__SSE4_1_SUPPORTED\n\t\tif(decoder->private_->cpuinfo.ia32.sse41) {\n\t\t\tdecoder->private_->local_lpc_restore_signal_64bit = FLAC__lpc_restore_signal_wide_intrin_sse41;\n\t\t}\n# endif\n#endif\n#elif defined FLAC__CPU_X86_64\n\t\tFLAC__ASSERT(decoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_X86_64);\n\t\t/* No useful SSE optimizations yet */\n#endif\n\t}\n#endif\n\n\t/* from here on, errors are fatal */\n\n\tif(!FLAC__bitreader_init(decoder->private_->input, read_callback_, decoder)) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR;\n\t}\n\n\tdecoder->private_->read_callback = read_callback;\n\tdecoder->private_->seek_callback = seek_callback;\n\tdecoder->private_->tell_callback = tell_callback;\n\tdecoder->private_->length_callback = length_callback;\n\tdecoder->private_->eof_callback = eof_callback;\n\tdecoder->private_->write_callback = write_callback;\n\tdecoder->private_->metadata_callback = metadata_callback;\n\tdecoder->private_->error_callback = error_callback;\n\tdecoder->private_->client_data = client_data;\n\tdecoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size = 0;\n\tdecoder->private_->samples_decoded = 0;\n\tdecoder->private_->has_stream_info = false;\n\tdecoder->private_->cached = false;\n\n\tdecoder->private_->do_md5_checking = decoder->protected_->md5_checking;\n\tdecoder->private_->is_seeking = false;\n\n\tdecoder->private_->internal_reset_hack = true; /* so the following reset does not try to rewind the input */\n\tif(!FLAC__stream_decoder_reset(decoder)) {\n\t\t/* above call sets the state for us */\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR;\n\t}\n\n\treturn FLAC__STREAM_DECODER_INIT_STATUS_OK;\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(\n\tFLAC__StreamDecoder *decoder,\n\tFLAC__StreamDecoderReadCallback read_callback,\n\tFLAC__StreamDecoderSeekCallback seek_callback,\n\tFLAC__StreamDecoderTellCallback tell_callback,\n\tFLAC__StreamDecoderLengthCallback length_callback,\n\tFLAC__StreamDecoderEofCallback eof_callback,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_stream_internal_(\n\t\tdecoder,\n\t\tread_callback,\n\t\tseek_callback,\n\t\ttell_callback,\n\t\tlength_callback,\n\t\teof_callback,\n\t\twrite_callback,\n\t\tmetadata_callback,\n\t\terror_callback,\n\t\tclient_data,\n\t\t/*is_ogg=*/false\n\t);\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(\n\tFLAC__StreamDecoder *decoder,\n\tFLAC__StreamDecoderReadCallback read_callback,\n\tFLAC__StreamDecoderSeekCallback seek_callback,\n\tFLAC__StreamDecoderTellCallback tell_callback,\n\tFLAC__StreamDecoderLengthCallback length_callback,\n\tFLAC__StreamDecoderEofCallback eof_callback,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_stream_internal_(\n\t\tdecoder,\n\t\tread_callback,\n\t\tseek_callback,\n\t\ttell_callback,\n\t\tlength_callback,\n\t\teof_callback,\n\t\twrite_callback,\n\t\tmetadata_callback,\n\t\terror_callback,\n\t\tclient_data,\n\t\t/*is_ogg=*/true\n\t);\n}\n\nstatic FLAC__StreamDecoderInitStatus init_FILE_internal_(\n\tFLAC__StreamDecoder *decoder,\n\tFILE *file,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != file);\n\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn decoder->protected_->initstate = FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\tif(0 == write_callback || 0 == error_callback)\n\t\treturn decoder->protected_->initstate = FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;\n\n\t/*\n\t * To make sure that our file does not go unclosed after an error, we\n\t * must assign the FILE pointer before any further error can occur in\n\t * this routine.\n\t */\n\tif(file == stdin)\n\t\tfile = get_binary_stdin_(); /* just to be safe */\n\n\tdecoder->private_->file = file;\n\n\treturn init_stream_internal_(\n\t\tdecoder,\n\t\tfile_read_callback_,\n\t\tdecoder->private_->file == stdin? 0: file_seek_callback_,\n\t\tdecoder->private_->file == stdin? 0: file_tell_callback_,\n\t\tdecoder->private_->file == stdin? 0: file_length_callback_,\n\t\tfile_eof_callback_,\n\t\twrite_callback,\n\t\tmetadata_callback,\n\t\terror_callback,\n\t\tclient_data,\n\t\tis_ogg\n\t);\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(\n\tFLAC__StreamDecoder *decoder,\n\tFILE *file,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/false);\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(\n\tFLAC__StreamDecoder *decoder,\n\tFILE *file,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/true);\n}\n\nstatic FLAC__StreamDecoderInitStatus init_file_internal_(\n\tFLAC__StreamDecoder *decoder,\n\tconst char *filename,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tFILE *file;\n\n\tFLAC__ASSERT(0 != decoder);\n\n\t/*\n\t * To make sure that our file does not go unclosed after an error, we\n\t * have to do the same entrance checks here that are later performed\n\t * in FLAC__stream_decoder_init_FILE() before the FILE* is assigned.\n\t */\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn decoder->protected_->initstate = FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\tif(0 == write_callback || 0 == error_callback)\n\t\treturn decoder->protected_->initstate = FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;\n\n\tfile = filename? flac_fopen(filename, \"rb\") : stdin;\n\n\tif(0 == file)\n\t\treturn FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE;\n\n\treturn init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, is_ogg);\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(\n\tFLAC__StreamDecoder *decoder,\n\tconst char *filename,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_file_internal_(decoder, filename, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/false);\n}\n\nFLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(\n\tFLAC__StreamDecoder *decoder,\n\tconst char *filename,\n\tFLAC__StreamDecoderWriteCallback write_callback,\n\tFLAC__StreamDecoderMetadataCallback metadata_callback,\n\tFLAC__StreamDecoderErrorCallback error_callback,\n\tvoid *client_data\n)\n{\n\treturn init_file_internal_(decoder, filename, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/true);\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__bool md5_failed = false;\n\tunsigned i;\n\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\tif(decoder->protected_->state == FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn true;\n\n\t/* see the comment in FLAC__stream_decoder_reset() as to why we\n\t * always call FLAC__MD5Final()\n\t */\n\tFLAC__MD5Final(decoder->private_->computed_md5sum, &decoder->private_->md5context);\n\n\tfree(decoder->private_->seek_table.data.seek_table.points);\n\tdecoder->private_->seek_table.data.seek_table.points = 0;\n\tdecoder->private_->has_seek_table = false;\n\n\tFLAC__bitreader_free(decoder->private_->input);\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\t/* WATCHOUT:\n\t\t * FLAC__lpc_restore_signal_asm_ia32_mmx() requires that the\n\t\t * output arrays have a buffer of up to 3 zeroes in front\n\t\t * (at negative indices) for alignment purposes; we use 4\n\t\t * to keep the data well-aligned.\n\t\t */\n\t\tif(0 != decoder->private_->output[i]) {\n\t\t\tfree(decoder->private_->output[i]-4);\n\t\t\tdecoder->private_->output[i] = 0;\n\t\t}\n\t\tif(0 != decoder->private_->residual_unaligned[i]) {\n\t\t\tfree(decoder->private_->residual_unaligned[i]);\n\t\t\tdecoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;\n\t\t}\n\t}\n\tdecoder->private_->output_capacity = 0;\n\tdecoder->private_->output_channels = 0;\n\n#if FLAC__HAS_OGG\n\tif(decoder->private_->is_ogg)\n\t\tFLAC__ogg_decoder_aspect_finish(&decoder->protected_->ogg_decoder_aspect);\n#endif\n\n\tif(0 != decoder->private_->file) {\n\t\tif(decoder->private_->file != stdin)\n\t\t\tfclose(decoder->private_->file);\n\t\tdecoder->private_->file = 0;\n\t}\n\n\tif(decoder->private_->do_md5_checking) {\n\t\tif(memcmp(decoder->private_->stream_info.data.stream_info.md5sum, decoder->private_->computed_md5sum, 16))\n\t\t\tmd5_failed = true;\n\t}\n\tdecoder->private_->is_seeking = false;\n\n\tset_defaults_(decoder);\n\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_UNINITIALIZED;\n\n\treturn !md5_failed;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder, long value)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n#if FLAC__HAS_OGG\n\t/* can't check decoder->private_->is_ogg since that's not set until init time */\n\tFLAC__ogg_decoder_aspect_set_serial_number(&decoder->protected_->ogg_decoder_aspect, value);\n\treturn true;\n#else\n\t(void)value;\n\treturn false;\n#endif\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\tdecoder->protected_->md5_checking = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder, FLAC__MetadataType type)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tFLAC__ASSERT((unsigned)type <= FLAC__MAX_METADATA_TYPE_CODE);\n\t/* double protection */\n\tif((unsigned)type > FLAC__MAX_METADATA_TYPE_CODE)\n\t\treturn false;\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\tdecoder->private_->metadata_filter[type] = true;\n\tif(type == FLAC__METADATA_TYPE_APPLICATION)\n\t\tdecoder->private_->metadata_filter_ids_count = 0;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4])\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tFLAC__ASSERT(0 != id);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\n\tif(decoder->private_->metadata_filter[FLAC__METADATA_TYPE_APPLICATION])\n\t\treturn true;\n\n\tFLAC__ASSERT(0 != decoder->private_->metadata_filter_ids);\n\n\tif(decoder->private_->metadata_filter_ids_count == decoder->private_->metadata_filter_ids_capacity) {\n\t\tif(0 == (decoder->private_->metadata_filter_ids = safe_realloc_mul_2op_(decoder->private_->metadata_filter_ids, decoder->private_->metadata_filter_ids_capacity, /*times*/2))) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tdecoder->private_->metadata_filter_ids_capacity *= 2;\n\t}\n\n\tmemcpy(decoder->private_->metadata_filter_ids + decoder->private_->metadata_filter_ids_count * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8));\n\tdecoder->private_->metadata_filter_ids_count++;\n\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder)\n{\n\tunsigned i;\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\tfor(i = 0; i < sizeof(decoder->private_->metadata_filter) / sizeof(decoder->private_->metadata_filter[0]); i++)\n\t\tdecoder->private_->metadata_filter[i] = true;\n\tdecoder->private_->metadata_filter_ids_count = 0;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder, FLAC__MetadataType type)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tFLAC__ASSERT((unsigned)type <= FLAC__MAX_METADATA_TYPE_CODE);\n\t/* double protection */\n\tif((unsigned)type > FLAC__MAX_METADATA_TYPE_CODE)\n\t\treturn false;\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\tdecoder->private_->metadata_filter[type] = false;\n\tif(type == FLAC__METADATA_TYPE_APPLICATION)\n\t\tdecoder->private_->metadata_filter_ids_count = 0;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4])\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tFLAC__ASSERT(0 != id);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\n\tif(!decoder->private_->metadata_filter[FLAC__METADATA_TYPE_APPLICATION])\n\t\treturn true;\n\n\tFLAC__ASSERT(0 != decoder->private_->metadata_filter_ids);\n\n\tif(decoder->private_->metadata_filter_ids_count == decoder->private_->metadata_filter_ids_capacity) {\n\t\tif(0 == (decoder->private_->metadata_filter_ids = safe_realloc_mul_2op_(decoder->private_->metadata_filter_ids, decoder->private_->metadata_filter_ids_capacity, /*times*/2))) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tdecoder->private_->metadata_filter_ids_capacity *= 2;\n\t}\n\n\tmemcpy(decoder->private_->metadata_filter_ids + decoder->private_->metadata_filter_ids_count * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8));\n\tdecoder->private_->metadata_filter_ids_count++;\n\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\tif(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\tmemset(decoder->private_->metadata_filter, 0, sizeof(decoder->private_->metadata_filter));\n\tdecoder->private_->metadata_filter_ids_count = 0;\n\treturn true;\n}\n\nFLAC_API FLAC__StreamDecoderState FLAC__stream_decoder_get_state(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->state;\n}\n\nFLAC_API const char *FLAC__stream_decoder_get_resolved_state_string(const FLAC__StreamDecoder *decoder)\n{\n\treturn FLAC__StreamDecoderStateString[decoder->protected_->state];\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_get_md5_checking(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->md5_checking;\n}\n\nFLAC_API FLAC__uint64 FLAC__stream_decoder_get_total_samples(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->private_->has_stream_info? decoder->private_->stream_info.data.stream_info.total_samples : 0;\n}\n\nFLAC_API unsigned FLAC__stream_decoder_get_channels(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->channels;\n}\n\nFLAC_API FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->channel_assignment;\n}\n\nFLAC_API unsigned FLAC__stream_decoder_get_bits_per_sample(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->bits_per_sample;\n}\n\nFLAC_API unsigned FLAC__stream_decoder_get_sample_rate(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->sample_rate;\n}\n\nFLAC_API unsigned FLAC__stream_decoder_get_blocksize(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\treturn decoder->protected_->blocksize;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_get_decode_position(const FLAC__StreamDecoder *decoder, FLAC__uint64 *position)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != position);\n\n\tif(FLAC__HAS_OGG && decoder->private_->is_ogg)\n\t\treturn false;\n\n\tif(0 == decoder->private_->tell_callback)\n\t\treturn false;\n\tif(decoder->private_->tell_callback(decoder, position, decoder->private_->client_data) != FLAC__STREAM_DECODER_TELL_STATUS_OK)\n\t\treturn false;\n\t/* should never happen since all FLAC frames and metadata blocks are byte aligned, but check just in case */\n\tif(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input))\n\t\treturn false;\n\tFLAC__ASSERT(*position >= FLAC__stream_decoder_get_input_bytes_unconsumed(decoder));\n\t*position -= FLAC__stream_decoder_get_input_bytes_unconsumed(decoder);\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\tif(!decoder->private_->internal_reset_hack && decoder->protected_->state == FLAC__STREAM_DECODER_UNINITIALIZED)\n\t\treturn false;\n\n\tdecoder->private_->samples_decoded = 0;\n\tdecoder->private_->do_md5_checking = false;\n\n#if FLAC__HAS_OGG\n\tif(decoder->private_->is_ogg)\n\t\tFLAC__ogg_decoder_aspect_flush(&decoder->protected_->ogg_decoder_aspect);\n#endif\n\n\tif(!FLAC__bitreader_clear(decoder->private_->input)) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\tif(!FLAC__stream_decoder_flush(decoder)) {\n\t\t/* above call sets the state for us */\n\t\treturn false;\n\t}\n\n#if FLAC__HAS_OGG\n\t/*@@@ could go in !internal_reset_hack block below */\n\tif(decoder->private_->is_ogg)\n\t\tFLAC__ogg_decoder_aspect_reset(&decoder->protected_->ogg_decoder_aspect);\n#endif\n\n\t/* Rewind if necessary.  If FLAC__stream_decoder_init() is calling us,\n\t * (internal_reset_hack) don't try to rewind since we are already at\n\t * the beginning of the stream and don't want to fail if the input is\n\t * not seekable.\n\t */\n\tif(!decoder->private_->internal_reset_hack) {\n\t\tif(decoder->private_->file == stdin)\n\t\t\treturn false; /* can't rewind stdin, reset fails */\n\t\tif(decoder->private_->seek_callback && decoder->private_->seek_callback(decoder, 0, decoder->private_->client_data) == FLAC__STREAM_DECODER_SEEK_STATUS_ERROR)\n\t\t\treturn false; /* seekable and seek fails, reset fails */\n\t}\n\telse\n\t\tdecoder->private_->internal_reset_hack = false;\n\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_METADATA;\n\n\tdecoder->private_->has_stream_info = false;\n\n\tfree(decoder->private_->seek_table.data.seek_table.points);\n\tdecoder->private_->seek_table.data.seek_table.points = 0;\n\tdecoder->private_->has_seek_table = false;\n\n\tdecoder->private_->do_md5_checking = decoder->protected_->md5_checking;\n\t/*\n\t * This goes in reset() and not flush() because according to the spec, a\n\t * fixed-blocksize stream must stay that way through the whole stream.\n\t */\n\tdecoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size = 0;\n\n\t/* We initialize the FLAC__MD5Context even though we may never use it.  This\n\t * is because md5 checking may be turned on to start and then turned off if\n\t * a seek occurs.  So we init the context here and finalize it in\n\t * FLAC__stream_decoder_finish() to make sure things are always cleaned up\n\t * properly.\n\t */\n\tFLAC__MD5Init(&decoder->private_->md5context);\n\n\tdecoder->private_->first_frame_offset = 0;\n\tdecoder->private_->unparseable_frame_count = 0;\n\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__bool got_a_frame;\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\twhile(1) {\n\t\tswitch(decoder->protected_->state) {\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:\n\t\t\t\tif(!find_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_METADATA:\n\t\t\t\tif(!read_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\telse\n\t\t\t\t\treturn true;\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:\n\t\t\t\tif(!frame_sync_(decoder))\n\t\t\t\t\treturn true; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_FRAME:\n\t\t\t\tif(!read_frame_(decoder, &got_a_frame, /*do_full_decode=*/true))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tif(got_a_frame)\n\t\t\t\t\treturn true; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_END_OF_STREAM:\n\t\t\tcase FLAC__STREAM_DECODER_ABORTED:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\twhile(1) {\n\t\tswitch(decoder->protected_->state) {\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:\n\t\t\t\tif(!find_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_METADATA:\n\t\t\t\tif(!read_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:\n\t\t\tcase FLAC__STREAM_DECODER_READ_FRAME:\n\t\t\tcase FLAC__STREAM_DECODER_END_OF_STREAM:\n\t\t\tcase FLAC__STREAM_DECODER_ABORTED:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__bool dummy;\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\twhile(1) {\n\t\tswitch(decoder->protected_->state) {\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:\n\t\t\t\tif(!find_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_METADATA:\n\t\t\t\tif(!read_metadata_(decoder))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:\n\t\t\t\tif(!frame_sync_(decoder))\n\t\t\t\t\treturn true; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_FRAME:\n\t\t\t\tif(!read_frame_(decoder, &dummy, /*do_full_decode=*/true))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_END_OF_STREAM:\n\t\t\tcase FLAC__STREAM_DECODER_ABORTED:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__bool got_a_frame;\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->protected_);\n\n\twhile(1) {\n\t\tswitch(decoder->protected_->state) {\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:\n\t\t\tcase FLAC__STREAM_DECODER_READ_METADATA:\n\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\tcase FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:\n\t\t\t\tif(!frame_sync_(decoder))\n\t\t\t\t\treturn true; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_READ_FRAME:\n\t\t\t\tif(!read_frame_(decoder, &got_a_frame, /*do_full_decode=*/false))\n\t\t\t\t\treturn false; /* above function sets the status for us */\n\t\t\t\tif(got_a_frame)\n\t\t\t\t\treturn true; /* above function sets the status for us */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__STREAM_DECODER_END_OF_STREAM:\n\t\t\tcase FLAC__STREAM_DECODER_ABORTED:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\n\nFLAC_API FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder, FLAC__uint64 sample)\n{\n\tFLAC__uint64 length;\n\n\tFLAC__ASSERT(0 != decoder);\n\n\tif(\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_METADATA &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_READ_METADATA &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_READ_FRAME &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_END_OF_STREAM\n\t)\n\t\treturn false;\n\n\tif(0 == decoder->private_->seek_callback)\n\t\treturn false;\n\n\tFLAC__ASSERT(decoder->private_->seek_callback);\n\tFLAC__ASSERT(decoder->private_->tell_callback);\n\tFLAC__ASSERT(decoder->private_->length_callback);\n\tFLAC__ASSERT(decoder->private_->eof_callback);\n\n\tif(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder))\n\t\treturn false;\n\n\tdecoder->private_->is_seeking = true;\n\n\t/* turn off md5 checking if a seek is attempted */\n\tdecoder->private_->do_md5_checking = false;\n\n\t/* get the file length (currently our algorithm needs to know the length so it's also an error to get FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED) */\n\tif(decoder->private_->length_callback(decoder, &length, decoder->private_->client_data) != FLAC__STREAM_DECODER_LENGTH_STATUS_OK) {\n\t\tdecoder->private_->is_seeking = false;\n\t\treturn false;\n\t}\n\n\t/* if we haven't finished processing the metadata yet, do that so we have the STREAMINFO, SEEK_TABLE, and first_frame_offset */\n\tif(\n\t\tdecoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_METADATA ||\n\t\tdecoder->protected_->state == FLAC__STREAM_DECODER_READ_METADATA\n\t) {\n\t\tif(!FLAC__stream_decoder_process_until_end_of_metadata(decoder)) {\n\t\t\t/* above call sets the state for us */\n\t\t\tdecoder->private_->is_seeking = false;\n\t\t\treturn false;\n\t\t}\n\t\t/* check this again in case we didn't know total_samples the first time */\n\t\tif(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder)) {\n\t\t\tdecoder->private_->is_seeking = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t{\n\t\tconst FLAC__bool ok =\n#if FLAC__HAS_OGG\n\t\t\tdecoder->private_->is_ogg?\n\t\t\tseek_to_absolute_sample_ogg_(decoder, length, sample) :\n#endif\n\t\t\tseek_to_absolute_sample_(decoder, length, sample)\n\t\t;\n\t\tdecoder->private_->is_seeking = false;\n\t\treturn ok;\n\t}\n}\n\n/***********************************************************************\n *\n * Protected class methods\n *\n ***********************************************************************/\n\nunsigned FLAC__stream_decoder_get_input_bytes_unconsumed(const FLAC__StreamDecoder *decoder)\n{\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\tFLAC__ASSERT(!(FLAC__bitreader_get_input_bits_unconsumed(decoder->private_->input) & 7));\n\treturn FLAC__bitreader_get_input_bits_unconsumed(decoder->private_->input) / 8;\n}\n\n/***********************************************************************\n *\n * Private class methods\n *\n ***********************************************************************/\n\nvoid set_defaults_(FLAC__StreamDecoder *decoder)\n{\n\tdecoder->private_->is_ogg = false;\n\tdecoder->private_->read_callback = 0;\n\tdecoder->private_->seek_callback = 0;\n\tdecoder->private_->tell_callback = 0;\n\tdecoder->private_->length_callback = 0;\n\tdecoder->private_->eof_callback = 0;\n\tdecoder->private_->write_callback = 0;\n\tdecoder->private_->metadata_callback = 0;\n\tdecoder->private_->error_callback = 0;\n\tdecoder->private_->client_data = 0;\n\n\tmemset(decoder->private_->metadata_filter, 0, sizeof(decoder->private_->metadata_filter));\n\tdecoder->private_->metadata_filter[FLAC__METADATA_TYPE_STREAMINFO] = true;\n\tdecoder->private_->metadata_filter_ids_count = 0;\n\n\tdecoder->protected_->md5_checking = false;\n\n#if FLAC__HAS_OGG\n\tFLAC__ogg_decoder_aspect_set_defaults(&decoder->protected_->ogg_decoder_aspect);\n#endif\n}\n\n/*\n * This will forcibly set stdin to binary mode (for OSes that require it)\n */\nFILE *get_binary_stdin_(void)\n{\n\t/* if something breaks here it is probably due to the presence or\n\t * absence of an underscore before the identifiers 'setmode',\n\t * 'fileno', and/or 'O_BINARY'; check your system header files.\n\t */\n#if defined _MSC_VER || defined __MINGW32__\n\t_setmode(_fileno(stdin), _O_BINARY);\n#elif defined __CYGWIN__\n\t/* almost certainly not needed for any modern Cygwin, but let's be safe... */\n\tsetmode(_fileno(stdin), _O_BINARY);\n#elif defined __EMX__\n\tsetmode(fileno(stdin), O_BINARY);\n#endif\n\n\treturn stdin;\n}\n\nFLAC__bool allocate_output_(FLAC__StreamDecoder *decoder, unsigned size, unsigned channels)\n{\n\tunsigned i;\n\tFLAC__int32 *tmp;\n\n\tif(size <= decoder->private_->output_capacity && channels <= decoder->private_->output_channels)\n\t\treturn true;\n\n\t/* simply using realloc() is not practical because the number of channels may change mid-stream */\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tif(0 != decoder->private_->output[i]) {\n\t\t\tfree(decoder->private_->output[i]-4);\n\t\t\tdecoder->private_->output[i] = 0;\n\t\t}\n\t\tif(0 != decoder->private_->residual_unaligned[i]) {\n\t\t\tfree(decoder->private_->residual_unaligned[i]);\n\t\t\tdecoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;\n\t\t}\n\t}\n\n\tfor(i = 0; i < channels; i++) {\n\t\t/* WATCHOUT:\n\t\t * FLAC__lpc_restore_signal_asm_ia32_mmx() requires that the\n\t\t * output arrays have a buffer of up to 3 zeroes in front\n\t\t * (at negative indices) for alignment purposes; we use 4\n\t\t * to keep the data well-aligned.\n\t\t */\n\t\ttmp = safe_malloc_muladd2_(sizeof(FLAC__int32), /*times (*/size, /*+*/4/*)*/);\n\t\tif(tmp == 0) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(FLAC__int32)*4);\n\t\tdecoder->private_->output[i] = tmp + 4;\n\n\t\tif(!FLAC__memory_alloc_aligned_int32_array(size, &decoder->private_->residual_unaligned[i], &decoder->private_->residual[i])) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdecoder->private_->output_capacity = size;\n\tdecoder->private_->output_channels = channels;\n\n\treturn true;\n}\n\nFLAC__bool has_id_filtered_(FLAC__StreamDecoder *decoder, FLAC__byte *id)\n{\n\tsize_t i;\n\n\tFLAC__ASSERT(0 != decoder);\n\tFLAC__ASSERT(0 != decoder->private_);\n\n\tfor(i = 0; i < decoder->private_->metadata_filter_ids_count; i++)\n\t\tif(0 == memcmp(decoder->private_->metadata_filter_ids + i * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8)))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nFLAC__bool find_metadata_(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__uint32 x;\n\tunsigned i, id;\n\tFLAC__bool first = true;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tfor(i = id = 0; i < 4; ) {\n\t\tif(decoder->private_->cached) {\n\t\t\tx = (FLAC__uint32)decoder->private_->lookahead;\n\t\t\tdecoder->private_->cached = false;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t}\n\t\tif(x == FLAC__STREAM_SYNC_STRING[i]) {\n\t\t\tfirst = true;\n\t\t\ti++;\n\t\t\tid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(id >= 3)\n\t\t\treturn false;\n\n\t\tif(x == ID3V2_TAG_[id]) {\n\t\t\tid++;\n\t\t\ti = 0;\n\t\t\tif(id == 3) {\n\t\t\t\tif(!skip_id3v2_tag_(decoder))\n\t\t\t\t\treturn false; /* skip_id3v2_tag_ sets the state for us */\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tid = 0;\n\t\tif(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */\n\t\t\tdecoder->private_->header_warmup[0] = (FLAC__byte)x;\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\t/* we have to check if we just read two 0xff's in a row; the second may actually be the beginning of the sync code */\n\t\t\t/* else we have to check if the second byte is the end of a sync code */\n\t\t\tif(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */\n\t\t\t\tdecoder->private_->lookahead = (FLAC__byte)x;\n\t\t\t\tdecoder->private_->cached = true;\n\t\t\t}\n\t\t\telse if(x >> 1 == 0x7c) { /* MAGIC NUMBER for the last 6 sync bits and reserved 7th bit */\n\t\t\t\tdecoder->private_->header_warmup[1] = (FLAC__byte)x;\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_READ_FRAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\ti = 0;\n\t\tif(first) {\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_READ_METADATA;\n\treturn true;\n}\n\nFLAC__bool read_metadata_(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__bool is_last;\n\tFLAC__uint32 i, x, type, length;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_IS_LAST_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tis_last = x? true : false;\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &type, FLAC__STREAM_METADATA_TYPE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &length, FLAC__STREAM_METADATA_LENGTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tif(type == FLAC__METADATA_TYPE_STREAMINFO) {\n\t\tif(!read_metadata_streaminfo_(decoder, is_last, length))\n\t\t\treturn false;\n\n\t\tdecoder->private_->has_stream_info = true;\n\t\tif(0 == memcmp(decoder->private_->stream_info.data.stream_info.md5sum, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", 16))\n\t\t\tdecoder->private_->do_md5_checking = false;\n\t\tif(!decoder->private_->is_seeking && decoder->private_->metadata_filter[FLAC__METADATA_TYPE_STREAMINFO] && decoder->private_->metadata_callback)\n\t\t\tdecoder->private_->metadata_callback(decoder, &decoder->private_->stream_info, decoder->private_->client_data);\n\t}\n\telse if(type == FLAC__METADATA_TYPE_SEEKTABLE) {\n\t\t/* just in case we already have a seek table, and reading the next one fails: */\n\t\tdecoder->private_->has_seek_table = false;\n\n\t\tif(!read_metadata_seektable_(decoder, is_last, length))\n\t\t\treturn false;\n\n\t\tdecoder->private_->has_seek_table = true;\n\t\tif(!decoder->private_->is_seeking && decoder->private_->metadata_filter[FLAC__METADATA_TYPE_SEEKTABLE] && decoder->private_->metadata_callback)\n\t\t\tdecoder->private_->metadata_callback(decoder, &decoder->private_->seek_table, decoder->private_->client_data);\n\t}\n\telse {\n\t\tFLAC__bool skip_it = !decoder->private_->metadata_filter[type];\n\t\tunsigned real_length = length;\n\t\tFLAC__StreamMetadata block;\n\n\t\tmemset(&block, 0, sizeof(block));\n\t\tblock.is_last = is_last;\n\t\tblock.type = (FLAC__MetadataType)type;\n\t\tblock.length = length;\n\n\t\tif(type == FLAC__METADATA_TYPE_APPLICATION) {\n\t\t\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.application.id, FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\tif(real_length < FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8) { /* underflow check */\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;/*@@@@@@ maybe wrong error? need to resync?*/\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treal_length -= FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8;\n\n\t\t\tif(decoder->private_->metadata_filter_ids_count > 0 && has_id_filtered_(decoder, block.data.application.id))\n\t\t\t\tskip_it = !skip_it;\n\t\t}\n\n\t\tif(skip_it) {\n\t\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, real_length))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t}\n\t\telse {\n\t\t\tFLAC__bool ok = true;\n\t\t\tswitch(type) {\n\t\t\t\tcase FLAC__METADATA_TYPE_PADDING:\n\t\t\t\t\t/* skip the padding bytes */\n\t\t\t\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, real_length))\n\t\t\t\t\t\tok = false; /* read_callback_ sets the state for us */\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_APPLICATION:\n\t\t\t\t\t/* remember, we read the ID already */\n\t\t\t\t\tif(real_length > 0) {\n\t\t\t\t\t\tif(0 == (block.data.application.data = malloc(real_length))) {\n\t\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.application.data, real_length))\n\t\t\t\t\t\t\tok = false; /* read_callback_ sets the state for us */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tblock.data.application.data = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT:\n\t\t\t\t\tif(!read_metadata_vorbiscomment_(decoder, &block.data.vorbis_comment, real_length))\n\t\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_CUESHEET:\n\t\t\t\t\tif(!read_metadata_cuesheet_(decoder, &block.data.cue_sheet))\n\t\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_PICTURE:\n\t\t\t\t\tif(!read_metadata_picture_(decoder, &block.data.picture))\n\t\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_STREAMINFO:\n\t\t\t\tcase FLAC__METADATA_TYPE_SEEKTABLE:\n\t\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif(real_length > 0) {\n\t\t\t\t\t\tif(0 == (block.data.unknown.data = malloc(real_length))) {\n\t\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.unknown.data, real_length))\n\t\t\t\t\t\t\tok = false; /* read_callback_ sets the state for us */\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tblock.data.unknown.data = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok && !decoder->private_->is_seeking && decoder->private_->metadata_callback)\n\t\t\t\tdecoder->private_->metadata_callback(decoder, &block, decoder->private_->client_data);\n\n\t\t\t/* now we have to free any malloc()ed data in the block */\n\t\t\tswitch(type) {\n\t\t\t\tcase FLAC__METADATA_TYPE_PADDING:\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_APPLICATION:\n\t\t\t\t\tif(0 != block.data.application.data)\n\t\t\t\t\t\tfree(block.data.application.data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT:\n\t\t\t\t\tif(0 != block.data.vorbis_comment.vendor_string.entry)\n\t\t\t\t\t\tfree(block.data.vorbis_comment.vendor_string.entry);\n\t\t\t\t\tif(block.data.vorbis_comment.num_comments > 0)\n\t\t\t\t\t\tfor(i = 0; i < block.data.vorbis_comment.num_comments; i++)\n\t\t\t\t\t\t\tif(0 != block.data.vorbis_comment.comments[i].entry)\n\t\t\t\t\t\t\t\tfree(block.data.vorbis_comment.comments[i].entry);\n\t\t\t\t\tif(0 != block.data.vorbis_comment.comments)\n\t\t\t\t\t\tfree(block.data.vorbis_comment.comments);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_CUESHEET:\n\t\t\t\t\tif(block.data.cue_sheet.num_tracks > 0)\n\t\t\t\t\t\tfor(i = 0; i < block.data.cue_sheet.num_tracks; i++)\n\t\t\t\t\t\t\tif(0 != block.data.cue_sheet.tracks[i].indices)\n\t\t\t\t\t\t\t\tfree(block.data.cue_sheet.tracks[i].indices);\n\t\t\t\t\tif(0 != block.data.cue_sheet.tracks)\n\t\t\t\t\t\tfree(block.data.cue_sheet.tracks);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_PICTURE:\n\t\t\t\t\tif(0 != block.data.picture.mime_type)\n\t\t\t\t\t\tfree(block.data.picture.mime_type);\n\t\t\t\t\tif(0 != block.data.picture.description)\n\t\t\t\t\t\tfree(block.data.picture.description);\n\t\t\t\t\tif(0 != block.data.picture.data)\n\t\t\t\t\t\tfree(block.data.picture.data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__METADATA_TYPE_STREAMINFO:\n\t\t\t\tcase FLAC__METADATA_TYPE_SEEKTABLE:\n\t\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\tdefault:\n\t\t\t\t\tif(0 != block.data.unknown.data)\n\t\t\t\t\t\tfree(block.data.unknown.data);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(!ok) /* anything that unsets \"ok\" should also make sure decoder->protected_->state is updated */\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif(is_last) {\n\t\t/* if this fails, it's OK, it's just a hint for the seek routine */\n\t\tif(!FLAC__stream_decoder_get_decode_position(decoder, &decoder->private_->first_frame_offset))\n\t\t\tdecoder->private_->first_frame_offset = 0;\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_metadata_streaminfo_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length)\n{\n\tFLAC__uint32 x;\n\tunsigned bits, used_bits = 0;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tdecoder->private_->stream_info.type = FLAC__METADATA_TYPE_STREAMINFO;\n\tdecoder->private_->stream_info.is_last = is_last;\n\tdecoder->private_->stream_info.length = length;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, bits))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.min_blocksize = x;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.max_blocksize = x;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.min_framesize = x;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.max_framesize = x;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.sample_rate = x;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.channels = x+1;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN;\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tdecoder->private_->stream_info.data.stream_info.bits_per_sample = x+1;\n\tused_bits += bits;\n\n\tbits = FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN;\n\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &decoder->private_->stream_info.data.stream_info.total_samples, FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tused_bits += bits;\n\n\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, decoder->private_->stream_info.data.stream_info.md5sum, 16))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tused_bits += 16*8;\n\n\t/* skip the rest of the block */\n\tFLAC__ASSERT(used_bits % 8 == 0);\n\tlength -= (used_bits / 8);\n\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\treturn true;\n}\n\nFLAC__bool read_metadata_seektable_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length)\n{\n\tFLAC__uint32 i, x;\n\tFLAC__uint64 xx;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tdecoder->private_->seek_table.type = FLAC__METADATA_TYPE_SEEKTABLE;\n\tdecoder->private_->seek_table.is_last = is_last;\n\tdecoder->private_->seek_table.length = length;\n\n\tdecoder->private_->seek_table.data.seek_table.num_points = length / FLAC__STREAM_METADATA_SEEKPOINT_LENGTH;\n\n\t/* use realloc since we may pass through here several times (e.g. after seeking) */\n\tif(0 == (decoder->private_->seek_table.data.seek_table.points = safe_realloc_mul_2op_(decoder->private_->seek_table.data.seek_table.points, decoder->private_->seek_table.data.seek_table.num_points, /*times*/sizeof(FLAC__StreamMetadata_SeekPoint)))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tfor(i = 0; i < decoder->private_->seek_table.data.seek_table.num_points; i++) {\n\t\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].sample_number = xx;\n\n\t\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].stream_offset = xx;\n\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].frame_samples = x;\n\t}\n\tlength -= (decoder->private_->seek_table.data.seek_table.num_points * FLAC__STREAM_METADATA_SEEKPOINT_LENGTH);\n\t/* if there is a partial point left, skip over it */\n\tif(length > 0) {\n\t\t/*@@@ do a send_error_to_client_() here?  there's an argument for either way */\n\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj, unsigned length)\n{\n\tFLAC__uint32 i;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\t/* read vendor string */\n\tif (length >= 8) {\n\t\tlength -= 8; /* vendor string length + num comments entries alone take 8 bytes */\n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->vendor_string.length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif (obj->vendor_string.length > 0) {\n\t\t\tif (length < obj->vendor_string.length) {\n\t\t\t\tobj->vendor_string.length = 0;\n\t\t\t\tobj->vendor_string.entry = 0;\n\t\t\t\tgoto skip;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlength -= obj->vendor_string.length;\n\t\t\tif (0 == (obj->vendor_string.entry = safe_malloc_add_2op_(obj->vendor_string.length, /*+*/1))) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->vendor_string.entry, obj->vendor_string.length))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tobj->vendor_string.entry[obj->vendor_string.length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tobj->vendor_string.entry = 0;\n\n\t\t/* read num comments */\n\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN == 32);\n\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->num_comments))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t/* read comments */\n\t\tif (obj->num_comments > 100000) {\n\t\t\t/* Possibly malicious file. */\n\t\t\tobj->num_comments = 0;\n\t\t\treturn false;\n\t\t}\n\t\tif (obj->num_comments > 0) {\n\t\t\tif (0 == (obj->comments = safe_malloc_mul_2op_p(obj->num_comments, /*times*/sizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) {\n\t\t\t\tobj->num_comments = 0;\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (i = 0; i < obj->num_comments; i++) {\n\t\t\t\t/* Initialize here just to make sure. */\n\t\t\t\tobj->comments[i].length = 0;\n\t\t\t\tobj->comments[i].entry = 0;\n\n\t\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);\n\t\t\t\tif (length < 4) {\n\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlength -= 4;\n\t\t\t\tif (!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->comments[i].length)) {\n\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\t\t}\n\t\t\t\tif (obj->comments[i].length > 0) {\n\t\t\t\t\tif (length < obj->comments[i].length) {\n\t\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\t\tgoto skip;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlength -= obj->comments[i].length;\n\t\t\t\t\tif (0 == (obj->comments[i].entry = safe_malloc_add_2op_(obj->comments[i].length, /*+*/1))) {\n\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tmemset (obj->comments[i].entry, 0, obj->comments[i].length) ;\n\t\t\t\t\tif (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->comments[i].entry, obj->comments[i].length)) {\n\t\t\t\t\t\tobj->num_comments = i;\n\t\t\t\t\t\tgoto skip;\n\t\t\t\t\t}\n\t\t\t\t\tobj->comments[i].entry[obj->comments[i].length] = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tobj->comments[i].entry = 0;\n\t\t\t}\n\t\t}\n\t}\n\n  skip:\n\tif (length > 0) {\n\t\t/* length > 0 can only happen on files with invalid data in comments */\n\t\tif(obj->num_comments < 1) {\n\t\t\tfree(obj->comments);\n\t\t\tobj->comments = NULL;\n\t\t}\n\t\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_metadata_cuesheet_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_CueSheet *obj)\n{\n\tFLAC__uint32 i, j, x;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tmemset(obj, 0, sizeof(FLAC__StreamMetadata_CueSheet));\n\n\tFLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN % 8 == 0);\n\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)obj->media_catalog_number, FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN/8))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &obj->lead_in, FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tobj->is_cd = x? true : false;\n\n\tif(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tobj->num_tracks = x;\n\n\tif(obj->num_tracks > 0) {\n\t\tif(0 == (obj->tracks = safe_calloc_(obj->num_tracks, sizeof(FLAC__StreamMetadata_CueSheet_Track)))) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tfor(i = 0; i < obj->num_tracks; i++) {\n\t\t\tFLAC__StreamMetadata_CueSheet_Track *track = &obj->tracks[i];\n\t\t\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &track->offset, FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\ttrack->number = (FLAC__byte)x;\n\n\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN % 8 == 0);\n\t\t\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)track->isrc, FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN/8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\ttrack->type = x;\n\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\ttrack->pre_emphasis = x;\n\n\t\t\tif(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\ttrack->num_indices = (FLAC__byte)x;\n\n\t\t\tif(track->num_indices > 0) {\n\t\t\t\tif(0 == (track->indices = safe_calloc_(track->num_indices, sizeof(FLAC__StreamMetadata_CueSheet_Index)))) {\n\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor(j = 0; j < track->num_indices; j++) {\n\t\t\t\t\tFLAC__StreamMetadata_CueSheet_Index *indx = &track->indices[j];\n\t\t\t\t\tif(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &indx->offset, FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN))\n\t\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN))\n\t\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\t\t\tindx->number = (FLAC__byte)x;\n\n\t\t\t\t\tif(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN))\n\t\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_metadata_picture_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_Picture *obj)\n{\n\tFLAC__uint32 x;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\t/* read type */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_TYPE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tobj->type = x;\n\n\t/* read MIME type */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(0 == (obj->mime_type = safe_malloc_add_2op_(x, /*+*/1))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(x > 0) {\n\t\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)obj->mime_type, x))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\tobj->mime_type[x] = '\\0';\n\n\t/* read description */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(0 == (obj->description = safe_malloc_add_2op_(x, /*+*/1))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(x > 0) {\n\t\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->description, x))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\tobj->description[x] = '\\0';\n\n\t/* read width */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->width, FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\t/* read height */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->height, FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\t/* read depth */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->depth, FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\t/* read colors */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->colors, FLAC__STREAM_METADATA_PICTURE_COLORS_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\t/* read data */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &(obj->data_length), FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(0 == (obj->data = safe_malloc_(obj->data_length))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(obj->data_length > 0) {\n\t\tif(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->data, obj->data_length))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\n\treturn true;\n}\n\nFLAC__bool skip_id3v2_tag_(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__uint32 x;\n\tunsigned i, skip;\n\n\t/* skip the version and flags bytes */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 24))\n\t\treturn false; /* read_callback_ sets the state for us */\n\t/* get the size (in bytes) to skip */\n\tskip = 0;\n\tfor(i = 0; i < 4; i++) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tskip <<= 7;\n\t\tskip |= (x & 0x7f);\n\t}\n\t/* skip the rest of the tag */\n\tif(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, skip))\n\t\treturn false; /* read_callback_ sets the state for us */\n\treturn true;\n}\n\nFLAC__bool frame_sync_(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__uint32 x;\n\tFLAC__bool first = true;\n\n\t/* If we know the total number of samples in the stream, stop if we've read that many. */\n\t/* This will stop us, for example, from wasting time trying to sync on an ID3V1 tag. */\n\tif(FLAC__stream_decoder_get_total_samples(decoder) > 0) {\n\t\tif(decoder->private_->samples_decoded >= FLAC__stream_decoder_get_total_samples(decoder)) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* make sure we're byte aligned */\n\tif(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input)) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__bitreader_bits_left_for_byte_alignment(decoder->private_->input)))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t}\n\n\twhile(1) {\n\t\tif(decoder->private_->cached) {\n\t\t\tx = (FLAC__uint32)decoder->private_->lookahead;\n\t\t\tdecoder->private_->cached = false;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t}\n\t\tif(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */\n\t\t\tdecoder->private_->header_warmup[0] = (FLAC__byte)x;\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\n\t\t\t/* we have to check if we just read two 0xff's in a row; the second may actually be the beginning of the sync code */\n\t\t\t/* else we have to check if the second byte is the end of a sync code */\n\t\t\tif(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */\n\t\t\t\tdecoder->private_->lookahead = (FLAC__byte)x;\n\t\t\t\tdecoder->private_->cached = true;\n\t\t\t}\n\t\t\telse if(x >> 1 == 0x7c) { /* MAGIC NUMBER for the last 6 sync bits and reserved 7th bit */\n\t\t\t\tdecoder->private_->header_warmup[1] = (FLAC__byte)x;\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_READ_FRAME;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif(first) {\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_frame_(FLAC__StreamDecoder *decoder, FLAC__bool *got_a_frame, FLAC__bool do_full_decode)\n{\n\tunsigned channel;\n\tunsigned i;\n\tFLAC__int32 mid, side;\n\tunsigned frame_crc; /* the one we calculate from the input stream */\n\tFLAC__uint32 x;\n\n\t*got_a_frame = false;\n\n\t/* init the CRC */\n\tframe_crc = 0;\n\tframe_crc = FLAC__CRC16_UPDATE(decoder->private_->header_warmup[0], frame_crc);\n\tframe_crc = FLAC__CRC16_UPDATE(decoder->private_->header_warmup[1], frame_crc);\n\tFLAC__bitreader_reset_read_crc16(decoder->private_->input, (FLAC__uint16)frame_crc);\n\n\tif(!read_frame_header_(decoder))\n\t\treturn false;\n\tif(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means we didn't sync on a valid header */\n\t\treturn true;\n\tif(!allocate_output_(decoder, decoder->private_->frame.header.blocksize, decoder->private_->frame.header.channels))\n\t\treturn false;\n\tfor(channel = 0; channel < decoder->private_->frame.header.channels; channel++) {\n\t\t/*\n\t\t * first figure the correct bits-per-sample of the subframe\n\t\t */\n\t\tunsigned bps = decoder->private_->frame.header.bits_per_sample;\n\t\tswitch(decoder->private_->frame.header.channel_assignment) {\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:\n\t\t\t\t/* no adjustment needed */\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:\n\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\tif(channel == 1)\n\t\t\t\t\tbps++;\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:\n\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\tif(channel == 0)\n\t\t\t\t\tbps++;\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:\n\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\tif(channel == 1)\n\t\t\t\t\tbps++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t}\n\t\t/*\n\t\t * now read it\n\t\t */\n\t\tif(!read_subframe_(decoder, channel, bps, do_full_decode))\n\t\t\treturn false;\n\t\tif(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */\n\t\t\treturn true;\n\t}\n\tif(!read_zero_padding_(decoder))\n\t\treturn false;\n\tif(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption (i.e. \"zero bits\" were not all zeroes) */\n\t\treturn true;\n\n\t/*\n\t * Read the frame CRC-16 from the footer and check\n\t */\n\tframe_crc = FLAC__bitreader_get_read_crc16(decoder->private_->input);\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__FRAME_FOOTER_CRC_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(frame_crc == x) {\n\t\tif(do_full_decode) {\n\t\t\t/* Undo any special channel coding */\n\t\t\tswitch(decoder->private_->frame.header.channel_assignment) {\n\t\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:\n\t\t\t\t\t/* do nothing */\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:\n\t\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\t\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++)\n\t\t\t\t\t\tdecoder->private_->output[1][i] = decoder->private_->output[0][i] - decoder->private_->output[1][i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:\n\t\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\t\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++)\n\t\t\t\t\t\tdecoder->private_->output[0][i] += decoder->private_->output[1][i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:\n\t\t\t\t\tFLAC__ASSERT(decoder->private_->frame.header.channels == 2);\n\t\t\t\t\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++) {\n#if 1\n\t\t\t\t\t\tmid = decoder->private_->output[0][i];\n\t\t\t\t\t\tside = decoder->private_->output[1][i];\n\t\t\t\t\t\tmid = ((uint32_t) mid) << 1;\n\t\t\t\t\t\tmid |= (side & 1); /* i.e. if 'side' is odd... */\n\t\t\t\t\t\tdecoder->private_->output[0][i] = (mid + side) >> 1;\n\t\t\t\t\t\tdecoder->private_->output[1][i] = (mid - side) >> 1;\n#else\n\t\t\t\t\t\t/* OPT: without 'side' temp variable */\n\t\t\t\t\t\tmid = (decoder->private_->output[0][i] << 1) | (decoder->private_->output[1][i] & 1); /* i.e. if 'side' is odd... */\n\t\t\t\t\t\tdecoder->private_->output[0][i] = (mid + decoder->private_->output[1][i]) >> 1;\n\t\t\t\t\t\tdecoder->private_->output[1][i] = (mid - decoder->private_->output[1][i]) >> 1;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t/* Bad frame, emit error and zero the output signal */\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH);\n\t\tif(do_full_decode) {\n\t\t\tfor(channel = 0; channel < decoder->private_->frame.header.channels; channel++) {\n\t\t\t\tmemset(decoder->private_->output[channel], 0, sizeof(FLAC__int32) * decoder->private_->frame.header.blocksize);\n\t\t\t}\n\t\t}\n\t}\n\n\t*got_a_frame = true;\n\n\t/* we wait to update fixed_block_size until here, when we're sure we've got a proper frame and hence a correct blocksize */\n\tif(decoder->private_->next_fixed_block_size)\n\t\tdecoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size;\n\n\t/* put the latest values into the public section of the decoder instance */\n\tdecoder->protected_->channels = decoder->private_->frame.header.channels;\n\tdecoder->protected_->channel_assignment = decoder->private_->frame.header.channel_assignment;\n\tdecoder->protected_->bits_per_sample = decoder->private_->frame.header.bits_per_sample;\n\tdecoder->protected_->sample_rate = decoder->private_->frame.header.sample_rate;\n\tdecoder->protected_->blocksize = decoder->private_->frame.header.blocksize;\n\n\tFLAC__ASSERT(decoder->private_->frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n\tdecoder->private_->samples_decoded = decoder->private_->frame.header.number.sample_number + decoder->private_->frame.header.blocksize;\n\n\t/* write it */\n\tif(do_full_decode) {\n\t\tif(write_audio_frame_to_client_(decoder, &decoder->private_->frame, (const FLAC__int32 * const *)decoder->private_->output) != FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\treturn true;\n}\n\nFLAC__bool read_frame_header_(FLAC__StreamDecoder *decoder)\n{\n\tFLAC__uint32 x;\n\tFLAC__uint64 xx;\n\tunsigned i, blocksize_hint = 0, sample_rate_hint = 0;\n\tFLAC__byte crc8, raw_header[16]; /* MAGIC NUMBER based on the maximum frame header size, including CRC */\n\tunsigned raw_header_len;\n\tFLAC__bool is_unparseable = false;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\t/* init the raw header with the saved bits from synchronization */\n\traw_header[0] = decoder->private_->header_warmup[0];\n\traw_header[1] = decoder->private_->header_warmup[1];\n\traw_header_len = 2;\n\n\t/* check to make sure that reserved bit is 0 */\n\tif(raw_header[1] & 0x02) /* MAGIC NUMBER */\n\t\tis_unparseable = true;\n\n\t/*\n\t * Note that along the way as we read the header, we look for a sync\n\t * code inside.  If we find one it would indicate that our original\n\t * sync was bad since there cannot be a sync code in a valid header.\n\t *\n\t * Three kinds of things can go wrong when reading the frame header:\n\t *  1) We may have sync'ed incorrectly and not landed on a frame header.\n\t *     If we don't find a sync code, it can end up looking like we read\n\t *     a valid but unparseable header, until getting to the frame header\n\t *     CRC.  Even then we could get a false positive on the CRC.\n\t *  2) We may have sync'ed correctly but on an unparseable frame (from a\n\t *     future encoder).\n\t *  3) We may be on a damaged frame which appears valid but unparseable.\n\t *\n\t * For all these reasons, we try and read a complete frame header as\n\t * long as it seems valid, even if unparseable, up until the frame\n\t * header CRC.\n\t */\n\n\t/*\n\t * read in the raw header as bytes so we can CRC it, and parse it on the way\n\t */\n\tfor(i = 0; i < 2; i++) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */\n\t\t\t/* if we get here it means our original sync was erroneous since the sync code cannot appear in the header */\n\t\t\tdecoder->private_->lookahead = (FLAC__byte)x;\n\t\t\tdecoder->private_->cached = true;\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t\t}\n\t\traw_header[raw_header_len++] = (FLAC__byte)x;\n\t}\n\n\tswitch(x = raw_header[2] >> 4) {\n\t\tcase 0:\n\t\t\tis_unparseable = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdecoder->private_->frame.header.blocksize = 192;\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tdecoder->private_->frame.header.blocksize = 576 << (x-2);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tblocksize_hint = x;\n\t\t\tbreak;\n\t\tcase 8:\n\t\tcase 9:\n\t\tcase 10:\n\t\tcase 11:\n\t\tcase 12:\n\t\tcase 13:\n\t\tcase 14:\n\t\tcase 15:\n\t\t\tdecoder->private_->frame.header.blocksize = 256 << (x-8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t\t\tbreak;\n\t}\n\n\tswitch(x = raw_header[2] & 0x0f) {\n\t\tcase 0:\n\t\t\tif(decoder->private_->has_stream_info)\n\t\t\t\tdecoder->private_->frame.header.sample_rate = decoder->private_->stream_info.data.stream_info.sample_rate;\n\t\t\telse\n\t\t\t\tis_unparseable = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdecoder->private_->frame.header.sample_rate = 88200;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdecoder->private_->frame.header.sample_rate = 176400;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdecoder->private_->frame.header.sample_rate = 192000;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdecoder->private_->frame.header.sample_rate = 8000;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdecoder->private_->frame.header.sample_rate = 16000;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdecoder->private_->frame.header.sample_rate = 22050;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tdecoder->private_->frame.header.sample_rate = 24000;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdecoder->private_->frame.header.sample_rate = 32000;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tdecoder->private_->frame.header.sample_rate = 44100;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tdecoder->private_->frame.header.sample_rate = 48000;\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tdecoder->private_->frame.header.sample_rate = 96000;\n\t\t\tbreak;\n\t\tcase 12:\n\t\tcase 13:\n\t\tcase 14:\n\t\t\tsample_rate_hint = x;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\tx = (unsigned)(raw_header[3] >> 4);\n\tif(x & 8) {\n\t\tdecoder->private_->frame.header.channels = 2;\n\t\tswitch(x & 7) {\n\t\t\tcase 0:\n\t\t\t\tdecoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdecoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdecoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_MID_SIDE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tis_unparseable = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tdecoder->private_->frame.header.channels = (unsigned)x + 1;\n\t\tdecoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;\n\t}\n\n\tswitch(x = (unsigned)(raw_header[3] & 0x0e) >> 1) {\n\t\tcase 0:\n\t\t\tif(decoder->private_->has_stream_info)\n\t\t\t\tdecoder->private_->frame.header.bits_per_sample = decoder->private_->stream_info.data.stream_info.bits_per_sample;\n\t\t\telse\n\t\t\t\tis_unparseable = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdecoder->private_->frame.header.bits_per_sample = 8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdecoder->private_->frame.header.bits_per_sample = 12;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdecoder->private_->frame.header.bits_per_sample = 16;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdecoder->private_->frame.header.bits_per_sample = 20;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdecoder->private_->frame.header.bits_per_sample = 24;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 7:\n\t\t\tis_unparseable = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t\t\tbreak;\n\t}\n\n\t/* check to make sure that reserved bit is 0 */\n\tif(raw_header[3] & 0x01) /* MAGIC NUMBER */\n\t\tis_unparseable = true;\n\n\t/* read the frame's starting sample number (or frame number as the case may be) */\n\tif(\n\t\traw_header[1] & 0x01 ||\n\t\t/*@@@ this clause is a concession to the old way of doing variable blocksize; the only known implementation is flake and can probably be removed without inconveniencing anyone */\n\t\t(decoder->private_->has_stream_info && decoder->private_->stream_info.data.stream_info.min_blocksize != decoder->private_->stream_info.data.stream_info.max_blocksize)\n\t) { /* variable blocksize */\n\t\tif(!FLAC__bitreader_read_utf8_uint64(decoder->private_->input, &xx, raw_header, &raw_header_len))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif(xx == FLAC__U64L(0xffffffffffffffff)) { /* i.e. non-UTF8 code... */\n\t\t\tdecoder->private_->lookahead = raw_header[raw_header_len-1]; /* back up as much as we can */\n\t\t\tdecoder->private_->cached = true;\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t\t}\n\t\tdecoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER;\n\t\tdecoder->private_->frame.header.number.sample_number = xx;\n\t}\n\telse { /* fixed blocksize */\n\t\tif(!FLAC__bitreader_read_utf8_uint32(decoder->private_->input, &x, raw_header, &raw_header_len))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif(x == 0xffffffff) { /* i.e. non-UTF8 code... */\n\t\t\tdecoder->private_->lookahead = raw_header[raw_header_len-1]; /* back up as much as we can */\n\t\t\tdecoder->private_->cached = true;\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t\t}\n\t\tdecoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER;\n\t\tdecoder->private_->frame.header.number.frame_number = x;\n\t}\n\n\tif(blocksize_hint) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\traw_header[raw_header_len++] = (FLAC__byte)x;\n\t\tif(blocksize_hint == 7) {\n\t\t\tFLAC__uint32 _x;\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &_x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\traw_header[raw_header_len++] = (FLAC__byte)_x;\n\t\t\tx = (x << 8) | _x;\n\t\t}\n\t\tdecoder->private_->frame.header.blocksize = x+1;\n\t}\n\n\tif(sample_rate_hint) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\traw_header[raw_header_len++] = (FLAC__byte)x;\n\t\tif(sample_rate_hint != 12) {\n\t\t\tFLAC__uint32 _x;\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &_x, 8))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\traw_header[raw_header_len++] = (FLAC__byte)_x;\n\t\t\tx = (x << 8) | _x;\n\t\t}\n\t\tif(sample_rate_hint == 12)\n\t\t\tdecoder->private_->frame.header.sample_rate = x*1000;\n\t\telse if(sample_rate_hint == 13)\n\t\t\tdecoder->private_->frame.header.sample_rate = x;\n\t\telse\n\t\t\tdecoder->private_->frame.header.sample_rate = x*10;\n\t}\n\n\t/* read the CRC-8 byte */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tcrc8 = (FLAC__byte)x;\n\n\tif(FLAC__crc8(raw_header, raw_header_len) != crc8) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\n\t/* calculate the sample number from the frame number if needed */\n\tdecoder->private_->next_fixed_block_size = 0;\n\tif(decoder->private_->frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER) {\n\t\tx = decoder->private_->frame.header.number.frame_number;\n\t\tdecoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER;\n\t\tif(decoder->private_->fixed_block_size)\n\t\t\tdecoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->fixed_block_size * (FLAC__uint64)x;\n\t\telse if(decoder->private_->has_stream_info) {\n\t\t\tif(decoder->private_->stream_info.data.stream_info.min_blocksize == decoder->private_->stream_info.data.stream_info.max_blocksize) {\n\t\t\t\tdecoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->stream_info.data.stream_info.min_blocksize * (FLAC__uint64)x;\n\t\t\t\tdecoder->private_->next_fixed_block_size = decoder->private_->stream_info.data.stream_info.max_blocksize;\n\t\t\t}\n\t\t\telse\n\t\t\t\tis_unparseable = true;\n\t\t}\n\t\telse if(x == 0) {\n\t\t\tdecoder->private_->frame.header.number.sample_number = 0;\n\t\t\tdecoder->private_->next_fixed_block_size = decoder->private_->frame.header.blocksize;\n\t\t}\n\t\telse {\n\t\t\t/* can only get here if the stream has invalid frame numbering and no STREAMINFO, so assume it's not the last (possibly short) frame */\n\t\t\tdecoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->frame.header.blocksize * (FLAC__uint64)x;\n\t\t}\n\t}\n\n\tif(is_unparseable) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_subframe_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)\n{\n\tFLAC__uint32 x;\n\tFLAC__bool wasted_bits;\n\tunsigned i;\n\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8)) /* MAGIC NUMBER */\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\twasted_bits = (x & 1);\n\tx &= 0xfe;\n\n\tif(wasted_bits) {\n\t\tunsigned u;\n\t\tif(!FLAC__bitreader_read_unary_unsigned(decoder->private_->input, &u))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->frame.subframes[channel].wasted_bits = u+1;\n\t\tif (decoder->private_->frame.subframes[channel].wasted_bits >= bps)\n\t\t\treturn false;\n\t\tbps -= decoder->private_->frame.subframes[channel].wasted_bits;\n\t}\n\telse\n\t\tdecoder->private_->frame.subframes[channel].wasted_bits = 0;\n\n\t/*\n\t * Lots of magic numbers here\n\t */\n\tif(x & 0x80) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\telse if(x == 0) {\n\t\tif(!read_subframe_constant_(decoder, channel, bps, do_full_decode))\n\t\t\treturn false;\n\t}\n\telse if(x == 2) {\n\t\tif(!read_subframe_verbatim_(decoder, channel, bps, do_full_decode))\n\t\t\treturn false;\n\t}\n\telse if(x < 16) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\telse if(x <= 24) {\n\t\tif(!read_subframe_fixed_(decoder, channel, bps, (x>>1)&7, do_full_decode))\n\t\t\treturn false;\n\t\tif(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */\n\t\t\treturn true;\n\t}\n\telse if(x < 64) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\telse {\n\t\tif(!read_subframe_lpc_(decoder, channel, bps, ((x>>1)&31)+1, do_full_decode))\n\t\t\treturn false;\n\t\tif(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */\n\t\t\treturn true;\n\t}\n\n\tif(wasted_bits && do_full_decode) {\n\t\tx = decoder->private_->frame.subframes[channel].wasted_bits;\n\t\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++) {\n\t\t\tuint32_t val = decoder->private_->output[channel][i];\n\t\t\tdecoder->private_->output[channel][i] = (val << x);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_subframe_constant_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)\n{\n\tFLAC__Subframe_Constant *subframe = &decoder->private_->frame.subframes[channel].data.constant;\n\tFLAC__int32 x;\n\tunsigned i;\n\tFLAC__int32 *output = decoder->private_->output[channel];\n\n\tdecoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_CONSTANT;\n\n\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &x, bps))\n\t\treturn false; /* read_callback_ sets the state for us */\n\n\tsubframe->value = x;\n\n\t/* decode the subframe */\n\tif(do_full_decode) {\n\t\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++)\n\t\t\toutput[i] = x;\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_subframe_fixed_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode)\n{\n\tFLAC__Subframe_Fixed *subframe = &decoder->private_->frame.subframes[channel].data.fixed;\n\tFLAC__int32 i32;\n\tFLAC__uint32 u32;\n\tunsigned u;\n\n\tdecoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_FIXED;\n\n\tsubframe->residual = decoder->private_->residual[channel];\n\tsubframe->order = order;\n\n\t/* read warm-up samples */\n\tfor(u = 0; u < order; u++) {\n\t\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, bps))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tsubframe->warmup[u] = i32;\n\t}\n\n\t/* read entropy coding method info */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tsubframe->entropy_coding_method.type = (FLAC__EntropyCodingMethodType)u32;\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tif(decoder->private_->frame.header.blocksize >> u32 < order) {\n\t\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.order = u32;\n\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents = &decoder->private_->partitioned_rice_contents[channel];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t}\n\n\t/* read residual */\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!read_residual_partitioned_rice_(decoder, order, subframe->entropy_coding_method.data.partitioned_rice.order, &decoder->private_->partitioned_rice_contents[channel], decoder->private_->residual[channel], /*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\t/* decode the subframe */\n\tif(do_full_decode) {\n\t\tmemcpy(decoder->private_->output[channel], subframe->warmup, sizeof(FLAC__int32) * order);\n\t\tFLAC__fixed_restore_signal(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, order, decoder->private_->output[channel]+order);\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_subframe_lpc_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode)\n{\n\tFLAC__Subframe_LPC *subframe = &decoder->private_->frame.subframes[channel].data.lpc;\n\tFLAC__int32 i32;\n\tFLAC__uint32 u32;\n\tunsigned u;\n\n\tdecoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_LPC;\n\n\tsubframe->residual = decoder->private_->residual[channel];\n\tsubframe->order = order;\n\n\t/* read warm-up samples */\n\tfor(u = 0; u < order; u++) {\n\t\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, bps))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tsubframe->warmup[u] = i32;\n\t}\n\n\t/* read qlp coeff precision */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(u32 == (1u << FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN) - 1) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\tsubframe->qlp_coeff_precision = u32+1;\n\n\t/* read qlp shift */\n\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tif(i32 < 0) {\n\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\treturn true;\n\t}\n\tsubframe->quantization_level = i32;\n\n\t/* read quantized lp coefficiencts */\n\tfor(u = 0; u < order; u++) {\n\t\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, subframe->qlp_coeff_precision))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tsubframe->qlp_coeff[u] = i32;\n\t}\n\n\t/* read entropy coding method info */\n\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))\n\t\treturn false; /* read_callback_ sets the state for us */\n\tsubframe->entropy_coding_method.type = (FLAC__EntropyCodingMethodType)u32;\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tif(decoder->private_->frame.header.blocksize >> u32 < order) {\n\t\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.order = u32;\n\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents = &decoder->private_->partitioned_rice_contents[channel];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t\treturn true;\n\t}\n\n\t/* read residual */\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!read_residual_partitioned_rice_(decoder, order, subframe->entropy_coding_method.data.partitioned_rice.order, &decoder->private_->partitioned_rice_contents[channel], decoder->private_->residual[channel], /*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\t/* decode the subframe */\n\tif(do_full_decode) {\n\t\tmemcpy(decoder->private_->output[channel], subframe->warmup, sizeof(FLAC__int32) * order);\n\t\tif(bps + subframe->qlp_coeff_precision + FLAC__bitmath_ilog2(order) <= 32)\n\t\t\tif(bps <= 16 && subframe->qlp_coeff_precision <= 16)\n\t\t\t\tdecoder->private_->local_lpc_restore_signal_16bit(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);\n\t\t\telse\n\t\t\t\tdecoder->private_->local_lpc_restore_signal(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);\n\t\telse\n\t\t\tdecoder->private_->local_lpc_restore_signal_64bit(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_subframe_verbatim_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)\n{\n\tFLAC__Subframe_Verbatim *subframe = &decoder->private_->frame.subframes[channel].data.verbatim;\n\tFLAC__int32 x, *residual = decoder->private_->residual[channel];\n\tunsigned i;\n\n\tdecoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_VERBATIM;\n\n\tsubframe->data = residual;\n\n\tfor(i = 0; i < decoder->private_->frame.header.blocksize; i++) {\n\t\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &x, bps))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tresidual[i] = x;\n\t}\n\n\t/* decode the subframe */\n\tif(do_full_decode)\n\t\tmemcpy(decoder->private_->output[channel], subframe->data, sizeof(FLAC__int32) * decoder->private_->frame.header.blocksize);\n\n\treturn true;\n}\n\nFLAC__bool read_residual_partitioned_rice_(FLAC__StreamDecoder *decoder, unsigned predictor_order, unsigned partition_order, FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents, FLAC__int32 *residual, FLAC__bool is_extended)\n{\n\tFLAC__uint32 rice_parameter;\n\tint i;\n\tunsigned partition, sample, u;\n\tconst unsigned partitions = 1u << partition_order;\n\tconst unsigned partition_samples = partition_order > 0? decoder->private_->frame.header.blocksize >> partition_order : decoder->private_->frame.header.blocksize - predictor_order;\n\tconst unsigned plen = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;\n\tconst unsigned pesc = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;\n\n\t/* invalid predictor and partition orders mush be handled in the callers */\n\tFLAC__ASSERT(partition_order > 0? partition_samples >= predictor_order : decoder->private_->frame.header.blocksize >= predictor_order);\n\n\tif(!FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(partitioned_rice_contents, flac_max(6u, partition_order))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\tsample = 0;\n\tfor(partition = 0; partition < partitions; partition++) {\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &rice_parameter, plen))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tpartitioned_rice_contents->parameters[partition] = rice_parameter;\n\t\tif(rice_parameter < pesc) {\n\t\t\tpartitioned_rice_contents->raw_bits[partition] = 0;\n\t\t\tu = (partition_order == 0 || partition > 0)? partition_samples : partition_samples - predictor_order;\n\t\t\tif(!FLAC__bitreader_read_rice_signed_block(decoder->private_->input, residual + sample, u, rice_parameter))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tsample += u;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &rice_parameter, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))\n\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\tpartitioned_rice_contents->raw_bits[partition] = rice_parameter;\n\t\t\tfor(u = (partition_order == 0 || partition > 0)? 0 : predictor_order; u < partition_samples; u++, sample++) {\n\t\t\t\tif(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i, rice_parameter))\n\t\t\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\t\t\tresidual[sample] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nFLAC__bool read_zero_padding_(FLAC__StreamDecoder *decoder)\n{\n\tif(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input)) {\n\t\tFLAC__uint32 zero = 0;\n\t\tif(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &zero, FLAC__bitreader_bits_left_for_byte_alignment(decoder->private_->input)))\n\t\t\treturn false; /* read_callback_ sets the state for us */\n\t\tif(zero != 0) {\n\t\t\tsend_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;\n\t\t}\n\t}\n\treturn true;\n}\n\nFLAC__bool read_callback_(FLAC__byte buffer[], size_t *bytes, void *client_data)\n{\n\tFLAC__StreamDecoder *decoder = (FLAC__StreamDecoder *)client_data;\n\n\tif(\n#if FLAC__HAS_OGG\n\t\t/* see [1] HACK NOTE below for why we don't call the eof_callback when decoding Ogg FLAC */\n\t\t!decoder->private_->is_ogg &&\n#endif\n\t\tdecoder->private_->eof_callback && decoder->private_->eof_callback(decoder, decoder->private_->client_data)\n\t) {\n\t\t*bytes = 0;\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;\n\t\treturn false;\n\t}\n\telse if(*bytes > 0) {\n\t\t/* While seeking, it is possible for our seek to land in the\n\t\t * middle of audio data that looks exactly like a frame header\n\t\t * from a future version of an encoder.  When that happens, our\n\t\t * error callback will get an\n\t\t * FLAC__STREAM_DECODER_UNPARSEABLE_STREAM and increment its\n\t\t * unparseable_frame_count.  But there is a remote possibility\n\t\t * that it is properly synced at such a \"future-codec frame\",\n\t\t * so to make sure, we wait to see many \"unparseable\" errors in\n\t\t * a row before bailing out.\n\t\t */\n\t\tif(decoder->private_->is_seeking && decoder->private_->unparseable_frame_count > 20) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tconst FLAC__StreamDecoderReadStatus status =\n#if FLAC__HAS_OGG\n\t\t\t\tdecoder->private_->is_ogg?\n\t\t\t\tread_callback_ogg_aspect_(decoder, buffer, bytes) :\n#endif\n\t\t\t\tdecoder->private_->read_callback(decoder, buffer, bytes, decoder->private_->client_data)\n\t\t\t;\n\t\t\tif(status == FLAC__STREAM_DECODER_READ_STATUS_ABORT) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if(*bytes == 0) {\n\t\t\t\tif(\n\t\t\t\t\tstatus == FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM ||\n\t\t\t\t\t(\n#if FLAC__HAS_OGG\n\t\t\t\t\t\t/* see [1] HACK NOTE below for why we don't call the eof_callback when decoding Ogg FLAC */\n\t\t\t\t\t\t!decoder->private_->is_ogg &&\n#endif\n\t\t\t\t\t\tdecoder->private_->eof_callback && decoder->private_->eof_callback(decoder, decoder->private_->client_data)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse {\n\t\t/* abort to avoid a deadlock */\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;\n\t\treturn false;\n\t}\n\t/* [1] @@@ HACK NOTE: The end-of-stream checking has to be hacked around\n\t * for Ogg FLAC.  This is because the ogg decoder aspect can lose sync\n\t * and at the same time hit the end of the stream (for example, seeking\n\t * to a point that is after the beginning of the last Ogg page).  There\n\t * is no way to report an Ogg sync loss through the callbacks (see note\n\t * in read_callback_ogg_aspect_()) so it returns CONTINUE with *bytes==0.\n\t * So to keep the decoder from stopping at this point we gate the call\n\t * to the eof_callback and let the Ogg decoder aspect set the\n\t * end-of-stream state when it is needed.\n\t */\n}\n\n#if FLAC__HAS_OGG\nFLAC__StreamDecoderReadStatus read_callback_ogg_aspect_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes)\n{\n\tswitch(FLAC__ogg_decoder_aspect_read_callback_wrapper(&decoder->protected_->ogg_decoder_aspect, buffer, bytes, read_callback_proxy_, decoder, decoder->private_->client_data)) {\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_OK:\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n\t\t/* we don't really have a way to handle lost sync via read\n\t\t * callback so we'll let it pass and let the underlying\n\t\t * FLAC decoder catch the error\n\t\t */\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_LOST_SYNC:\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_END_OF_STREAM:\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_NOT_FLAC:\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_UNSUPPORTED_MAPPING_VERSION:\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT:\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_ERROR:\n\t\tcase FLAC__OGG_DECODER_ASPECT_READ_STATUS_MEMORY_ALLOCATION_ERROR:\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t\t\t/* double protection */\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n\t}\n}\n\nFLAC__OggDecoderAspectReadStatus read_callback_proxy_(const void *void_decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n{\n\tFLAC__StreamDecoder *decoder = (FLAC__StreamDecoder*)void_decoder;\n\n\tswitch(decoder->private_->read_callback(decoder, buffer, bytes, client_data)) {\n\t\tcase FLAC__STREAM_DECODER_READ_STATUS_CONTINUE:\n\t\t\treturn FLAC__OGG_DECODER_ASPECT_READ_STATUS_OK;\n\t\tcase FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM:\n\t\t\treturn FLAC__OGG_DECODER_ASPECT_READ_STATUS_END_OF_STREAM;\n\t\tcase FLAC__STREAM_DECODER_READ_STATUS_ABORT:\n\t\t\treturn FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT;\n\t\tdefault:\n\t\t\t/* double protection: */\n\t\t\tFLAC__ASSERT(0);\n\t\t\treturn FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT;\n\t}\n}\n#endif\n\nFLAC__StreamDecoderWriteStatus write_audio_frame_to_client_(FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[])\n{\n\tif(decoder->private_->is_seeking) {\n\t\tFLAC__uint64 this_frame_sample = frame->header.number.sample_number;\n\t\tFLAC__uint64 next_frame_sample = this_frame_sample + (FLAC__uint64)frame->header.blocksize;\n\t\tFLAC__uint64 target_sample = decoder->private_->target_sample;\n\n\t\tFLAC__ASSERT(frame->header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n\n#if FLAC__HAS_OGG\n\t\tdecoder->private_->got_a_frame = true;\n#endif\n\t\tdecoder->private_->last_frame = *frame; /* save the frame */\n\t\tif(this_frame_sample <= target_sample && target_sample < next_frame_sample) { /* we hit our target frame */\n\t\t\tunsigned delta = (unsigned)(target_sample - this_frame_sample);\n\t\t\t/* kick out of seek mode */\n\t\t\tdecoder->private_->is_seeking = false;\n\t\t\t/* shift out the samples before target_sample */\n\t\t\tif(delta > 0) {\n\t\t\t\tunsigned channel;\n\t\t\t\tconst FLAC__int32 *newbuffer[FLAC__MAX_CHANNELS];\n\t\t\t\tfor(channel = 0; channel < frame->header.channels; channel++)\n\t\t\t\t\tnewbuffer[channel] = buffer[channel] + delta;\n\t\t\t\tdecoder->private_->last_frame.header.blocksize -= delta;\n\t\t\t\tdecoder->private_->last_frame.header.number.sample_number += (FLAC__uint64)delta;\n\t\t\t\t/* write the relevant samples */\n\t\t\t\treturn decoder->private_->write_callback(decoder, &decoder->private_->last_frame, newbuffer, decoder->private_->client_data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* write the relevant samples */\n\t\t\t\treturn decoder->private_->write_callback(decoder, frame, buffer, decoder->private_->client_data);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;\n\t\t}\n\t}\n\telse {\n\t\t/*\n\t\t * If we never got STREAMINFO, turn off MD5 checking to save\n\t\t * cycles since we don't have a sum to compare to anyway\n\t\t */\n\t\tif(!decoder->private_->has_stream_info)\n\t\t\tdecoder->private_->do_md5_checking = false;\n\t\tif(decoder->private_->do_md5_checking) {\n\t\t\tif(!FLAC__MD5Accumulate(&decoder->private_->md5context, buffer, frame->header.channels, frame->header.blocksize, (frame->header.bits_per_sample+7) / 8))\n\t\t\t\treturn FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;\n\t\t}\n\t\treturn decoder->private_->write_callback(decoder, frame, buffer, decoder->private_->client_data);\n\t}\n}\n\nvoid send_error_to_client_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status)\n{\n\tif(!decoder->private_->is_seeking)\n\t\tdecoder->private_->error_callback(decoder, status, decoder->private_->client_data);\n\telse if(status == FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM)\n\t\tdecoder->private_->unparseable_frame_count++;\n}\n\nFLAC__bool seek_to_absolute_sample_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample)\n{\n\tFLAC__uint64 first_frame_offset = decoder->private_->first_frame_offset, lower_bound, upper_bound, lower_bound_sample, upper_bound_sample, this_frame_sample;\n\tFLAC__int64 pos = -1;\n\tint i;\n\tunsigned approx_bytes_per_frame;\n\tFLAC__bool first_seek = true;\n\tconst FLAC__uint64 total_samples = FLAC__stream_decoder_get_total_samples(decoder);\n\tconst unsigned min_blocksize = decoder->private_->stream_info.data.stream_info.min_blocksize;\n\tconst unsigned max_blocksize = decoder->private_->stream_info.data.stream_info.max_blocksize;\n\tconst unsigned max_framesize = decoder->private_->stream_info.data.stream_info.max_framesize;\n\tconst unsigned min_framesize = decoder->private_->stream_info.data.stream_info.min_framesize;\n\t/* take these from the current frame in case they've changed mid-stream */\n\tunsigned channels = FLAC__stream_decoder_get_channels(decoder);\n\tunsigned bps = FLAC__stream_decoder_get_bits_per_sample(decoder);\n\tconst FLAC__StreamMetadata_SeekTable *seek_table = decoder->private_->has_seek_table? &decoder->private_->seek_table.data.seek_table : 0;\n\n\t/* use values from stream info if we didn't decode a frame */\n\tif(channels == 0)\n\t\tchannels = decoder->private_->stream_info.data.stream_info.channels;\n\tif(bps == 0)\n\t\tbps = decoder->private_->stream_info.data.stream_info.bits_per_sample;\n\n\t/* we are just guessing here */\n\tif(max_framesize > 0)\n\t\tapprox_bytes_per_frame = (max_framesize + min_framesize) / 2 + 1;\n\t/*\n\t * Check if it's a known fixed-blocksize stream.  Note that though\n\t * the spec doesn't allow zeroes in the STREAMINFO block, we may\n\t * never get a STREAMINFO block when decoding so the value of\n\t * min_blocksize might be zero.\n\t */\n\telse if(min_blocksize == max_blocksize && min_blocksize > 0) {\n\t\t/* note there are no () around 'bps/8' to keep precision up since it's an integer calulation */\n\t\tapprox_bytes_per_frame = min_blocksize * channels * bps/8 + 64;\n\t}\n\telse\n\t\tapprox_bytes_per_frame = 4096 * channels * bps/8 + 64;\n\n\t/*\n\t * First, we set an upper and lower bound on where in the\n\t * stream we will search.  For now we assume the worst case\n\t * scenario, which is our best guess at the beginning of\n\t * the first frame and end of the stream.\n\t */\n\tlower_bound = first_frame_offset;\n\tlower_bound_sample = 0;\n\tupper_bound = stream_length;\n\tupper_bound_sample = total_samples > 0 ? total_samples : target_sample /*estimate it*/;\n\n\t/*\n\t * Now we refine the bounds if we have a seektable with\n\t * suitable points.  Note that according to the spec they\n\t * must be ordered by ascending sample number.\n\t *\n\t * Note: to protect against invalid seek tables we will ignore points\n\t * that have frame_samples==0 or sample_number>=total_samples\n\t */\n\tif(seek_table) {\n\t\tFLAC__uint64 new_lower_bound = lower_bound;\n\t\tFLAC__uint64 new_upper_bound = upper_bound;\n\t\tFLAC__uint64 new_lower_bound_sample = lower_bound_sample;\n\t\tFLAC__uint64 new_upper_bound_sample = upper_bound_sample;\n\n\t\t/* find the closest seek point <= target_sample, if it exists */\n\t\tfor(i = (int)seek_table->num_points - 1; i >= 0; i--) {\n\t\t\tif(\n\t\t\t\tseek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&\n\t\t\t\tseek_table->points[i].frame_samples > 0 && /* defense against bad seekpoints */\n\t\t\t\t(total_samples <= 0 || seek_table->points[i].sample_number < total_samples) && /* defense against bad seekpoints */\n\t\t\t\tseek_table->points[i].sample_number <= target_sample\n\t\t\t)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i >= 0) { /* i.e. we found a suitable seek point... */\n\t\t\tnew_lower_bound = first_frame_offset + seek_table->points[i].stream_offset;\n\t\t\tnew_lower_bound_sample = seek_table->points[i].sample_number;\n\t\t}\n\n\t\t/* find the closest seek point > target_sample, if it exists */\n\t\tfor(i = 0; i < (int)seek_table->num_points; i++) {\n\t\t\tif(\n\t\t\t\tseek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&\n\t\t\t\tseek_table->points[i].frame_samples > 0 && /* defense against bad seekpoints */\n\t\t\t\t(total_samples <= 0 || seek_table->points[i].sample_number < total_samples) && /* defense against bad seekpoints */\n\t\t\t\tseek_table->points[i].sample_number > target_sample\n\t\t\t)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i < (int)seek_table->num_points) { /* i.e. we found a suitable seek point... */\n\t\t\tnew_upper_bound = first_frame_offset + seek_table->points[i].stream_offset;\n\t\t\tnew_upper_bound_sample = seek_table->points[i].sample_number;\n\t\t}\n\t\t/* final protection against unsorted seek tables; keep original values if bogus */\n\t\tif(new_upper_bound >= new_lower_bound) {\n\t\t\tlower_bound = new_lower_bound;\n\t\t\tupper_bound = new_upper_bound;\n\t\t\tlower_bound_sample = new_lower_bound_sample;\n\t\t\tupper_bound_sample = new_upper_bound_sample;\n\t\t}\n\t}\n\n\tFLAC__ASSERT(upper_bound_sample >= lower_bound_sample);\n\t/* there are 2 insidious ways that the following equality occurs, which\n\t * we need to fix:\n\t *  1) total_samples is 0 (unknown) and target_sample is 0\n\t *  2) total_samples is 0 (unknown) and target_sample happens to be\n\t *     exactly equal to the last seek point in the seek table; this\n\t *     means there is no seek point above it, and upper_bound_samples\n\t *     remains equal to the estimate (of target_samples) we made above\n\t * in either case it does not hurt to move upper_bound_sample up by 1\n\t */\n\tif(upper_bound_sample == lower_bound_sample)\n\t\tupper_bound_sample++;\n\n\tdecoder->private_->target_sample = target_sample;\n\twhile(1) {\n\t\t/* check if the bounds are still ok */\n\t\tif (lower_bound_sample >= upper_bound_sample || lower_bound > upper_bound) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\treturn false;\n\t\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tpos = (FLAC__int64)lower_bound + (FLAC__int64)((double)(target_sample - lower_bound_sample) / (double)(upper_bound_sample - lower_bound_sample) * (double)(upper_bound - lower_bound)) - approx_bytes_per_frame;\n#else\n\t\t/* a little less accurate: */\n\t\tif(upper_bound - lower_bound < 0xffffffff)\n\t\t\tpos = (FLAC__int64)lower_bound + (FLAC__int64)(((target_sample - lower_bound_sample) * (upper_bound - lower_bound)) / (upper_bound_sample - lower_bound_sample)) - approx_bytes_per_frame;\n\t\telse /* @@@ WATCHOUT, ~2TB limit */\n\t\t\tpos = (FLAC__int64)lower_bound + (FLAC__int64)((((target_sample - lower_bound_sample)>>8) * ((upper_bound - lower_bound)>>8)) / ((upper_bound_sample - lower_bound_sample)>>16)) - approx_bytes_per_frame;\n#endif\n\t\tif(pos >= (FLAC__int64)upper_bound)\n\t\t\tpos = (FLAC__int64)upper_bound - 1;\n\t\tif(pos < (FLAC__int64)lower_bound)\n\t\t\tpos = (FLAC__int64)lower_bound;\n\t\tif(decoder->private_->seek_callback(decoder, (FLAC__uint64)pos, decoder->private_->client_data) != FLAC__STREAM_DECODER_SEEK_STATUS_OK) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tif(!FLAC__stream_decoder_flush(decoder)) {\n\t\t\t/* above call sets the state for us */\n\t\t\treturn false;\n\t\t}\n\t\t/* Now we need to get a frame.  First we need to reset our\n\t\t * unparseable_frame_count; if we get too many unparseable\n\t\t * frames in a row, the read callback will return\n\t\t * FLAC__STREAM_DECODER_READ_STATUS_ABORT, causing\n\t\t * FLAC__stream_decoder_process_single() to return false.\n\t\t */\n\t\tdecoder->private_->unparseable_frame_count = 0;\n\t\tif(!FLAC__stream_decoder_process_single(decoder) ||\n\t\t   decoder->protected_->state == FLAC__STREAM_DECODER_ABORTED) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\t/* our write callback will change the state when it gets to the target frame */\n\t\t/* actually, we could have got_a_frame if our decoder is at FLAC__STREAM_DECODER_END_OF_STREAM so we need to check for that also */\n#if 0\n\t\t/*@@@@@@ used to be the following; not clear if the check for end of stream is needed anymore */\n\t\tif(decoder->protected_->state != FLAC__SEEKABLE_STREAM_DECODER_SEEKING && decoder->protected_->state != FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak;\n#endif\n\t\tif(!decoder->private_->is_seeking)\n\t\t\tbreak;\n\n\t\tFLAC__ASSERT(decoder->private_->last_frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n\t\tthis_frame_sample = decoder->private_->last_frame.header.number.sample_number;\n\n\t\tif (0 == decoder->private_->samples_decoded || (this_frame_sample + decoder->private_->last_frame.header.blocksize >= upper_bound_sample && !first_seek)) {\n\t\t\tif (pos == (FLAC__int64)lower_bound) {\n\t\t\t\t/* can't move back any more than the first frame, something is fatally wrong */\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t/* our last move backwards wasn't big enough, try again */\n\t\t\tapprox_bytes_per_frame = approx_bytes_per_frame? approx_bytes_per_frame * 2 : 16;\n\t\t\tcontinue;\n\t\t}\n\t\t/* allow one seek over upper bound, so we can get a correct upper_bound_sample for streams with unknown total_samples */\n\t\tfirst_seek = false;\n\n\t\t/* make sure we are not seeking in corrupted stream */\n\t\tif (this_frame_sample < lower_bound_sample) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\treturn false;\n\t\t}\n\n\t\t/* we need to narrow the search */\n\t\tif(target_sample < this_frame_sample) {\n\t\t\tupper_bound_sample = this_frame_sample + decoder->private_->last_frame.header.blocksize;\n/*@@@@@@ what will decode position be if at end of stream? */\n\t\t\tif(!FLAC__stream_decoder_get_decode_position(decoder, &upper_bound)) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tapprox_bytes_per_frame = (unsigned)(2 * (upper_bound - pos) / 3 + 16);\n\t\t}\n\t\telse { /* target_sample >= this_frame_sample + this frame's blocksize */\n\t\t\tlower_bound_sample = this_frame_sample + decoder->private_->last_frame.header.blocksize;\n\t\t\tif(!FLAC__stream_decoder_get_decode_position(decoder, &lower_bound)) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tapprox_bytes_per_frame = (unsigned)(2 * (lower_bound - pos) / 3 + 16);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n#if FLAC__HAS_OGG\nFLAC__bool seek_to_absolute_sample_ogg_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample)\n{\n\tFLAC__uint64 left_pos = 0, right_pos = stream_length;\n\tFLAC__uint64 left_sample = 0, right_sample = FLAC__stream_decoder_get_total_samples(decoder);\n\tFLAC__uint64 this_frame_sample = (FLAC__uint64)0 - 1;\n\tFLAC__uint64 pos = 0; /* only initialized to avoid compiler warning */\n\tFLAC__bool did_a_seek;\n\tunsigned iteration = 0;\n\n\t/* In the first iterations, we will calculate the target byte position\n\t * by the distance from the target sample to left_sample and\n\t * right_sample (let's call it \"proportional search\").  After that, we\n\t * will switch to binary search.\n\t */\n\tunsigned BINARY_SEARCH_AFTER_ITERATION = 2;\n\n\t/* We will switch to a linear search once our current sample is less\n\t * than this number of samples ahead of the target sample\n\t */\n\tstatic const FLAC__uint64 LINEAR_SEARCH_WITHIN_SAMPLES = FLAC__MAX_BLOCK_SIZE * 2;\n\n\t/* If the total number of samples is unknown, use a large value, and\n\t * force binary search immediately.\n\t */\n\tif(right_sample == 0) {\n\t\tright_sample = (FLAC__uint64)(-1);\n\t\tBINARY_SEARCH_AFTER_ITERATION = 0;\n\t}\n\n\tdecoder->private_->target_sample = target_sample;\n\tfor( ; ; iteration++) {\n\t\tif (iteration == 0 || this_frame_sample > target_sample || target_sample - this_frame_sample > LINEAR_SEARCH_WITHIN_SAMPLES) {\n\t\t\tif (iteration >= BINARY_SEARCH_AFTER_ITERATION) {\n\t\t\t\tpos = (right_pos + left_pos) / 2;\n\t\t\t}\n\t\t\telse {\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\t\t\tpos = (FLAC__uint64)((double)(target_sample - left_sample) / (double)(right_sample - left_sample) * (double)(right_pos - left_pos));\n#else\n\t\t\t\t/* a little less accurate: */\n\t\t\t\tif ((target_sample-left_sample <= 0xffffffff) && (right_pos-left_pos <= 0xffffffff))\n\t\t\t\t\tpos = (FLAC__int64)(((target_sample-left_sample) * (right_pos-left_pos)) / (right_sample-left_sample));\n\t\t\t\telse /* @@@ WATCHOUT, ~2TB limit */\n\t\t\t\t\tpos = (FLAC__int64)((((target_sample-left_sample)>>8) * ((right_pos-left_pos)>>8)) / ((right_sample-left_sample)>>16));\n#endif\n\t\t\t\t/* @@@ TODO: might want to limit pos to some distance\n\t\t\t\t * before EOF, to make sure we land before the last frame,\n\t\t\t\t * thereby getting a this_frame_sample and so having a better\n\t\t\t\t * estimate.\n\t\t\t\t */\n\t\t\t}\n\n\t\t\t/* physical seek */\n\t\t\tif(decoder->private_->seek_callback((FLAC__StreamDecoder*)decoder, (FLAC__uint64)pos, decoder->private_->client_data) != FLAC__STREAM_DECODER_SEEK_STATUS_OK) {\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(!FLAC__stream_decoder_flush(decoder)) {\n\t\t\t\t/* above call sets the state for us */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdid_a_seek = true;\n\t\t}\n\t\telse\n\t\t\tdid_a_seek = false;\n\n\t\tdecoder->private_->got_a_frame = false;\n\t\tif(!FLAC__stream_decoder_process_single(decoder) ||\n\t\t   decoder->protected_->state == FLAC__STREAM_DECODER_ABORTED) {\n\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\treturn false;\n\t\t}\n\t\tif(!decoder->private_->got_a_frame) {\n\t\t\tif(did_a_seek) {\n\t\t\t\t/* this can happen if we seek to a point after the last frame; we drop\n\t\t\t\t * to binary search right away in this case to avoid any wasted\n\t\t\t\t * iterations of proportional search.\n\t\t\t\t */\n\t\t\t\tright_pos = pos;\n\t\t\t\tBINARY_SEARCH_AFTER_ITERATION = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* this can probably only happen if total_samples is unknown and the\n\t\t\t\t * target_sample is past the end of the stream\n\t\t\t\t */\n\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/* our write callback will change the state when it gets to the target frame */\n\t\telse if(!decoder->private_->is_seeking) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tthis_frame_sample = decoder->private_->last_frame.header.number.sample_number;\n\t\t\tFLAC__ASSERT(decoder->private_->last_frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n\n\t\t\tif (did_a_seek) {\n\t\t\t\tif (this_frame_sample <= target_sample) {\n\t\t\t\t\t/* The 'equal' case should not happen, since\n\t\t\t\t\t * FLAC__stream_decoder_process_single()\n\t\t\t\t\t * should recognize that it has hit the\n\t\t\t\t\t * target sample and we would exit through\n\t\t\t\t\t * the 'break' above.\n\t\t\t\t\t */\n\t\t\t\t\tFLAC__ASSERT(this_frame_sample != target_sample);\n\n\t\t\t\t\tleft_sample = this_frame_sample;\n\t\t\t\t\t/* sanity check to avoid infinite loop */\n\t\t\t\t\tif (left_pos == pos) {\n\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tleft_pos = pos;\n\t\t\t\t}\n\t\t\t\telse if(this_frame_sample > target_sample) {\n\t\t\t\t\tright_sample = this_frame_sample;\n\t\t\t\t\t/* sanity check to avoid infinite loop */\n\t\t\t\t\tif (right_pos == pos) {\n\t\t\t\t\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tright_pos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n#endif\n\nFLAC__StreamDecoderReadStatus file_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n{\n\t(void)client_data;\n\n\tif(*bytes > 0) {\n\t\t*bytes = fread(buffer, sizeof(FLAC__byte), *bytes, decoder->private_->file);\n\t\tif(ferror(decoder->private_->file))\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n\t\telse if(*bytes == 0)\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\n\t\telse\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n\t}\n\telse\n\t\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT; /* abort to avoid a deadlock */\n}\n\nFLAC__StreamDecoderSeekStatus file_seek_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)\n{\n\t(void)client_data;\n\n\tif(decoder->private_->file == stdin)\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;\n\telse if(fseeko(decoder->private_->file, (FLAC__off_t)absolute_byte_offset, SEEK_SET) < 0)\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;\n\telse\n\t\treturn FLAC__STREAM_DECODER_SEEK_STATUS_OK;\n}\n\nFLAC__StreamDecoderTellStatus file_tell_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\n\tFLAC__off_t pos;\n\t(void)client_data;\n\n\tif(decoder->private_->file == stdin)\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;\n\telse if((pos = ftello(decoder->private_->file)) < 0)\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_ERROR;\n\telse {\n\t\t*absolute_byte_offset = (FLAC__uint64)pos;\n\t\treturn FLAC__STREAM_DECODER_TELL_STATUS_OK;\n\t}\n}\n\nFLAC__StreamDecoderLengthStatus file_length_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)\n{\n\tstruct flac_stat_s filestats;\n\t(void)client_data;\n\n\tif(decoder->private_->file == stdin)\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;\n\telse if(flac_fstat(fileno(decoder->private_->file), &filestats) != 0)\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;\n\telse {\n\t\t*stream_length = (FLAC__uint64)filestats.st_size;\n\t\treturn FLAC__STREAM_DECODER_LENGTH_STATUS_OK;\n\t}\n}\n\nFLAC__bool file_eof_callback_(const FLAC__StreamDecoder *decoder, void *client_data)\n{\n\t(void)client_data;\n\n\treturn feof(decoder->private_->file)? true : false;\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h> /* for malloc() */\n#include <string.h> /* for memcpy() */\n#include <sys/types.h> /* for off_t */\n#ifdef _WIN32\n#include <windows.h> /* for GetFileType() */\n#include <io.h> /* for _get_osfhandle() */\n#endif\n#include \"share/compat.h\"\n#include \"FLAC/assert.h\"\n#include \"FLAC/stream_decoder.h\"\n#include \"protected/stream_encoder.h\"\n#include \"private/bitwriter.h\"\n#include \"private/bitmath.h\"\n#include \"private/crc.h\"\n#include \"private/cpu.h\"\n#include \"private/fixed.h\"\n#include \"private/format.h\"\n#include \"private/lpc.h\"\n#include \"private/md5.h\"\n#include \"private/memory.h\"\n#include \"private/macros.h\"\n#if FLAC__HAS_OGG\n#include \"private/ogg_helper.h\"\n#include \"private/ogg_mapping.h\"\n#endif\n#include \"private/stream_encoder.h\"\n#include \"private/stream_encoder_framing.h\"\n#include \"private/window.h\"\n#include \"share/alloc.h\"\n#include \"share/private.h\"\n\n\n/* Exact Rice codeword length calculation is off by default.  The simple\n * (and fast) estimation (of how many bits a residual value will be\n * encoded with) in this encoder is very good, almost always yielding\n * compression within 0.1% of exact calculation.\n */\n#undef EXACT_RICE_BITS_CALCULATION\n/* Rice parameter searching is off by default.  The simple (and fast)\n * parameter estimation in this encoder is very good, almost always\n * yielding compression within 0.1% of the optimal parameters.\n */\n#undef ENABLE_RICE_PARAMETER_SEARCH\n\n\ntypedef struct {\n\tFLAC__int32 *data[FLAC__MAX_CHANNELS];\n\tunsigned size; /* of each data[] in samples */\n\tunsigned tail;\n} verify_input_fifo;\n\ntypedef struct {\n\tconst FLAC__byte *data;\n\tunsigned capacity;\n\tunsigned bytes;\n} verify_output;\n\ntypedef enum {\n\tENCODER_IN_MAGIC = 0,\n\tENCODER_IN_METADATA = 1,\n\tENCODER_IN_AUDIO = 2\n} EncoderStateHint;\n\nstatic struct CompressionLevels {\n\tFLAC__bool do_mid_side_stereo;\n\tFLAC__bool loose_mid_side_stereo;\n\tunsigned max_lpc_order;\n\tunsigned qlp_coeff_precision;\n\tFLAC__bool do_qlp_coeff_prec_search;\n\tFLAC__bool do_escape_coding;\n\tFLAC__bool do_exhaustive_model_search;\n\tunsigned min_residual_partition_order;\n\tunsigned max_residual_partition_order;\n\tunsigned rice_parameter_search_dist;\n\tconst char *apodization;\n} compression_levels_[] = {\n\t{ false, false,  0, 0, false, false, false, 0, 3, 0, \"tukey(5e-1)\" },\n\t{ true , true ,  0, 0, false, false, false, 0, 3, 0, \"tukey(5e-1)\" },\n\t{ true , false,  0, 0, false, false, false, 0, 3, 0, \"tukey(5e-1)\" },\n\t{ false, false,  6, 0, false, false, false, 0, 4, 0, \"tukey(5e-1)\" },\n\t{ true , true ,  8, 0, false, false, false, 0, 4, 0, \"tukey(5e-1)\" },\n\t{ true , false,  8, 0, false, false, false, 0, 5, 0, \"tukey(5e-1)\" },\n\t{ true , false,  8, 0, false, false, false, 0, 6, 0, \"tukey(5e-1);partial_tukey(2)\" },\n\t{ true , false, 12, 0, false, false, false, 0, 6, 0, \"tukey(5e-1);partial_tukey(2)\" },\n\t{ true , false, 12, 0, false, false, false, 0, 6, 0, \"tukey(5e-1);partial_tukey(2);punchout_tukey(3)\" }\n\t/* here we use locale-independent 5e-1 instead of 0.5 or 0,5 */\n};\n\n\n/***********************************************************************\n *\n * Private class method prototypes\n *\n ***********************************************************************/\n\nstatic void set_defaults_(FLAC__StreamEncoder *encoder);\nstatic void free_(FLAC__StreamEncoder *encoder);\nstatic FLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, unsigned new_blocksize);\nstatic FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, unsigned samples, FLAC__bool is_last_block);\nstatic FLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, FLAC__bool is_last_block);\nstatic void update_metadata_(const FLAC__StreamEncoder *encoder);\n#if FLAC__HAS_OGG\nstatic void update_ogg_metadata_(FLAC__StreamEncoder *encoder);\n#endif\nstatic FLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block, FLAC__bool is_last_block);\nstatic FLAC__bool process_subframes_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block);\n\nstatic FLAC__bool process_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tconst FLAC__FrameHeader *frame_header,\n\tunsigned subframe_bps,\n\tconst FLAC__int32 integer_signal[],\n\tFLAC__Subframe *subframe[2],\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],\n\tFLAC__int32 *residual[2],\n\tunsigned *best_subframe,\n\tunsigned *best_bits\n);\n\nstatic FLAC__bool add_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tconst FLAC__Subframe *subframe,\n\tFLAC__BitWriter *frame\n);\n\nstatic unsigned evaluate_constant_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal,\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tFLAC__Subframe *subframe\n);\n\nstatic unsigned evaluate_fixed_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tFLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tunsigned order,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__Subframe *subframe,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents\n);\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\nstatic unsigned evaluate_lpc_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tFLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tconst FLAC__real lp_coeff[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tunsigned order,\n\tunsigned qlp_coeff_precision,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__Subframe *subframe,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents\n);\n#endif\n\nstatic unsigned evaluate_verbatim_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tFLAC__Subframe *subframe\n);\n\nstatic unsigned find_best_partition_order_(\n\tstruct FLAC__StreamEncoderPrivate *private_,\n\tconst FLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tunsigned bps,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__EntropyCodingMethod *best_ecm\n);\n\nstatic void precompute_partition_info_sums_(\n\tconst FLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tunsigned bps\n);\n\nstatic void precompute_partition_info_escapes_(\n\tconst FLAC__int32 residual[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order\n);\n\nstatic FLAC__bool set_partitioned_rice_(\n#ifdef EXACT_RICE_BITS_CALCULATION\n\tconst FLAC__int32 residual[],\n#endif\n\tconst FLAC__uint64 abs_residual_partition_sums[],\n\tconst unsigned raw_bits_per_partition[],\n\tconst unsigned residual_samples,\n\tconst unsigned predictor_order,\n\tconst unsigned suggested_rice_parameter,\n\tconst unsigned rice_parameter_limit,\n\tconst unsigned rice_parameter_search_dist,\n\tconst unsigned partition_order,\n\tconst FLAC__bool search_for_escapes,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,\n\tunsigned *bits\n);\n\nstatic unsigned get_wasted_bits_(FLAC__int32 signal[], unsigned samples);\n\n/* verify-related routines: */\nstatic void append_to_verify_fifo_(\n\tverify_input_fifo *fifo,\n\tconst FLAC__int32 * const input[],\n\tunsigned input_offset,\n\tunsigned channels,\n\tunsigned wide_samples\n);\n\nstatic void append_to_verify_fifo_interleaved_(\n\tverify_input_fifo *fifo,\n\tconst FLAC__int32 input[],\n\tunsigned input_offset,\n\tunsigned channels,\n\tunsigned wide_samples\n);\n\nstatic FLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);\nstatic FLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);\nstatic void verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);\nstatic void verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);\n\nstatic FLAC__StreamEncoderReadStatus file_read_callback_(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data);\nstatic FLAC__StreamEncoderSeekStatus file_seek_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data);\nstatic FLAC__StreamEncoderTellStatus file_tell_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data);\nstatic FLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data);\nstatic FILE *get_binary_stdout_(void);\n\n\n/***********************************************************************\n *\n * Private class data\n *\n ***********************************************************************/\n\ntypedef struct FLAC__StreamEncoderPrivate {\n\tunsigned input_capacity;                          /* current size (in samples) of the signal and residual buffers */\n\tFLAC__int32 *integer_signal[FLAC__MAX_CHANNELS];  /* the integer version of the input signal */\n\tFLAC__int32 *integer_signal_mid_side[2];          /* the integer version of the mid-side input signal (stereo only) */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tFLAC__real *real_signal[FLAC__MAX_CHANNELS];      /* (@@@ currently unused) the floating-point version of the input signal */\n\tFLAC__real *real_signal_mid_side[2];              /* (@@@ currently unused) the floating-point version of the mid-side input signal (stereo only) */\n\tFLAC__real *window[FLAC__MAX_APODIZATION_FUNCTIONS]; /* the pre-computed floating-point window for each apodization function */\n\tFLAC__real *windowed_signal;                      /* the integer_signal[] * current window[] */\n#endif\n\tunsigned subframe_bps[FLAC__MAX_CHANNELS];        /* the effective bits per sample of the input signal (stream bps - wasted bits) */\n\tunsigned subframe_bps_mid_side[2];                /* the effective bits per sample of the mid-side input signal (stream bps - wasted bits + 0/1) */\n\tFLAC__int32 *residual_workspace[FLAC__MAX_CHANNELS][2]; /* each channel has a candidate and best workspace where the subframe residual signals will be stored */\n\tFLAC__int32 *residual_workspace_mid_side[2][2];\n\tFLAC__Subframe subframe_workspace[FLAC__MAX_CHANNELS][2];\n\tFLAC__Subframe subframe_workspace_mid_side[2][2];\n\tFLAC__Subframe *subframe_workspace_ptr[FLAC__MAX_CHANNELS][2];\n\tFLAC__Subframe *subframe_workspace_ptr_mid_side[2][2];\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace[FLAC__MAX_CHANNELS][2];\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace_mid_side[FLAC__MAX_CHANNELS][2];\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr[FLAC__MAX_CHANNELS][2];\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr_mid_side[FLAC__MAX_CHANNELS][2];\n\tunsigned best_subframe[FLAC__MAX_CHANNELS];       /* index (0 or 1) into 2nd dimension of the above workspaces */\n\tunsigned best_subframe_mid_side[2];\n\tunsigned best_subframe_bits[FLAC__MAX_CHANNELS];  /* size in bits of the best subframe for each channel */\n\tunsigned best_subframe_bits_mid_side[2];\n\tFLAC__uint64 *abs_residual_partition_sums;        /* workspace where the sum of abs(candidate residual) for each partition is stored */\n\tunsigned *raw_bits_per_partition;                 /* workspace where the sum of silog2(candidate residual) for each partition is stored */\n\tFLAC__BitWriter *frame;                           /* the current frame being worked on */\n\tunsigned loose_mid_side_stereo_frames;            /* rounded number of frames the encoder will use before trying both independent and mid/side frames again */\n\tunsigned loose_mid_side_stereo_frame_count;       /* number of frames using the current channel assignment */\n\tFLAC__ChannelAssignment last_channel_assignment;\n\tFLAC__StreamMetadata streaminfo;                  /* scratchpad for STREAMINFO as it is built */\n\tFLAC__StreamMetadata_SeekTable *seek_table;       /* pointer into encoder->protected_->metadata_ where the seek table is */\n\tunsigned current_sample_number;\n\tunsigned current_frame_number;\n\tFLAC__MD5Context md5context;\n\tFLAC__CPUInfo cpuinfo;\n\tvoid (*local_precompute_partition_info_sums)(const FLAC__int32 residual[], FLAC__uint64 abs_residual_partition_sums[], unsigned residual_samples, unsigned predictor_order, unsigned min_partition_order, unsigned max_partition_order, unsigned bps);\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tunsigned (*local_fixed_compute_best_predictor)(const FLAC__int32 data[], unsigned data_len, float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);\n\tunsigned (*local_fixed_compute_best_predictor_wide)(const FLAC__int32 data[], unsigned data_len, float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);\n#else\n\tunsigned (*local_fixed_compute_best_predictor)(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);\n\tunsigned (*local_fixed_compute_best_predictor_wide)(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);\n#endif\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tvoid (*local_lpc_compute_autocorrelation)(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);\n\tvoid (*local_lpc_compute_residual_from_qlp_coefficients)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);\n\tvoid (*local_lpc_compute_residual_from_qlp_coefficients_64bit)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);\n\tvoid (*local_lpc_compute_residual_from_qlp_coefficients_16bit)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);\n#endif\n\tFLAC__bool disable_constant_subframes;\n\tFLAC__bool disable_fixed_subframes;\n\tFLAC__bool disable_verbatim_subframes;\n\tFLAC__bool is_ogg;\n\tFLAC__StreamEncoderReadCallback read_callback; /* currently only needed for Ogg FLAC */\n\tFLAC__StreamEncoderSeekCallback seek_callback;\n\tFLAC__StreamEncoderTellCallback tell_callback;\n\tFLAC__StreamEncoderWriteCallback write_callback;\n\tFLAC__StreamEncoderMetadataCallback metadata_callback;\n\tFLAC__StreamEncoderProgressCallback progress_callback;\n\tvoid *client_data;\n\tunsigned first_seekpoint_to_check;\n\tFILE *file;                            /* only used when encoding to a file */\n\tFLAC__uint64 bytes_written;\n\tFLAC__uint64 samples_written;\n\tunsigned frames_written;\n\tunsigned total_frames_estimate;\n\t/* unaligned (original) pointers to allocated data */\n\tFLAC__int32 *integer_signal_unaligned[FLAC__MAX_CHANNELS];\n\tFLAC__int32 *integer_signal_mid_side_unaligned[2];\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tFLAC__real *real_signal_unaligned[FLAC__MAX_CHANNELS]; /* (@@@ currently unused) */\n\tFLAC__real *real_signal_mid_side_unaligned[2]; /* (@@@ currently unused) */\n\tFLAC__real *window_unaligned[FLAC__MAX_APODIZATION_FUNCTIONS];\n\tFLAC__real *windowed_signal_unaligned;\n#endif\n\tFLAC__int32 *residual_workspace_unaligned[FLAC__MAX_CHANNELS][2];\n\tFLAC__int32 *residual_workspace_mid_side_unaligned[2][2];\n\tFLAC__uint64 *abs_residual_partition_sums_unaligned;\n\tunsigned *raw_bits_per_partition_unaligned;\n\t/*\n\t * These fields have been moved here from private function local\n\t * declarations merely to save stack space during encoding.\n\t */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tFLAC__real lp_coeff[FLAC__MAX_LPC_ORDER][FLAC__MAX_LPC_ORDER]; /* from process_subframe_() */\n#endif\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_extra[2]; /* from find_best_partition_order_() */\n\t/*\n\t * The data for the verify section\n\t */\n\tstruct {\n\t\tFLAC__StreamDecoder *decoder;\n\t\tEncoderStateHint state_hint;\n\t\tFLAC__bool needs_magic_hack;\n\t\tverify_input_fifo input_fifo;\n\t\tverify_output output;\n\t\tstruct {\n\t\t\tFLAC__uint64 absolute_sample;\n\t\t\tunsigned frame_number;\n\t\t\tunsigned channel;\n\t\t\tunsigned sample;\n\t\t\tFLAC__int32 expected;\n\t\t\tFLAC__int32 got;\n\t\t} error_stats;\n\t} verify;\n\tFLAC__bool is_being_deleted; /* if true, call to ..._finish() from ..._delete() will not call the callbacks */\n} FLAC__StreamEncoderPrivate;\n\n/***********************************************************************\n *\n * Public static class data\n *\n ***********************************************************************/\n\nFLAC_API const char * const FLAC__StreamEncoderStateString[] = {\n\t\"FLAC__STREAM_ENCODER_OK\",\n\t\"FLAC__STREAM_ENCODER_UNINITIALIZED\",\n\t\"FLAC__STREAM_ENCODER_OGG_ERROR\",\n\t\"FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR\",\n\t\"FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA\",\n\t\"FLAC__STREAM_ENCODER_CLIENT_ERROR\",\n\t\"FLAC__STREAM_ENCODER_IO_ERROR\",\n\t\"FLAC__STREAM_ENCODER_FRAMING_ERROR\",\n\t\"FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR\"\n};\n\nFLAC_API const char * const FLAC__StreamEncoderInitStatusString[] = {\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_OK\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA\",\n\t\"FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED\"\n};\n\nFLAC_API const char * const FLAC__StreamEncoderReadStatusString[] = {\n\t\"FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE\",\n\t\"FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM\",\n\t\"FLAC__STREAM_ENCODER_READ_STATUS_ABORT\",\n\t\"FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED\"\n};\n\nFLAC_API const char * const FLAC__StreamEncoderWriteStatusString[] = {\n\t\"FLAC__STREAM_ENCODER_WRITE_STATUS_OK\",\n\t\"FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR\"\n};\n\nFLAC_API const char * const FLAC__StreamEncoderSeekStatusString[] = {\n\t\"FLAC__STREAM_ENCODER_SEEK_STATUS_OK\",\n\t\"FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR\",\n\t\"FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED\"\n};\n\nFLAC_API const char * const FLAC__StreamEncoderTellStatusString[] = {\n\t\"FLAC__STREAM_ENCODER_TELL_STATUS_OK\",\n\t\"FLAC__STREAM_ENCODER_TELL_STATUS_ERROR\",\n\t\"FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED\"\n};\n\n/* Number of samples that will be overread to watch for end of stream.  By\n * 'overread', we mean that the FLAC__stream_encoder_process*() calls will\n * always try to read blocksize+1 samples before encoding a block, so that\n * even if the stream has a total sample count that is an integral multiple\n * of the blocksize, we will still notice when we are encoding the last\n * block.  This is needed, for example, to correctly set the end-of-stream\n * marker in Ogg FLAC.\n *\n * WATCHOUT: some parts of the code assert that OVERREAD_ == 1 and there's\n * not really any reason to change it.\n */\nstatic const unsigned OVERREAD_ = 1;\n\n/***********************************************************************\n *\n * Class constructor/destructor\n *\n */\nFLAC_API FLAC__StreamEncoder *FLAC__stream_encoder_new(void)\n{\n\tFLAC__StreamEncoder *encoder;\n\tunsigned i;\n\n\tFLAC__ASSERT(sizeof(int) >= 4); /* we want to die right away if this is not true */\n\n\tencoder = calloc(1, sizeof(FLAC__StreamEncoder));\n\tif(encoder == 0) {\n\t\treturn 0;\n\t}\n\n\tencoder->protected_ = calloc(1, sizeof(FLAC__StreamEncoderProtected));\n\tif(encoder->protected_ == 0) {\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_ = calloc(1, sizeof(FLAC__StreamEncoderPrivate));\n\tif(encoder->private_ == 0) {\n\t\tfree(encoder->protected_);\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_->frame = FLAC__bitwriter_new();\n\tif(encoder->private_->frame == 0) {\n\t\tfree(encoder->private_);\n\t\tfree(encoder->protected_);\n\t\tfree(encoder);\n\t\treturn 0;\n\t}\n\n\tencoder->private_->file = 0;\n\n\tset_defaults_(encoder);\n\n\tencoder->private_->is_being_deleted = false;\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tencoder->private_->subframe_workspace_ptr[i][0] = &encoder->private_->subframe_workspace[i][0];\n\t\tencoder->private_->subframe_workspace_ptr[i][1] = &encoder->private_->subframe_workspace[i][1];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->subframe_workspace_ptr_mid_side[i][0] = &encoder->private_->subframe_workspace_mid_side[i][0];\n\t\tencoder->private_->subframe_workspace_ptr_mid_side[i][1] = &encoder->private_->subframe_workspace_mid_side[i][1];\n\t}\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr[i][0] = &encoder->private_->partitioned_rice_contents_workspace[i][0];\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr[i][1] = &encoder->private_->partitioned_rice_contents_workspace[i][1];\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][0] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0];\n\t\tencoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][1] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1];\n\t}\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++)\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_extra[i]);\n\n\tencoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;\n\n\treturn encoder;\n}\n\nFLAC_API void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder)\n{\n\tunsigned i;\n\n\tif (encoder == NULL)\n\t\treturn ;\n\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->private_->frame);\n\n\tencoder->private_->is_being_deleted = true;\n\n\t(void)FLAC__stream_encoder_finish(encoder);\n\n\tif(0 != encoder->private_->verify.decoder)\n\t\tFLAC__stream_decoder_delete(encoder->private_->verify.decoder);\n\n\tfor(i = 0; i < FLAC__MAX_CHANNELS; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);\n\t}\n\tfor(i = 0; i < 2; i++)\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_extra[i]);\n\n\tFLAC__bitwriter_delete(encoder->private_->frame);\n\tfree(encoder->private_);\n\tfree(encoder->protected_);\n\tfree(encoder);\n}\n\n/***********************************************************************\n *\n * Public class methods\n *\n ***********************************************************************/\n\nstatic FLAC__StreamEncoderInitStatus init_stream_internal_(\n\tFLAC__StreamEncoder *encoder,\n\tFLAC__StreamEncoderReadCallback read_callback,\n\tFLAC__StreamEncoderWriteCallback write_callback,\n\tFLAC__StreamEncoderSeekCallback seek_callback,\n\tFLAC__StreamEncoderTellCallback tell_callback,\n\tFLAC__StreamEncoderMetadataCallback metadata_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tunsigned i;\n\tFLAC__bool metadata_has_seektable, metadata_has_vorbis_comment, metadata_picture_has_type1, metadata_picture_has_type2;\n\n\tFLAC__ASSERT(0 != encoder);\n\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\tif(FLAC__HAS_OGG == 0 && is_ogg)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER;\n\n\tif(0 == write_callback || (seek_callback && 0 == tell_callback))\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS;\n\n\tif(encoder->protected_->channels == 0 || encoder->protected_->channels > FLAC__MAX_CHANNELS)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS;\n\n\tif(encoder->protected_->channels != 2) {\n\t\tencoder->protected_->do_mid_side_stereo = false;\n\t\tencoder->protected_->loose_mid_side_stereo = false;\n\t}\n\telse if(!encoder->protected_->do_mid_side_stereo)\n\t\tencoder->protected_->loose_mid_side_stereo = false;\n\n\tif(encoder->protected_->bits_per_sample >= 32)\n\t\tencoder->protected_->do_mid_side_stereo = false; /* since we currenty do 32-bit math, the side channel would have 33 bps and overflow */\n\n\tif(encoder->protected_->bits_per_sample < FLAC__MIN_BITS_PER_SAMPLE || encoder->protected_->bits_per_sample > FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE;\n\n\tif(!FLAC__format_sample_rate_is_valid(encoder->protected_->sample_rate))\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE;\n\n\tif(encoder->protected_->blocksize == 0) {\n\t\tif(encoder->protected_->max_lpc_order == 0)\n\t\t\tencoder->protected_->blocksize = 1152;\n\t\telse\n\t\t\tencoder->protected_->blocksize = 4096;\n\t}\n\n\tif(encoder->protected_->blocksize < FLAC__MIN_BLOCK_SIZE || encoder->protected_->blocksize > FLAC__MAX_BLOCK_SIZE)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE;\n\n\tif(encoder->protected_->max_lpc_order > FLAC__MAX_LPC_ORDER)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER;\n\n\tif(encoder->protected_->blocksize < encoder->protected_->max_lpc_order)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER;\n\n\tif(encoder->protected_->qlp_coeff_precision == 0) {\n\t\tif(encoder->protected_->bits_per_sample < 16) {\n\t\t\t/* @@@ need some data about how to set this here w.r.t. blocksize and sample rate */\n\t\t\t/* @@@ until then we'll make a guess */\n\t\t\tencoder->protected_->qlp_coeff_precision = flac_max(FLAC__MIN_QLP_COEFF_PRECISION, 2 + encoder->protected_->bits_per_sample / 2);\n\t\t}\n\t\telse if(encoder->protected_->bits_per_sample == 16) {\n\t\t\tif(encoder->protected_->blocksize <= 192)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 7;\n\t\t\telse if(encoder->protected_->blocksize <= 384)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 8;\n\t\t\telse if(encoder->protected_->blocksize <= 576)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 9;\n\t\t\telse if(encoder->protected_->blocksize <= 1152)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 10;\n\t\t\telse if(encoder->protected_->blocksize <= 2304)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 11;\n\t\t\telse if(encoder->protected_->blocksize <= 4608)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 12;\n\t\t\telse\n\t\t\t\tencoder->protected_->qlp_coeff_precision = 13;\n\t\t}\n\t\telse {\n\t\t\tif(encoder->protected_->blocksize <= 384)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-2;\n\t\t\telse if(encoder->protected_->blocksize <= 1152)\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-1;\n\t\t\telse\n\t\t\t\tencoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION;\n\t\t}\n\t\tFLAC__ASSERT(encoder->protected_->qlp_coeff_precision <= FLAC__MAX_QLP_COEFF_PRECISION);\n\t}\n\telse if(encoder->protected_->qlp_coeff_precision < FLAC__MIN_QLP_COEFF_PRECISION || encoder->protected_->qlp_coeff_precision > FLAC__MAX_QLP_COEFF_PRECISION)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION;\n\n\tif(encoder->protected_->streamable_subset) {\n\t\tif(!FLAC__format_blocksize_is_subset(encoder->protected_->blocksize, encoder->protected_->sample_rate))\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(!FLAC__format_sample_rate_is_subset(encoder->protected_->sample_rate))\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(\n\t\t\tencoder->protected_->bits_per_sample != 8 &&\n\t\t\tencoder->protected_->bits_per_sample != 12 &&\n\t\t\tencoder->protected_->bits_per_sample != 16 &&\n\t\t\tencoder->protected_->bits_per_sample != 20 &&\n\t\t\tencoder->protected_->bits_per_sample != 24\n\t\t)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(encoder->protected_->max_residual_partition_order > FLAC__SUBSET_MAX_RICE_PARTITION_ORDER)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\tif(\n\t\t\tencoder->protected_->sample_rate <= 48000 &&\n\t\t\t(\n\t\t\t\tencoder->protected_->blocksize > FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ ||\n\t\t\t\tencoder->protected_->max_lpc_order > FLAC__SUBSET_MAX_LPC_ORDER_48000HZ\n\t\t\t)\n\t\t) {\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;\n\t\t}\n\t}\n\n\tif(encoder->protected_->max_residual_partition_order >= (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))\n\t\tencoder->protected_->max_residual_partition_order = (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN) - 1;\n\tif(encoder->protected_->min_residual_partition_order >= encoder->protected_->max_residual_partition_order)\n\t\tencoder->protected_->min_residual_partition_order = encoder->protected_->max_residual_partition_order;\n\n#if FLAC__HAS_OGG\n\t/* reorder metadata if necessary to ensure that any VORBIS_COMMENT is the first, according to the mapping spec */\n\tif(is_ogg && 0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 1) {\n\t\tunsigned i1;\n\t\tfor(i1 = 1; i1 < encoder->protected_->num_metadata_blocks; i1++) {\n\t\t\tif(0 != encoder->protected_->metadata[i1] && encoder->protected_->metadata[i1]->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {\n\t\t\t\tFLAC__StreamMetadata *vc = encoder->protected_->metadata[i1];\n\t\t\t\tfor( ; i1 > 0; i1--)\n\t\t\t\t\tencoder->protected_->metadata[i1] = encoder->protected_->metadata[i1-1];\n\t\t\t\tencoder->protected_->metadata[0] = vc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/* keep track of any SEEKTABLE block */\n\tif(0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0) {\n\t\tunsigned i2;\n\t\tfor(i2 = 0; i2 < encoder->protected_->num_metadata_blocks; i2++) {\n\t\t\tif(0 != encoder->protected_->metadata[i2] && encoder->protected_->metadata[i2]->type == FLAC__METADATA_TYPE_SEEKTABLE) {\n\t\t\t\tencoder->private_->seek_table = &encoder->protected_->metadata[i2]->data.seek_table;\n\t\t\t\tbreak; /* take only the first one */\n\t\t\t}\n\t\t}\n\t}\n\n\t/* validate metadata */\n\tif(0 == encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\tmetadata_has_seektable = false;\n\tmetadata_has_vorbis_comment = false;\n\tmetadata_picture_has_type1 = false;\n\tmetadata_picture_has_type2 = false;\n\tfor(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\tconst FLAC__StreamMetadata *m = encoder->protected_->metadata[i];\n\t\tif(m->type == FLAC__METADATA_TYPE_STREAMINFO)\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\telse if(m->type == FLAC__METADATA_TYPE_SEEKTABLE) {\n\t\t\tif(metadata_has_seektable) /* only one is allowed */\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tmetadata_has_seektable = true;\n\t\t\tif(!FLAC__format_seektable_is_legal(&m->data.seek_table))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {\n\t\t\tif(metadata_has_vorbis_comment) /* only one is allowed */\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tmetadata_has_vorbis_comment = true;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_CUESHEET) {\n\t\t\tif(!FLAC__format_cuesheet_is_legal(&m->data.cue_sheet, m->data.cue_sheet.is_cd, /*violation=*/0))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t}\n\t\telse if(m->type == FLAC__METADATA_TYPE_PICTURE) {\n\t\t\tif(!FLAC__format_picture_is_legal(&m->data.picture, /*violation=*/0))\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\tif(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD) {\n\t\t\t\tif(metadata_picture_has_type1) /* there should only be 1 per stream */\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t\tmetadata_picture_has_type1 = true;\n\t\t\t\t/* standard icon must be 32x32 pixel PNG */\n\t\t\t\tif(\n\t\t\t\t\tm->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD &&\n\t\t\t\t\t(\n\t\t\t\t\t\t(strcmp(m->data.picture.mime_type, \"image/png\") && strcmp(m->data.picture.mime_type, \"-->\")) ||\n\t\t\t\t\t\tm->data.picture.width != 32 ||\n\t\t\t\t\t\tm->data.picture.height != 32\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t}\n\t\t\telse if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON) {\n\t\t\t\tif(metadata_picture_has_type2) /* there should only be 1 per stream */\n\t\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;\n\t\t\t\tmetadata_picture_has_type2 = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tencoder->private_->input_capacity = 0;\n\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\tencoder->private_->integer_signal_unaligned[i] = encoder->private_->integer_signal[i] = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tencoder->private_->real_signal_unaligned[i] = encoder->private_->real_signal[i] = 0;\n#endif\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->integer_signal_mid_side_unaligned[i] = encoder->private_->integer_signal_mid_side[i] = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tencoder->private_->real_signal_mid_side_unaligned[i] = encoder->private_->real_signal_mid_side[i] = 0;\n#endif\n\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tfor(i = 0; i < encoder->protected_->num_apodizations; i++)\n\t\tencoder->private_->window_unaligned[i] = encoder->private_->window[i] = 0;\n\tencoder->private_->windowed_signal_unaligned = encoder->private_->windowed_signal = 0;\n#endif\n\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\tencoder->private_->residual_workspace_unaligned[i][0] = encoder->private_->residual_workspace[i][0] = 0;\n\t\tencoder->private_->residual_workspace_unaligned[i][1] = encoder->private_->residual_workspace[i][1] = 0;\n\t\tencoder->private_->best_subframe[i] = 0;\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tencoder->private_->residual_workspace_mid_side_unaligned[i][0] = encoder->private_->residual_workspace_mid_side[i][0] = 0;\n\t\tencoder->private_->residual_workspace_mid_side_unaligned[i][1] = encoder->private_->residual_workspace_mid_side[i][1] = 0;\n\t\tencoder->private_->best_subframe_mid_side[i] = 0;\n\t}\n\tencoder->private_->abs_residual_partition_sums_unaligned = encoder->private_->abs_residual_partition_sums = 0;\n\tencoder->private_->raw_bits_per_partition_unaligned = encoder->private_->raw_bits_per_partition = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->loose_mid_side_stereo_frames = (unsigned)((double)encoder->protected_->sample_rate * 0.4 / (double)encoder->protected_->blocksize + 0.5);\n#else\n\t/* 26214 is the approximate fixed-point equivalent to 0.4 (0.4 * 2^16) */\n\t/* sample rate can be up to 655350 Hz, and thus use 20 bits, so we do the multiply&divide by hand */\n\tFLAC__ASSERT(FLAC__MAX_SAMPLE_RATE <= 655350);\n\tFLAC__ASSERT(FLAC__MAX_BLOCK_SIZE <= 65535);\n\tFLAC__ASSERT(encoder->protected_->sample_rate <= 655350);\n\tFLAC__ASSERT(encoder->protected_->blocksize <= 65535);\n\tencoder->private_->loose_mid_side_stereo_frames = (unsigned)FLAC__fixedpoint_trunc((((FLAC__uint64)(encoder->protected_->sample_rate) * (FLAC__uint64)(26214)) << 16) / (encoder->protected_->blocksize<<16) + FLAC__FP_ONE_HALF);\n#endif\n\tif(encoder->private_->loose_mid_side_stereo_frames == 0)\n\t\tencoder->private_->loose_mid_side_stereo_frames = 1;\n\tencoder->private_->loose_mid_side_stereo_frame_count = 0;\n\tencoder->private_->current_sample_number = 0;\n\tencoder->private_->current_frame_number = 0;\n\n\t/*\n\t * get the CPU info and set the function pointers\n\t */\n\tFLAC__cpu_info(&encoder->private_->cpuinfo);\n\t/* first default to the non-asm routines */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;\n#endif\n\tencoder->private_->local_precompute_partition_info_sums = precompute_partition_info_sums_;\n\tencoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor;\n\tencoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients;\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide;\n\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients;\n#endif\n\t/* now override with asm where appropriate */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n# ifndef FLAC__NO_ASM\n\tif(encoder->private_->cpuinfo.use_asm) {\n#  ifdef FLAC__CPU_IA32\n\t\tFLAC__ASSERT(encoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_IA32);\n#   ifdef FLAC__HAS_NASM\n\t\tif(encoder->private_->cpuinfo.ia32.sse) {\n\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_4_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_8_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_12_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 16)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_16_old;\n\t\t\telse\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;\n\t\t}\n\t\telse\n\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;\n\n\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide_asm_ia32; /* OPT_IA32: was really necessary for GCC < 4.9 */\n\t\tif(encoder->private_->cpuinfo.ia32.mmx) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx;\n\t\t}\n\t\telse {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;\n\t\t}\n\n\t\tif(encoder->private_->cpuinfo.ia32.mmx && encoder->private_->cpuinfo.ia32.cmov)\n\t\t\tencoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor_asm_ia32_mmx_cmov;\n#   endif /* FLAC__HAS_NASM */\n#   if FLAC__HAS_X86INTRIN\n#    if defined FLAC__SSE_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.sse) {\n\t\t\tif(encoder->private_->cpuinfo.ia32.sse42 || !encoder->private_->cpuinfo.ia32.intel) { /* use new autocorrelation functions */\n\t\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_4_new;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_8_new;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_12_new;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 16)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_16_new;\n\t\t\t\telse\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;\n\t\t\t}\n\t\t\telse { /* use old autocorrelation functions */\n\t\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_4_old;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_8_old;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_12_old;\n\t\t\t\telse if(encoder->protected_->max_lpc_order < 16)\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_16_old;\n\t\t\t\telse\n\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;\n\t\t\t}\n\t\t}\n#    endif\n\n#    ifdef FLAC__SSE2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.sse2) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients       = FLAC__lpc_compute_residual_from_qlp_coefficients_intrin_sse2;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_16_intrin_sse2;\n\t\t}\n#    endif\n#    ifdef FLAC__SSE4_1_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.sse41) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients       = FLAC__lpc_compute_residual_from_qlp_coefficients_intrin_sse41;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide_intrin_sse41;\n\t\t}\n#    endif\n#    ifdef FLAC__AVX2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.avx2) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_16_intrin_avx2;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients       = FLAC__lpc_compute_residual_from_qlp_coefficients_intrin_avx2;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide_intrin_avx2;\n\t\t}\n#    endif\n\n#    ifdef FLAC__SSE2_SUPPORTED\n\t\tif (encoder->private_->cpuinfo.ia32.sse2) {\n\t\t\tencoder->private_->local_fixed_compute_best_predictor      = FLAC__fixed_compute_best_predictor_intrin_sse2;\n\t\t\tencoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide_intrin_sse2;\n\t\t}\n#    endif\n#    ifdef FLAC__SSSE3_SUPPORTED\n\t\tif (encoder->private_->cpuinfo.ia32.ssse3) {\n\t\t\tencoder->private_->local_fixed_compute_best_predictor      = FLAC__fixed_compute_best_predictor_intrin_ssse3;\n\t\t\tencoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide_intrin_ssse3;\n\t\t}\n#    endif\n#   endif /* FLAC__HAS_X86INTRIN */\n#  elif defined FLAC__CPU_X86_64\n\t\tFLAC__ASSERT(encoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_X86_64);\n#   if FLAC__HAS_X86INTRIN\n#    ifdef FLAC__SSE_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.x86.sse42 || !encoder->private_->cpuinfo.x86.intel) { /* use new autocorrelation functions */\n\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_4_new;\n\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_8_new;\n\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_12_new;\n\t\t\telse if(encoder->protected_->max_lpc_order < 16)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_16_new;\n\t\t}\n\t\telse {\n\t\t\tif(encoder->protected_->max_lpc_order < 4)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_4_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 8)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_8_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 12)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_12_old;\n\t\t\telse if(encoder->protected_->max_lpc_order < 16)\n\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_intrin_sse_lag_16_old;\n\t\t}\n#    endif\n\n#    ifdef FLAC__SSE2_SUPPORTED\n\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_16_intrin_sse2;\n#    endif\n#    ifdef FLAC__SSE4_1_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.x86.sse41) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_intrin_sse41;\n\t\t}\n#    endif\n#    ifdef FLAC__AVX2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.x86.avx2) {\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_16_intrin_avx2;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients       = FLAC__lpc_compute_residual_from_qlp_coefficients_intrin_avx2;\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide_intrin_avx2;\n\t\t}\n#    endif\n\n#    ifdef FLAC__SSE2_SUPPORTED\n\t\tencoder->private_->local_fixed_compute_best_predictor      = FLAC__fixed_compute_best_predictor_intrin_sse2;\n\t\tencoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide_intrin_sse2;\n#    endif\n#    ifdef FLAC__SSSE3_SUPPORTED\n\t\tif (encoder->private_->cpuinfo.x86.ssse3) {\n\t\t\tencoder->private_->local_fixed_compute_best_predictor      = FLAC__fixed_compute_best_predictor_intrin_ssse3;\n\t\t\tencoder->private_->local_fixed_compute_best_predictor_wide = FLAC__fixed_compute_best_predictor_wide_intrin_ssse3;\n\t\t}\n#    endif\n#   endif /* FLAC__HAS_X86INTRIN */\n#  endif /* FLAC__CPU_... */\n\t}\n# endif /* !FLAC__NO_ASM */\n#endif /* !FLAC__INTEGER_ONLY_LIBRARY */\n#if !defined FLAC__NO_ASM && FLAC__HAS_X86INTRIN\n\tif(encoder->private_->cpuinfo.use_asm) {\n# if defined FLAC__CPU_IA32\n#  ifdef FLAC__SSE2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.sse2)\n\t\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_sse2;\n#  endif\n#  ifdef FLAC__SSSE3_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.ssse3)\n\t\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_ssse3;\n#  endif\n#  ifdef FLAC__AVX2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.ia32.avx2)\n\t\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_avx2;\n#  endif\n# elif defined FLAC__CPU_X86_64\n#  ifdef FLAC__SSE2_SUPPORTED\n\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_sse2;\n#  endif\n#  ifdef FLAC__SSSE3_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.x86.ssse3)\n\t\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_ssse3;\n#  endif\n#  ifdef FLAC__AVX2_SUPPORTED\n\t\tif(encoder->private_->cpuinfo.x86.avx2)\n\t\t\tencoder->private_->local_precompute_partition_info_sums = FLAC__precompute_partition_info_sums_intrin_avx2;\n#  endif\n# endif /* FLAC__CPU_... */\n\t}\n#endif /* !FLAC__NO_ASM && FLAC__HAS_X86INTRIN */\n\n\t/* set state to OK; from here on, errors are fatal and we'll override the state then */\n\tencoder->protected_->state = FLAC__STREAM_ENCODER_OK;\n\n#if FLAC__HAS_OGG\n\tencoder->private_->is_ogg = is_ogg;\n\tif(is_ogg && !FLAC__ogg_encoder_aspect_init(&encoder->protected_->ogg_encoder_aspect)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n#endif\n\n\tencoder->private_->read_callback = read_callback;\n\tencoder->private_->write_callback = write_callback;\n\tencoder->private_->seek_callback = seek_callback;\n\tencoder->private_->tell_callback = tell_callback;\n\tencoder->private_->metadata_callback = metadata_callback;\n\tencoder->private_->client_data = client_data;\n\n\tif(!resize_buffers_(encoder, encoder->protected_->blocksize)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\tif(!FLAC__bitwriter_init(encoder->private_->frame)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * Set up the verify stuff if necessary\n\t */\n\tif(encoder->protected_->verify) {\n\t\t/*\n\t\t * First, set up the fifo which will hold the\n\t\t * original signal to compare against\n\t\t */\n\t\tencoder->private_->verify.input_fifo.size = encoder->protected_->blocksize+OVERREAD_;\n\t\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\t\tif(0 == (encoder->private_->verify.input_fifo.data[i] = safe_malloc_mul_2op_p(sizeof(FLAC__int32), /*times*/encoder->private_->verify.input_fifo.size))) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t\t}\n\t\t}\n\t\tencoder->private_->verify.input_fifo.tail = 0;\n\n\t\t/*\n\t\t * Now set up a stream decoder for verification\n\t\t */\n\t\tif(0 == encoder->private_->verify.decoder) {\n\t\t\tencoder->private_->verify.decoder = FLAC__stream_decoder_new();\n\t\t\tif(0 == encoder->private_->verify.decoder) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t\t}\n\t\t}\n\n\t\tif(FLAC__stream_decoder_init_stream(encoder->private_->verify.decoder, verify_read_callback_, /*seek_callback=*/0, /*tell_callback=*/0, /*length_callback=*/0, /*eof_callback=*/0, verify_write_callback_, verify_metadata_callback_, verify_error_callback_, /*client_data=*/encoder) != FLAC__STREAM_DECODER_INIT_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\tencoder->private_->verify.error_stats.absolute_sample = 0;\n\tencoder->private_->verify.error_stats.frame_number = 0;\n\tencoder->private_->verify.error_stats.channel = 0;\n\tencoder->private_->verify.error_stats.sample = 0;\n\tencoder->private_->verify.error_stats.expected = 0;\n\tencoder->private_->verify.error_stats.got = 0;\n\n\t/*\n\t * These must be done before we write any metadata, because that\n\t * calls the write_callback, which uses these values.\n\t */\n\tencoder->private_->first_seekpoint_to_check = 0;\n\tencoder->private_->samples_written = 0;\n\tencoder->protected_->streaminfo_offset = 0;\n\tencoder->protected_->seektable_offset = 0;\n\tencoder->protected_->audio_offset = 0;\n\n\t/*\n\t * write the stream header\n\t */\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_MAGIC;\n\tif(!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, FLAC__STREAM_SYNC, FLAC__STREAM_SYNC_LEN)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * write the STREAMINFO metadata block\n\t */\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_METADATA;\n\tencoder->private_->streaminfo.type = FLAC__METADATA_TYPE_STREAMINFO;\n\tencoder->private_->streaminfo.is_last = false; /* we will have at a minimum a VORBIS_COMMENT afterwards */\n\tencoder->private_->streaminfo.length = FLAC__STREAM_METADATA_STREAMINFO_LENGTH;\n\tencoder->private_->streaminfo.data.stream_info.min_blocksize = encoder->protected_->blocksize; /* this encoder uses the same blocksize for the whole stream */\n\tencoder->private_->streaminfo.data.stream_info.max_blocksize = encoder->protected_->blocksize;\n\tencoder->private_->streaminfo.data.stream_info.min_framesize = 0; /* we don't know this yet; have to fill it in later */\n\tencoder->private_->streaminfo.data.stream_info.max_framesize = 0; /* we don't know this yet; have to fill it in later */\n\tencoder->private_->streaminfo.data.stream_info.sample_rate = encoder->protected_->sample_rate;\n\tencoder->private_->streaminfo.data.stream_info.channels = encoder->protected_->channels;\n\tencoder->private_->streaminfo.data.stream_info.bits_per_sample = encoder->protected_->bits_per_sample;\n\tencoder->private_->streaminfo.data.stream_info.total_samples = encoder->protected_->total_samples_estimate; /* we will replace this later with the real total */\n\tmemset(encoder->private_->streaminfo.data.stream_info.md5sum, 0, 16); /* we don't know this yet; have to fill it in later */\n\tif(encoder->protected_->do_md5)\n\t\tFLAC__MD5Init(&encoder->private_->md5context);\n\tif(!FLAC__add_metadata_block(&encoder->private_->streaminfo, encoder->private_->frame)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * Now that the STREAMINFO block is written, we can init this to an\n\t * absurdly-high value...\n\t */\n\tencoder->private_->streaminfo.data.stream_info.min_framesize = (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN) - 1;\n\t/* ... and clear this to 0 */\n\tencoder->private_->streaminfo.data.stream_info.total_samples = 0;\n\n\t/*\n\t * Check to see if the supplied metadata contains a VORBIS_COMMENT;\n\t * if not, we will write an empty one (FLAC__add_metadata_block()\n\t * automatically supplies the vendor string).\n\t *\n\t * WATCHOUT: the Ogg FLAC mapping requires us to write this block after\n\t * the STREAMINFO.  (In the case that metadata_has_vorbis_comment is\n\t * true it will have already insured that the metadata list is properly\n\t * ordered.)\n\t */\n\tif(!metadata_has_vorbis_comment) {\n\t\tFLAC__StreamMetadata vorbis_comment;\n\t\tvorbis_comment.type = FLAC__METADATA_TYPE_VORBIS_COMMENT;\n\t\tvorbis_comment.is_last = (encoder->protected_->num_metadata_blocks == 0);\n\t\tvorbis_comment.length = 4 + 4; /* MAGIC NUMBER */\n\t\tvorbis_comment.data.vorbis_comment.vendor_string.length = 0;\n\t\tvorbis_comment.data.vorbis_comment.vendor_string.entry = 0;\n\t\tvorbis_comment.data.vorbis_comment.num_comments = 0;\n\t\tvorbis_comment.data.vorbis_comment.comments = 0;\n\t\tif(!FLAC__add_metadata_block(&vorbis_comment, encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t\t/* the above function sets the state for us in case of an error */\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * write the user's metadata blocks\n\t */\n\tfor(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {\n\t\tencoder->protected_->metadata[i]->is_last = (i == encoder->protected_->num_metadata_blocks - 1);\n\t\tif(!FLAC__add_metadata_block(encoder->protected_->metadata[i], encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t\tif(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {\n\t\t\t/* the above function sets the state for us in case of an error */\n\t\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t\t}\n\t}\n\n\t/* now that all the metadata is written, we save the stream offset */\n\tif(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &encoder->protected_->audio_offset, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) { /* FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED just means we didn't get the offset; no error */\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\tif(encoder->protected_->verify)\n\t\tencoder->private_->verify.state_hint = ENCODER_IN_AUDIO;\n\n\treturn FLAC__STREAM_ENCODER_INIT_STATUS_OK;\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(\n\tFLAC__StreamEncoder *encoder,\n\tFLAC__StreamEncoderWriteCallback write_callback,\n\tFLAC__StreamEncoderSeekCallback seek_callback,\n\tFLAC__StreamEncoderTellCallback tell_callback,\n\tFLAC__StreamEncoderMetadataCallback metadata_callback,\n\tvoid *client_data\n)\n{\n\treturn init_stream_internal_(\n\t\tencoder,\n\t\t/*read_callback=*/0,\n\t\twrite_callback,\n\t\tseek_callback,\n\t\ttell_callback,\n\t\tmetadata_callback,\n\t\tclient_data,\n\t\t/*is_ogg=*/false\n\t);\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(\n\tFLAC__StreamEncoder *encoder,\n\tFLAC__StreamEncoderReadCallback read_callback,\n\tFLAC__StreamEncoderWriteCallback write_callback,\n\tFLAC__StreamEncoderSeekCallback seek_callback,\n\tFLAC__StreamEncoderTellCallback tell_callback,\n\tFLAC__StreamEncoderMetadataCallback metadata_callback,\n\tvoid *client_data\n)\n{\n\treturn init_stream_internal_(\n\t\tencoder,\n\t\tread_callback,\n\t\twrite_callback,\n\t\tseek_callback,\n\t\ttell_callback,\n\t\tmetadata_callback,\n\t\tclient_data,\n\t\t/*is_ogg=*/true\n\t);\n}\n\nstatic FLAC__StreamEncoderInitStatus init_FILE_internal_(\n\tFLAC__StreamEncoder *encoder,\n\tFILE *file,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tFLAC__StreamEncoderInitStatus init_status;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != file);\n\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\t/* double protection */\n\tif(file == 0) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\t/*\n\t * To make sure that our file does not go unclosed after an error, we\n\t * must assign the FILE pointer before any further error can occur in\n\t * this routine.\n\t */\n\tif(file == stdout)\n\t\tfile = get_binary_stdout_(); /* just to be safe */\n\n#ifdef _WIN32\n\t/*\n\t * Windows can suffer quite badly from disk fragmentation. This can be\n\t * reduced significantly by setting the output buffer size to be 10MB.\n\t */\n\tif(GetFileType((HANDLE)_get_osfhandle(_fileno(file))) == FILE_TYPE_DISK)\n\t\tsetvbuf(file, NULL, _IOFBF, 10*1024*1024);\n#endif\n\tencoder->private_->file = file;\n\n\tencoder->private_->progress_callback = progress_callback;\n\tencoder->private_->bytes_written = 0;\n\tencoder->private_->samples_written = 0;\n\tencoder->private_->frames_written = 0;\n\n\tinit_status = init_stream_internal_(\n\t\tencoder,\n\t\tencoder->private_->file == stdout? 0 : is_ogg? file_read_callback_ : 0,\n\t\tfile_write_callback_,\n\t\tencoder->private_->file == stdout? 0 : file_seek_callback_,\n\t\tencoder->private_->file == stdout? 0 : file_tell_callback_,\n\t\t/*metadata_callback=*/0,\n\t\tclient_data,\n\t\tis_ogg\n\t);\n\tif(init_status != FLAC__STREAM_ENCODER_INIT_STATUS_OK) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn init_status;\n\t}\n\n\t{\n\t\tunsigned blocksize = FLAC__stream_encoder_get_blocksize(encoder);\n\n\t\tFLAC__ASSERT(blocksize != 0);\n\t\tencoder->private_->total_frames_estimate = (unsigned)((FLAC__stream_encoder_get_total_samples_estimate(encoder) + blocksize - 1) / blocksize);\n\t}\n\n\treturn init_status;\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(\n\tFLAC__StreamEncoder *encoder,\n\tFILE *file,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data\n)\n{\n\treturn init_FILE_internal_(encoder, file, progress_callback, client_data, /*is_ogg=*/false);\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(\n\tFLAC__StreamEncoder *encoder,\n\tFILE *file,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data\n)\n{\n\treturn init_FILE_internal_(encoder, file, progress_callback, client_data, /*is_ogg=*/true);\n}\n\nstatic FLAC__StreamEncoderInitStatus init_file_internal_(\n\tFLAC__StreamEncoder *encoder,\n\tconst char *filename,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data,\n\tFLAC__bool is_ogg\n)\n{\n\tFILE *file;\n\n\tFLAC__ASSERT(0 != encoder);\n\n\t/*\n\t * To make sure that our file does not go unclosed after an error, we\n\t * have to do the same entrance checks here that are later performed\n\t * in FLAC__stream_encoder_init_FILE() before the FILE* is assigned.\n\t */\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;\n\n\tfile = filename? flac_fopen(filename, \"w+b\") : stdout;\n\n\tif(file == 0) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;\n\t}\n\n\treturn init_FILE_internal_(encoder, file, progress_callback, client_data, is_ogg);\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(\n\tFLAC__StreamEncoder *encoder,\n\tconst char *filename,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data\n)\n{\n\treturn init_file_internal_(encoder, filename, progress_callback, client_data, /*is_ogg=*/false);\n}\n\nFLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(\n\tFLAC__StreamEncoder *encoder,\n\tconst char *filename,\n\tFLAC__StreamEncoderProgressCallback progress_callback,\n\tvoid *client_data\n)\n{\n\treturn init_file_internal_(encoder, filename, progress_callback, client_data, /*is_ogg=*/true);\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder)\n{\n\tFLAC__bool error = false;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\n\tif(encoder->protected_->state == FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn true;\n\n\tif(encoder->protected_->state == FLAC__STREAM_ENCODER_OK && !encoder->private_->is_being_deleted) {\n\t\tif(encoder->private_->current_sample_number != 0) {\n\t\t\tconst FLAC__bool is_fractional_block = encoder->protected_->blocksize != encoder->private_->current_sample_number;\n\t\t\tencoder->protected_->blocksize = encoder->private_->current_sample_number;\n\t\t\tif(!process_frame_(encoder, is_fractional_block, /*is_last_block=*/true))\n\t\t\t\terror = true;\n\t\t}\n\t}\n\n\tif(encoder->protected_->do_md5)\n\t\tFLAC__MD5Final(encoder->private_->streaminfo.data.stream_info.md5sum, &encoder->private_->md5context);\n\n\tif(!encoder->private_->is_being_deleted) {\n\t\tif(encoder->protected_->state == FLAC__STREAM_ENCODER_OK) {\n\t\t\tif(encoder->private_->seek_callback) {\n#if FLAC__HAS_OGG\n\t\t\t\tif(encoder->private_->is_ogg)\n\t\t\t\t\tupdate_ogg_metadata_(encoder);\n\t\t\t\telse\n#endif\n\t\t\t\tupdate_metadata_(encoder);\n\n\t\t\t\t/* check if an error occurred while updating metadata */\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_OK)\n\t\t\t\t\terror = true;\n\t\t\t}\n\t\t\tif(encoder->private_->metadata_callback)\n\t\t\t\tencoder->private_->metadata_callback(encoder, &encoder->private_->streaminfo, encoder->private_->client_data);\n\t\t}\n\n\t\tif(encoder->protected_->verify && 0 != encoder->private_->verify.decoder && !FLAC__stream_decoder_finish(encoder->private_->verify.decoder)) {\n\t\t\tif(!error)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;\n\t\t\terror = true;\n\t\t}\n\t}\n\n\tif(0 != encoder->private_->file) {\n\t\tif(encoder->private_->file != stdout)\n\t\t\tfclose(encoder->private_->file);\n\t\tencoder->private_->file = 0;\n\t}\n\n#if FLAC__HAS_OGG\n\tif(encoder->private_->is_ogg)\n\t\tFLAC__ogg_encoder_aspect_finish(&encoder->protected_->ogg_encoder_aspect);\n#endif\n\n\tfree_(encoder);\n\tset_defaults_(encoder);\n\n\tif(!error)\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;\n\n\treturn !error;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder, long value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#if FLAC__HAS_OGG\n\t/* can't check encoder->private_->is_ogg since that's not set until init time */\n\tFLAC__ogg_encoder_aspect_set_serial_number(&encoder->protected_->ogg_encoder_aspect, value);\n\treturn true;\n#else\n\t(void)value;\n\treturn false;\n#endif\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#ifndef FLAC__MANDATORY_VERIFY_WHILE_ENCODING\n\tencoder->protected_->verify = value;\n#endif\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->streamable_subset = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_do_md5(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->do_md5 = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->channels = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->bits_per_sample = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->sample_rate = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__bool ok = true;\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tif(value >= sizeof(compression_levels_)/sizeof(compression_levels_[0]))\n\t\tvalue = sizeof(compression_levels_)/sizeof(compression_levels_[0]) - 1;\n\tok &= FLAC__stream_encoder_set_do_mid_side_stereo          (encoder, compression_levels_[value].do_mid_side_stereo);\n\tok &= FLAC__stream_encoder_set_loose_mid_side_stereo       (encoder, compression_levels_[value].loose_mid_side_stereo);\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n#if 1\n\tok &= FLAC__stream_encoder_set_apodization                 (encoder, compression_levels_[value].apodization);\n#else\n\t/* equivalent to -A tukey(0.5) */\n\tencoder->protected_->num_apodizations = 1;\n\tencoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;\n\tencoder->protected_->apodizations[0].parameters.tukey.p = 0.5;\n#endif\n#endif\n\tok &= FLAC__stream_encoder_set_max_lpc_order               (encoder, compression_levels_[value].max_lpc_order);\n\tok &= FLAC__stream_encoder_set_qlp_coeff_precision         (encoder, compression_levels_[value].qlp_coeff_precision);\n\tok &= FLAC__stream_encoder_set_do_qlp_coeff_prec_search    (encoder, compression_levels_[value].do_qlp_coeff_prec_search);\n\tok &= FLAC__stream_encoder_set_do_escape_coding            (encoder, compression_levels_[value].do_escape_coding);\n\tok &= FLAC__stream_encoder_set_do_exhaustive_model_search  (encoder, compression_levels_[value].do_exhaustive_model_search);\n\tok &= FLAC__stream_encoder_set_min_residual_partition_order(encoder, compression_levels_[value].min_residual_partition_order);\n\tok &= FLAC__stream_encoder_set_max_residual_partition_order(encoder, compression_levels_[value].max_residual_partition_order);\n\tok &= FLAC__stream_encoder_set_rice_parameter_search_dist  (encoder, compression_levels_[value].rice_parameter_search_dist);\n\treturn ok;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->blocksize = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->do_mid_side_stereo = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->loose_mid_side_stereo = value;\n\treturn true;\n}\n\n/*@@@@add to tests*/\nFLAC_API FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(0 != specification);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#ifdef FLAC__INTEGER_ONLY_LIBRARY\n\t(void)specification; /* silently ignore since we haven't integerized; will always use a rectangular window */\n#else\n\tencoder->protected_->num_apodizations = 0;\n\twhile(1) {\n\t\tconst char *s = strchr(specification, ';');\n\t\tconst size_t n = s? (size_t)(s - specification) : strlen(specification);\n\t\tif     (n==8  && 0 == strncmp(\"bartlett\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT;\n\t\telse if(n==13 && 0 == strncmp(\"bartlett_hann\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT_HANN;\n\t\telse if(n==8  && 0 == strncmp(\"blackman\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN;\n\t\telse if(n==26 && 0 == strncmp(\"blackman_harris_4term_92db\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE;\n\t\telse if(n==6  && 0 == strncmp(\"connes\"       , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_CONNES;\n\t\telse if(n==7  && 0 == strncmp(\"flattop\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_FLATTOP;\n\t\telse if(n>7   && 0 == strncmp(\"gauss(\"       , specification, 6)) {\n\t\t\tFLAC__real stddev = (FLAC__real)strtod(specification+6, 0);\n\t\t\tif (stddev > 0.0 && stddev <= 0.5) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.gauss.stddev = stddev;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_GAUSS;\n\t\t\t}\n\t\t}\n\t\telse if(n==7  && 0 == strncmp(\"hamming\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HAMMING;\n\t\telse if(n==4  && 0 == strncmp(\"hann\"         , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HANN;\n\t\telse if(n==13 && 0 == strncmp(\"kaiser_bessel\", specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_KAISER_BESSEL;\n\t\telse if(n==7  && 0 == strncmp(\"nuttall\"      , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_NUTTALL;\n\t\telse if(n==9  && 0 == strncmp(\"rectangle\"    , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_RECTANGLE;\n\t\telse if(n==8  && 0 == strncmp(\"triangle\"     , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TRIANGLE;\n\t\telse if(n>7   && 0 == strncmp(\"tukey(\"       , specification, 6)) {\n\t\t\tFLAC__real p = (FLAC__real)strtod(specification+6, 0);\n\t\t\tif (p >= 0.0 && p <= 1.0) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = p;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;\n\t\t\t}\n\t\t}\n\t\telse if(n>15   && 0 == strncmp(\"partial_tukey(\"       , specification, 14)) {\n\t\t\tFLAC__int32 tukey_parts = (FLAC__int32)strtod(specification+14, 0);\n\t\t\tconst char *si_1 = strchr(specification, '/');\n\t\t\tFLAC__real overlap = si_1?flac_min((FLAC__real)strtod(si_1+1, 0),0.99f):0.1f;\n\t\t\tFLAC__real overlap_units = 1.0f/(1.0f - overlap) - 1.0f;\n\t\t\tconst char *si_2 = strchr((si_1?(si_1+1):specification), '/');\n\t\t\tFLAC__real tukey_p = si_2?(FLAC__real)strtod(si_2+1, 0):0.2f;\n\n\t\t\tif (tukey_parts <= 1) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = tukey_p;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;\n\t\t\t}else if (encoder->protected_->num_apodizations + tukey_parts < 32){\n\t\t\t\tFLAC__int32 m;\n\t\t\t\tfor(m = 0; m < tukey_parts; m++){\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.p = tukey_p;\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.start = m/(tukey_parts+overlap_units);\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.end = (m+1+overlap_units)/(tukey_parts+overlap_units);\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_PARTIAL_TUKEY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(n>16   && 0 == strncmp(\"punchout_tukey(\"       , specification, 15)) {\n\t\t\tFLAC__int32 tukey_parts = (FLAC__int32)strtod(specification+15, 0);\n\t\t\tconst char *si_1 = strchr(specification, '/');\n\t\t\tFLAC__real overlap = si_1?flac_min((FLAC__real)strtod(si_1+1, 0),0.99f):0.2f;\n\t\t\tFLAC__real overlap_units = 1.0f/(1.0f - overlap) - 1.0f;\n\t\t\tconst char *si_2 = strchr((si_1?(si_1+1):specification), '/');\n\t\t\tFLAC__real tukey_p = si_2?(FLAC__real)strtod(si_2+1, 0):0.2f;\n\n\t\t\tif (tukey_parts <= 1) {\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = tukey_p;\n\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;\n\t\t\t}else if (encoder->protected_->num_apodizations + tukey_parts < 32){\n\t\t\t\tFLAC__int32 m;\n\t\t\t\tfor(m = 0; m < tukey_parts; m++){\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.p = tukey_p;\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.start = m/(tukey_parts+overlap_units);\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.multiple_tukey.end = (m+1+overlap_units)/(tukey_parts+overlap_units);\n\t\t\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_PUNCHOUT_TUKEY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(n==5  && 0 == strncmp(\"welch\"        , specification, n))\n\t\t\tencoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_WELCH;\n\t\tif (encoder->protected_->num_apodizations == 32)\n\t\t\tbreak;\n\t\tif (s)\n\t\t\tspecification = s+1;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif(encoder->protected_->num_apodizations == 0) {\n\t\tencoder->protected_->num_apodizations = 1;\n\t\tencoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;\n\t\tencoder->protected_->apodizations[0].parameters.tukey.p = 0.5;\n\t}\n#endif\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->max_lpc_order = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->qlp_coeff_precision = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->do_qlp_coeff_prec_search = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#if 0\n\t/*@@@ deprecated: */\n\tencoder->protected_->do_escape_coding = value;\n#else\n\t(void)value;\n#endif\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->do_exhaustive_model_search = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->min_residual_partition_order = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->max_residual_partition_order = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder, unsigned value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n#if 0\n\t/*@@@ deprecated: */\n\tencoder->protected_->rice_parameter_search_dist = value;\n#else\n\t(void)value;\n#endif\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder, FLAC__uint64 value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tvalue = flac_min(value, (FLAC__U64L(1) << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN) - 1);\n\tencoder->protected_->total_samples_estimate = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder, FLAC__StreamMetadata **metadata, unsigned num_blocks)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tif(0 == metadata)\n\t\tnum_blocks = 0;\n\tif(0 == num_blocks)\n\t\tmetadata = 0;\n\t/* realloc() does not do exactly what we want so... */\n\tif(encoder->protected_->metadata) {\n\t\tfree(encoder->protected_->metadata);\n\t\tencoder->protected_->metadata = 0;\n\t\tencoder->protected_->num_metadata_blocks = 0;\n\t}\n\tif(num_blocks) {\n\t\tFLAC__StreamMetadata **m;\n\t\tif(0 == (m = safe_malloc_mul_2op_p(sizeof(m[0]), /*times*/num_blocks)))\n\t\t\treturn false;\n\t\tmemcpy(m, metadata, sizeof(m[0]) * num_blocks);\n\t\tencoder->protected_->metadata = m;\n\t\tencoder->protected_->num_metadata_blocks = num_blocks;\n\t}\n#if FLAC__HAS_OGG\n\tif(!FLAC__ogg_encoder_aspect_set_num_metadata(&encoder->protected_->ogg_encoder_aspect, num_blocks))\n\t\treturn false;\n#endif\n\treturn true;\n}\n\n/*\n * These three functions are not static, but not publically exposed in\n * include/FLAC/ either.  They are used by the test suite.\n */\nFLAC_API FLAC__bool FLAC__stream_encoder_disable_constant_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->private_->disable_constant_subframes = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_disable_fixed_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->private_->disable_fixed_subframes = value;\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_disable_verbatim_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->private_->disable_verbatim_subframes = value;\n\treturn true;\n}\n\nFLAC_API FLAC__StreamEncoderState FLAC__stream_encoder_get_state(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->state;\n}\n\nFLAC_API FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->verify)\n\t\treturn FLAC__stream_decoder_get_state(encoder->private_->verify.decoder);\n\telse\n\t\treturn FLAC__STREAM_DECODER_UNINITIALIZED;\n}\n\nFLAC_API const char *FLAC__stream_encoder_get_resolved_state_string(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR)\n\t\treturn FLAC__StreamEncoderStateString[encoder->protected_->state];\n\telse\n\t\treturn FLAC__stream_decoder_get_resolved_state_string(encoder->private_->verify.decoder);\n}\n\nFLAC_API void FLAC__stream_encoder_get_verify_decoder_error_stats(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_sample, unsigned *frame_number, unsigned *channel, unsigned *sample, FLAC__int32 *expected, FLAC__int32 *got)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(0 != absolute_sample)\n\t\t*absolute_sample = encoder->private_->verify.error_stats.absolute_sample;\n\tif(0 != frame_number)\n\t\t*frame_number = encoder->private_->verify.error_stats.frame_number;\n\tif(0 != channel)\n\t\t*channel = encoder->private_->verify.error_stats.channel;\n\tif(0 != sample)\n\t\t*sample = encoder->private_->verify.error_stats.sample;\n\tif(0 != expected)\n\t\t*expected = encoder->private_->verify.error_stats.expected;\n\tif(0 != got)\n\t\t*got = encoder->private_->verify.error_stats.got;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_verify(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->verify;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_streamable_subset(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->streamable_subset;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_do_md5(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->do_md5;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_channels(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->channels;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_bits_per_sample(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->bits_per_sample;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_sample_rate(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->sample_rate;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_blocksize(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->blocksize;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->do_mid_side_stereo;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->loose_mid_side_stereo;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_max_lpc_order(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->max_lpc_order;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_qlp_coeff_precision(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->qlp_coeff_precision;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->do_qlp_coeff_prec_search;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_do_escape_coding(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->do_escape_coding;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->do_exhaustive_model_search;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_min_residual_partition_order(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->min_residual_partition_order;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_max_residual_partition_order(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->max_residual_partition_order;\n}\n\nFLAC_API unsigned FLAC__stream_encoder_get_rice_parameter_search_dist(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->rice_parameter_search_dist;\n}\n\nFLAC_API FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\treturn encoder->protected_->total_samples_estimate;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], unsigned samples)\n{\n\tunsigned i, j = 0, channel;\n\tconst unsigned channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tdo {\n\t\tconst unsigned n = flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j);\n\n\t\tif(encoder->protected_->verify)\n\t\t\tappend_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);\n\n\t\tfor(channel = 0; channel < channels; channel++) {\n\t\t\tif (buffer[channel] == NULL) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(&encoder->private_->integer_signal[channel][encoder->private_->current_sample_number], &buffer[channel][j], sizeof(buffer[channel][0]) * n);\n\t\t}\n\n\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\tFLAC__ASSERT(channels == 2);\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = buffer[0][j] - buffer[1][j];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = (buffer[0][j] + buffer[1][j]) >> 1; /* NOTE: not the same as 'mid = (buffer[0][j] + buffer[1][j]) / 2' ! */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tj += n;\n\n\t\tencoder->private_->current_sample_number += n;\n\n\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\tif(encoder->private_->current_sample_number > blocksize) {\n\t\t\tFLAC__ASSERT(encoder->private_->current_sample_number == blocksize+OVERREAD_);\n\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\treturn false;\n\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\tif(encoder->protected_->do_mid_side_stereo) {\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = 1;\n\t\t}\n\t} while(j < samples);\n\n\treturn true;\n}\n\nFLAC_API FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], unsigned samples)\n{\n\tunsigned i, j, k, channel;\n\tFLAC__int32 x, mid, side;\n\tconst unsigned channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;\n\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\tj = k = 0;\n\t/*\n\t * we have several flavors of the same basic loop, optimized for\n\t * different conditions:\n\t */\n\tif(encoder->protected_->do_mid_side_stereo && channels == 2) {\n\t\t/*\n\t\t * stereo coding: unroll channel loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tencoder->private_->integer_signal[0][i] = mid = side = buffer[k++];\n\t\t\t\tx = buffer[k++];\n\t\t\t\tencoder->private_->integer_signal[1][i] = x;\n\t\t\t\tmid += x;\n\t\t\t\tside -= x;\n\t\t\t\tmid >>= 1; /* NOTE: not the same as 'mid = (left + right) / 2' ! */\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][i] = side;\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][i] = mid;\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tencoder->private_->integer_signal[0][0] = encoder->private_->integer_signal[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal[1][0] = encoder->private_->integer_signal[1][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];\n\t\t\t\tencoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\telse {\n\t\t/*\n\t\t * independent channel coding: buffer each channel in inner loop\n\t\t */\n\t\tdo {\n\t\t\tif(encoder->protected_->verify)\n\t\t\t\tappend_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, flac_min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));\n\n\t\t\t/* \"i <= blocksize\" to overread 1 sample; see comment in OVERREAD_ decl */\n\t\t\tfor(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {\n\t\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\t\tencoder->private_->integer_signal[channel][i] = buffer[k++];\n\t\t\t}\n\t\t\tencoder->private_->current_sample_number = i;\n\t\t\t/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */\n\t\t\tif(i > blocksize) {\n\t\t\t\tif(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))\n\t\t\t\t\treturn false;\n\t\t\t\t/* move unprocessed overread samples to beginnings of arrays */\n\t\t\t\tFLAC__ASSERT(i == blocksize+OVERREAD_);\n\t\t\t\tFLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */\n\t\t\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\t\t\tencoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];\n\t\t\t\tencoder->private_->current_sample_number = 1;\n\t\t\t}\n\t\t} while(j < samples);\n\t}\n\n\treturn true;\n}\n\n/***********************************************************************\n *\n * Private class methods\n *\n ***********************************************************************/\n\nvoid set_defaults_(FLAC__StreamEncoder *encoder)\n{\n\tFLAC__ASSERT(0 != encoder);\n\n#ifdef FLAC__MANDATORY_VERIFY_WHILE_ENCODING\n\tencoder->protected_->verify = true;\n#else\n\tencoder->protected_->verify = false;\n#endif\n\tencoder->protected_->streamable_subset = true;\n\tencoder->protected_->do_md5 = true;\n\tencoder->protected_->do_mid_side_stereo = false;\n\tencoder->protected_->loose_mid_side_stereo = false;\n\tencoder->protected_->channels = 2;\n\tencoder->protected_->bits_per_sample = 16;\n\tencoder->protected_->sample_rate = 44100;\n\tencoder->protected_->blocksize = 0;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tencoder->protected_->num_apodizations = 1;\n\tencoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;\n\tencoder->protected_->apodizations[0].parameters.tukey.p = 0.5;\n#endif\n\tencoder->protected_->max_lpc_order = 0;\n\tencoder->protected_->qlp_coeff_precision = 0;\n\tencoder->protected_->do_qlp_coeff_prec_search = false;\n\tencoder->protected_->do_exhaustive_model_search = false;\n\tencoder->protected_->do_escape_coding = false;\n\tencoder->protected_->min_residual_partition_order = 0;\n\tencoder->protected_->max_residual_partition_order = 0;\n\tencoder->protected_->rice_parameter_search_dist = 0;\n\tencoder->protected_->total_samples_estimate = 0;\n\tencoder->protected_->metadata = 0;\n\tencoder->protected_->num_metadata_blocks = 0;\n\n\tencoder->private_->seek_table = 0;\n\tencoder->private_->disable_constant_subframes = false;\n\tencoder->private_->disable_fixed_subframes = false;\n\tencoder->private_->disable_verbatim_subframes = false;\n\tencoder->private_->is_ogg = false;\n\tencoder->private_->read_callback = 0;\n\tencoder->private_->write_callback = 0;\n\tencoder->private_->seek_callback = 0;\n\tencoder->private_->tell_callback = 0;\n\tencoder->private_->metadata_callback = 0;\n\tencoder->private_->progress_callback = 0;\n\tencoder->private_->client_data = 0;\n\n#if FLAC__HAS_OGG\n\tFLAC__ogg_encoder_aspect_set_defaults(&encoder->protected_->ogg_encoder_aspect);\n#endif\n\n\tFLAC__stream_encoder_set_compression_level(encoder, 5);\n}\n\nvoid free_(FLAC__StreamEncoder *encoder)\n{\n\tunsigned i, channel;\n\n\tFLAC__ASSERT(0 != encoder);\n\tif(encoder->protected_->metadata) {\n\t\tfree(encoder->protected_->metadata);\n\t\tencoder->protected_->metadata = 0;\n\t\tencoder->protected_->num_metadata_blocks = 0;\n\t}\n\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\tif(0 != encoder->private_->integer_signal_unaligned[i]) {\n\t\t\tfree(encoder->private_->integer_signal_unaligned[i]);\n\t\t\tencoder->private_->integer_signal_unaligned[i] = 0;\n\t\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tif(0 != encoder->private_->real_signal_unaligned[i]) {\n\t\t\tfree(encoder->private_->real_signal_unaligned[i]);\n\t\t\tencoder->private_->real_signal_unaligned[i] = 0;\n\t\t}\n#endif\n\t}\n\tfor(i = 0; i < 2; i++) {\n\t\tif(0 != encoder->private_->integer_signal_mid_side_unaligned[i]) {\n\t\t\tfree(encoder->private_->integer_signal_mid_side_unaligned[i]);\n\t\t\tencoder->private_->integer_signal_mid_side_unaligned[i] = 0;\n\t\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\tif(0 != encoder->private_->real_signal_mid_side_unaligned[i]) {\n\t\t\tfree(encoder->private_->real_signal_mid_side_unaligned[i]);\n\t\t\tencoder->private_->real_signal_mid_side_unaligned[i] = 0;\n\t\t}\n#endif\n\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tfor(i = 0; i < encoder->protected_->num_apodizations; i++) {\n\t\tif(0 != encoder->private_->window_unaligned[i]) {\n\t\t\tfree(encoder->private_->window_unaligned[i]);\n\t\t\tencoder->private_->window_unaligned[i] = 0;\n\t\t}\n\t}\n\tif(0 != encoder->private_->windowed_signal_unaligned) {\n\t\tfree(encoder->private_->windowed_signal_unaligned);\n\t\tencoder->private_->windowed_signal_unaligned = 0;\n\t}\n#endif\n\tfor(channel = 0; channel < encoder->protected_->channels; channel++) {\n\t\tfor(i = 0; i < 2; i++) {\n\t\t\tif(0 != encoder->private_->residual_workspace_unaligned[channel][i]) {\n\t\t\t\tfree(encoder->private_->residual_workspace_unaligned[channel][i]);\n\t\t\t\tencoder->private_->residual_workspace_unaligned[channel][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(channel = 0; channel < 2; channel++) {\n\t\tfor(i = 0; i < 2; i++) {\n\t\t\tif(0 != encoder->private_->residual_workspace_mid_side_unaligned[channel][i]) {\n\t\t\t\tfree(encoder->private_->residual_workspace_mid_side_unaligned[channel][i]);\n\t\t\t\tencoder->private_->residual_workspace_mid_side_unaligned[channel][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif(0 != encoder->private_->abs_residual_partition_sums_unaligned) {\n\t\tfree(encoder->private_->abs_residual_partition_sums_unaligned);\n\t\tencoder->private_->abs_residual_partition_sums_unaligned = 0;\n\t}\n\tif(0 != encoder->private_->raw_bits_per_partition_unaligned) {\n\t\tfree(encoder->private_->raw_bits_per_partition_unaligned);\n\t\tencoder->private_->raw_bits_per_partition_unaligned = 0;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tfor(i = 0; i < encoder->protected_->channels; i++) {\n\t\t\tif(0 != encoder->private_->verify.input_fifo.data[i]) {\n\t\t\t\tfree(encoder->private_->verify.input_fifo.data[i]);\n\t\t\t\tencoder->private_->verify.input_fifo.data[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tFLAC__bitwriter_free(encoder->private_->frame);\n}\n\nFLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, unsigned new_blocksize)\n{\n\tFLAC__bool ok;\n\tunsigned i, channel;\n\n\tFLAC__ASSERT(new_blocksize > 0);\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\tFLAC__ASSERT(encoder->private_->current_sample_number == 0);\n\n\t/* To avoid excessive malloc'ing, we only grow the buffer; no shrinking. */\n\tif(new_blocksize <= encoder->private_->input_capacity)\n\t\treturn true;\n\n\tok = true;\n\n\t/* WATCHOUT: FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx() and ..._intrin_sse2()\n\t * require that the input arrays (in our case the integer signals)\n\t * have a buffer of up to 3 zeroes in front (at negative indices) for\n\t * alignment purposes; we use 4 in front to keep the data well-aligned.\n\t */\n\n\tfor(i = 0; ok && i < encoder->protected_->channels; i++) {\n\t\tok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_unaligned[i], &encoder->private_->integer_signal[i]);\n\t\tmemset(encoder->private_->integer_signal[i], 0, sizeof(FLAC__int32)*4);\n\t\tencoder->private_->integer_signal[i] += 4;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n#if 0 /* @@@ currently unused */\n\t\tif(encoder->protected_->max_lpc_order > 0)\n\t\t\tok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize+OVERREAD_, &encoder->private_->real_signal_unaligned[i], &encoder->private_->real_signal[i]);\n#endif\n#endif\n\t}\n\tfor(i = 0; ok && i < 2; i++) {\n\t\tok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_mid_side_unaligned[i], &encoder->private_->integer_signal_mid_side[i]);\n\t\tmemset(encoder->private_->integer_signal_mid_side[i], 0, sizeof(FLAC__int32)*4);\n\t\tencoder->private_->integer_signal_mid_side[i] += 4;\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n#if 0 /* @@@ currently unused */\n\t\tif(encoder->protected_->max_lpc_order > 0)\n\t\t\tok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize+OVERREAD_, &encoder->private_->real_signal_mid_side_unaligned[i], &encoder->private_->real_signal_mid_side[i]);\n#endif\n#endif\n\t}\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tif(ok && encoder->protected_->max_lpc_order > 0) {\n\t\tfor(i = 0; ok && i < encoder->protected_->num_apodizations; i++)\n\t\t\tok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->window_unaligned[i], &encoder->private_->window[i]);\n\t\tok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->windowed_signal_unaligned, &encoder->private_->windowed_signal);\n\t}\n#endif\n\tfor(channel = 0; ok && channel < encoder->protected_->channels; channel++) {\n\t\tfor(i = 0; ok && i < 2; i++) {\n\t\t\tok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_unaligned[channel][i], &encoder->private_->residual_workspace[channel][i]);\n\t\t}\n\t}\n\tfor(channel = 0; ok && channel < 2; channel++) {\n\t\tfor(i = 0; ok && i < 2; i++) {\n\t\t\tok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_mid_side_unaligned[channel][i], &encoder->private_->residual_workspace_mid_side[channel][i]);\n\t\t}\n\t}\n\t/* the *2 is an approximation to the series 1 + 1/2 + 1/4 + ... that sums tree occupies in a flat array */\n\t/*@@@ new_blocksize*2 is too pessimistic, but to fix, we need smarter logic because a smaller new_blocksize can actually increase the # of partitions; would require moving this out into a separate function, then checking its capacity against the need of the current blocksize&min/max_partition_order (and maybe predictor order) */\n\tok = ok && FLAC__memory_alloc_aligned_uint64_array(new_blocksize * 2, &encoder->private_->abs_residual_partition_sums_unaligned, &encoder->private_->abs_residual_partition_sums);\n\tif(encoder->protected_->do_escape_coding)\n\t\tok = ok && FLAC__memory_alloc_aligned_unsigned_array(new_blocksize * 2, &encoder->private_->raw_bits_per_partition_unaligned, &encoder->private_->raw_bits_per_partition);\n\n\t/* now adjust the windows if the blocksize has changed */\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tif(ok && new_blocksize != encoder->private_->input_capacity && encoder->protected_->max_lpc_order > 0) {\n\t\tfor(i = 0; ok && i < encoder->protected_->num_apodizations; i++) {\n\t\t\tswitch(encoder->protected_->apodizations[i].type) {\n\t\t\t\tcase FLAC__APODIZATION_BARTLETT:\n\t\t\t\t\tFLAC__window_bartlett(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_BARTLETT_HANN:\n\t\t\t\t\tFLAC__window_bartlett_hann(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_BLACKMAN:\n\t\t\t\t\tFLAC__window_blackman(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE:\n\t\t\t\t\tFLAC__window_blackman_harris_4term_92db_sidelobe(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_CONNES:\n\t\t\t\t\tFLAC__window_connes(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_FLATTOP:\n\t\t\t\t\tFLAC__window_flattop(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_GAUSS:\n\t\t\t\t\tFLAC__window_gauss(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.gauss.stddev);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_HAMMING:\n\t\t\t\t\tFLAC__window_hamming(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_HANN:\n\t\t\t\t\tFLAC__window_hann(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_KAISER_BESSEL:\n\t\t\t\t\tFLAC__window_kaiser_bessel(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_NUTTALL:\n\t\t\t\t\tFLAC__window_nuttall(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_RECTANGLE:\n\t\t\t\t\tFLAC__window_rectangle(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_TRIANGLE:\n\t\t\t\t\tFLAC__window_triangle(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_TUKEY:\n\t\t\t\t\tFLAC__window_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.tukey.p);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_PARTIAL_TUKEY:\n\t\t\t\t\tFLAC__window_partial_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.multiple_tukey.p, encoder->protected_->apodizations[i].parameters.multiple_tukey.start, encoder->protected_->apodizations[i].parameters.multiple_tukey.end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_PUNCHOUT_TUKEY:\n\t\t\t\t\tFLAC__window_punchout_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.multiple_tukey.p, encoder->protected_->apodizations[i].parameters.multiple_tukey.start, encoder->protected_->apodizations[i].parameters.multiple_tukey.end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FLAC__APODIZATION_WELCH:\n\t\t\t\t\tFLAC__window_welch(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tFLAC__ASSERT(0);\n\t\t\t\t\t/* double protection */\n\t\t\t\t\tFLAC__window_hann(encoder->private_->window[i], new_blocksize);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif(ok)\n\t\tencoder->private_->input_capacity = new_blocksize;\n\telse\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\n\treturn ok;\n}\n\nFLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, unsigned samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\n\treturn true;\n}\n\nFLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, FLAC__bool is_last_block)\n{\n\tFLAC__StreamEncoderWriteStatus status;\n\tFLAC__uint64 output_position = 0;\n\n#if FLAC__HAS_OGG == 0\n\t(void)is_last_block;\n#endif\n\n\t/* FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED just means we didn't get the offset; no error */\n\tif(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &output_position, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;\n\t}\n\n\t/*\n\t * Watch for the STREAMINFO block and first SEEKTABLE block to go by and store their offsets.\n\t */\n\tif(samples == 0) {\n\t\tFLAC__MetadataType type = (buffer[0] & 0x7f);\n\t\tif(type == FLAC__METADATA_TYPE_STREAMINFO)\n\t\t\tencoder->protected_->streaminfo_offset = output_position;\n\t\telse if(type == FLAC__METADATA_TYPE_SEEKTABLE && encoder->protected_->seektable_offset == 0)\n\t\t\tencoder->protected_->seektable_offset = output_position;\n\t}\n\n\t/*\n\t * Mark the current seek point if hit (if audio_offset == 0 that\n\t * means we're still writing metadata and haven't hit the first\n\t * frame yet)\n\t */\n\tif(0 != encoder->private_->seek_table && encoder->protected_->audio_offset > 0 && encoder->private_->seek_table->num_points > 0) {\n\t\tconst unsigned blocksize = FLAC__stream_encoder_get_blocksize(encoder);\n\t\tconst FLAC__uint64 frame_first_sample = encoder->private_->samples_written;\n\t\tconst FLAC__uint64 frame_last_sample = frame_first_sample + (FLAC__uint64)blocksize - 1;\n\t\tFLAC__uint64 test_sample;\n\t\tunsigned i;\n\t\tfor(i = encoder->private_->first_seekpoint_to_check; i < encoder->private_->seek_table->num_points; i++) {\n\t\t\ttest_sample = encoder->private_->seek_table->points[i].sample_number;\n\t\t\tif(test_sample > frame_last_sample) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(test_sample >= frame_first_sample) {\n\t\t\t\tencoder->private_->seek_table->points[i].sample_number = frame_first_sample;\n\t\t\t\tencoder->private_->seek_table->points[i].stream_offset = output_position - encoder->protected_->audio_offset;\n\t\t\t\tencoder->private_->seek_table->points[i].frame_samples = blocksize;\n\t\t\t\tencoder->private_->first_seekpoint_to_check++;\n\t\t\t\t/* DO NOT: \"break;\" and here's why:\n\t\t\t\t * The seektable template may contain more than one target\n\t\t\t\t * sample for any given frame; we will keep looping, generating\n\t\t\t\t * duplicate seekpoints for them, and we'll clean it up later,\n\t\t\t\t * just before writing the seektable back to the metadata.\n\t\t\t\t */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tencoder->private_->first_seekpoint_to_check++;\n\t\t\t}\n\t\t}\n\t}\n\n#if FLAC__HAS_OGG\n\tif(encoder->private_->is_ogg) {\n\t\tstatus = FLAC__ogg_encoder_aspect_write_callback_wrapper(\n\t\t\t&encoder->protected_->ogg_encoder_aspect,\n\t\t\tbuffer,\n\t\t\tbytes,\n\t\t\tsamples,\n\t\t\tencoder->private_->current_frame_number,\n\t\t\tis_last_block,\n\t\t\t(FLAC__OggEncoderAspectWriteCallbackProxy)encoder->private_->write_callback,\n\t\t\tencoder,\n\t\t\tencoder->private_->client_data\n\t\t);\n\t}\n\telse\n#endif\n\tstatus = encoder->private_->write_callback(encoder, buffer, bytes, samples, encoder->private_->current_frame_number, encoder->private_->client_data);\n\n\tif(status == FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tencoder->private_->bytes_written += bytes;\n\t\tencoder->private_->samples_written += samples;\n\t\t/* we keep a high watermark on the number of frames written because\n\t\t * when the encoder goes back to write metadata, 'current_frame'\n\t\t * will drop back to 0.\n\t\t */\n\t\tencoder->private_->frames_written = flac_max(encoder->private_->frames_written, encoder->private_->current_frame_number+1);\n\t}\n\telse\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\n\treturn status;\n}\n\n/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */\nvoid update_metadata_(const FLAC__StreamEncoder *encoder)\n{\n\tFLAC__byte b[flac_max(6u, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];\n\tconst FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;\n\tconst FLAC__uint64 samples = metadata->data.stream_info.total_samples;\n\tconst unsigned min_framesize = metadata->data.stream_info.min_framesize;\n\tconst unsigned max_framesize = metadata->data.stream_info.max_framesize;\n\tconst unsigned bps = metadata->data.stream_info.bits_per_sample;\n\tFLAC__StreamEncoderSeekStatus seek_status;\n\n\tFLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);\n\n\t/* All this is based on intimate knowledge of the stream header\n\t * layout, but a change to the header format that would break this\n\t * would also break all streams encoded in the previous format.\n\t */\n\n\t/*\n\t * Write MD5 signature\n\t */\n\t{\n\t\tconst unsigned md5_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN\n\t\t\t) / 8;\n\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + md5_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, metadata->data.stream_info.md5sum, 16, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write total samples\n\t */\n\t{\n\t\tconst unsigned total_samples_byte_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN\n\t\t\t\t- 4\n\t\t\t) / 8;\n\n\t\tb[0] = ((FLAC__byte)(bps-1) << 4) | (FLAC__byte)((samples >> 32) & 0x0F);\n\t\tb[1] = (FLAC__byte)((samples >> 24) & 0xFF);\n\t\tb[2] = (FLAC__byte)((samples >> 16) & 0xFF);\n\t\tb[3] = (FLAC__byte)((samples >> 8) & 0xFF);\n\t\tb[4] = (FLAC__byte)(samples & 0xFF);\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + total_samples_byte_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, b, 5, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write min/max framesize\n\t */\n\t{\n\t\tconst unsigned min_framesize_offset =\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN\n\t\t\t) / 8;\n\n\t\tb[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);\n\t\tb[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);\n\t\tb[2] = (FLAC__byte)(min_framesize & 0xFF);\n\t\tb[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);\n\t\tb[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);\n\t\tb[5] = (FLAC__byte)(max_framesize & 0xFF);\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + min_framesize_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(encoder->private_->write_callback(encoder, b, 6, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Write seektable\n\t */\n\tif(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {\n\t\tunsigned i;\n\n\t\tFLAC__format_seektable_sort(encoder->private_->seek_table);\n\n\t\tFLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));\n\n\t\tif((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->seektable_offset + FLAC__STREAM_METADATA_HEADER_LENGTH, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {\n\t\t\tif(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\treturn;\n\t\t}\n\n\t\tfor(i = 0; i < encoder->private_->seek_table->num_points; i++) {\n\t\t\tFLAC__uint64 xx;\n\t\t\tunsigned x;\n\t\t\txx = encoder->private_->seek_table->points[i].sample_number;\n\t\t\tb[7] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[6] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[5] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[4] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[3] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[2] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[1] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[0] = (FLAC__byte)xx; xx >>= 8;\n\t\t\txx = encoder->private_->seek_table->points[i].stream_offset;\n\t\t\tb[15] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[14] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[13] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[12] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[11] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[10] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[9] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[8] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tx = encoder->private_->seek_table->points[i].frame_samples;\n\t\t\tb[17] = (FLAC__byte)x; x >>= 8;\n\t\t\tb[16] = (FLAC__byte)x; x >>= 8;\n\t\t\tif(encoder->private_->write_callback(encoder, b, 18, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#if FLAC__HAS_OGG\n/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */\nvoid update_ogg_metadata_(FLAC__StreamEncoder *encoder)\n{\n\t/* the # of bytes in the 1st packet that precede the STREAMINFO */\n\tstatic const unsigned FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH =\n\t\tFLAC__OGG_MAPPING_PACKET_TYPE_LENGTH +\n\t\tFLAC__OGG_MAPPING_MAGIC_LENGTH +\n\t\tFLAC__OGG_MAPPING_VERSION_MAJOR_LENGTH +\n\t\tFLAC__OGG_MAPPING_VERSION_MINOR_LENGTH +\n\t\tFLAC__OGG_MAPPING_NUM_HEADERS_LENGTH +\n\t\tFLAC__STREAM_SYNC_LENGTH\n\t;\n\tFLAC__byte b[flac_max(6u, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];\n\tconst FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;\n\tconst FLAC__uint64 samples = metadata->data.stream_info.total_samples;\n\tconst unsigned min_framesize = metadata->data.stream_info.min_framesize;\n\tconst unsigned max_framesize = metadata->data.stream_info.max_framesize;\n\togg_page page;\n\n\tFLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);\n\tFLAC__ASSERT(0 != encoder->private_->seek_callback);\n\n\t/* Pre-check that client supports seeking, since we don't want the\n\t * ogg_helper code to ever have to deal with this condition.\n\t */\n\tif(encoder->private_->seek_callback(encoder, 0, encoder->private_->client_data) == FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED)\n\t\treturn;\n\n\t/* All this is based on intimate knowledge of the stream header\n\t * layout, but a change to the header format that would break this\n\t * would also break all streams encoded in the previous format.\n\t */\n\n\t/**\n\t ** Write STREAMINFO stats\n\t **/\n\tsimple_ogg_page__init(&page);\n\tif(!simple_ogg_page__get_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {\n\t\tsimple_ogg_page__clear(&page);\n\t\treturn; /* state already set */\n\t}\n\n\t/*\n\t * Write MD5 signature\n\t */\n\t{\n\t\tconst unsigned md5_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN\n\t\t\t) / 8;\n\n\t\tif(md5_offset + 16 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(page.body + md5_offset, metadata->data.stream_info.md5sum, 16);\n\t}\n\n\t/*\n\t * Write total samples\n\t */\n\t{\n\t\tconst unsigned total_samples_byte_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN\n\t\t\t\t- 4\n\t\t\t) / 8;\n\n\t\tif(total_samples_byte_offset + 5 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tb[0] = (FLAC__byte)page.body[total_samples_byte_offset] & 0xF0;\n\t\tb[0] |= (FLAC__byte)((samples >> 32) & 0x0F);\n\t\tb[1] = (FLAC__byte)((samples >> 24) & 0xFF);\n\t\tb[2] = (FLAC__byte)((samples >> 16) & 0xFF);\n\t\tb[3] = (FLAC__byte)((samples >> 8) & 0xFF);\n\t\tb[4] = (FLAC__byte)(samples & 0xFF);\n\t\tmemcpy(page.body + total_samples_byte_offset, b, 5);\n\t}\n\n\t/*\n\t * Write min/max framesize\n\t */\n\t{\n\t\tconst unsigned min_framesize_offset =\n\t\t\tFIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +\n\t\t\tFLAC__STREAM_METADATA_HEADER_LENGTH +\n\t\t\t(\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +\n\t\t\t\tFLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN\n\t\t\t) / 8;\n\n\t\tif(min_framesize_offset + 6 > (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\t\tb[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);\n\t\tb[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);\n\t\tb[2] = (FLAC__byte)(min_framesize & 0xFF);\n\t\tb[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);\n\t\tb[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);\n\t\tb[5] = (FLAC__byte)(max_framesize & 0xFF);\n\t\tmemcpy(page.body + min_framesize_offset, b, 6);\n\t}\n\tif(!simple_ogg_page__set_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {\n\t\tsimple_ogg_page__clear(&page);\n\t\treturn; /* state already set */\n\t}\n\tsimple_ogg_page__clear(&page);\n\n\t/*\n\t * Write seektable\n\t */\n\tif(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {\n\t\tunsigned i;\n\t\tFLAC__byte *p;\n\n\t\tFLAC__format_seektable_sort(encoder->private_->seek_table);\n\n\t\tFLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));\n\n\t\tsimple_ogg_page__init(&page);\n\t\tif(!simple_ogg_page__get_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn; /* state already set */\n\t\t}\n\n\t\tif((FLAC__STREAM_METADATA_HEADER_LENGTH + 18*encoder->private_->seek_table->num_points) != (unsigned)page.body_len) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(i = 0, p = page.body + FLAC__STREAM_METADATA_HEADER_LENGTH; i < encoder->private_->seek_table->num_points; i++, p += 18) {\n\t\t\tFLAC__uint64 xx;\n\t\t\tunsigned x;\n\t\t\txx = encoder->private_->seek_table->points[i].sample_number;\n\t\t\tb[7] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[6] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[5] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[4] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[3] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[2] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[1] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[0] = (FLAC__byte)xx; xx >>= 8;\n\t\t\txx = encoder->private_->seek_table->points[i].stream_offset;\n\t\t\tb[15] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[14] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[13] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[12] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[11] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[10] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[9] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tb[8] = (FLAC__byte)xx; xx >>= 8;\n\t\t\tx = encoder->private_->seek_table->points[i].frame_samples;\n\t\t\tb[17] = (FLAC__byte)x; x >>= 8;\n\t\t\tb[16] = (FLAC__byte)x; x >>= 8;\n\t\t\tmemcpy(p, b, 18);\n\t\t}\n\n\t\tif(!simple_ogg_page__set_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {\n\t\t\tsimple_ogg_page__clear(&page);\n\t\t\treturn; /* state already set */\n\t\t}\n\t\tsimple_ogg_page__clear(&page);\n\t}\n}\n#endif\n\nFLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block, FLAC__bool is_last_block)\n{\n\tFLAC__uint16 crc;\n\tFLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);\n\n\t/*\n\t * Accumulate raw signal to the MD5 signature\n\t */\n\tif(encoder->protected_->do_md5 && !FLAC__MD5Accumulate(&encoder->private_->md5context, (const FLAC__int32 * const *)encoder->private_->integer_signal, encoder->protected_->channels, encoder->protected_->blocksize, (encoder->protected_->bits_per_sample+7) / 8)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\t/*\n\t * Process the frame header and subframes into the frame bitbuffer\n\t */\n\tif(!process_subframes_(encoder, is_fractional_block)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Zero-pad the frame to a byte_boundary\n\t */\n\tif(!FLAC__bitwriter_zero_pad_to_byte_boundary(encoder->private_->frame)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\t/*\n\t * CRC-16 the whole thing\n\t */\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(\n\t\t!FLAC__bitwriter_get_write_crc16(encoder->private_->frame, &crc) ||\n\t\t!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, crc, FLAC__FRAME_FOOTER_CRC_LEN)\n\t) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\n\t/*\n\t * Write it\n\t */\n\tif(!write_bitbuffer_(encoder, encoder->protected_->blocksize, is_last_block)) {\n\t\t/* the above function sets the state for us in case of an error */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Get ready for the next frame\n\t */\n\tencoder->private_->current_sample_number = 0;\n\tencoder->private_->current_frame_number++;\n\tencoder->private_->streaminfo.data.stream_info.total_samples += (FLAC__uint64)encoder->protected_->blocksize;\n\n\treturn true;\n}\n\nFLAC__bool process_subframes_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block)\n{\n\tFLAC__FrameHeader frame_header;\n\tunsigned channel, min_partition_order = encoder->protected_->min_residual_partition_order, max_partition_order;\n\tFLAC__bool do_independent, do_mid_side;\n\n\t/*\n\t * Calculate the min,max Rice partition orders\n\t */\n\tif(is_fractional_block) {\n\t\tmax_partition_order = 0;\n\t}\n\telse {\n\t\tmax_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize(encoder->protected_->blocksize);\n\t\tmax_partition_order = flac_min(max_partition_order, encoder->protected_->max_residual_partition_order);\n\t}\n\tmin_partition_order = flac_min(min_partition_order, max_partition_order);\n\n\t/*\n\t * Setup the frame\n\t */\n\tframe_header.blocksize = encoder->protected_->blocksize;\n\tframe_header.sample_rate = encoder->protected_->sample_rate;\n\tframe_header.channels = encoder->protected_->channels;\n\tframe_header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT; /* the default unless the encoder determines otherwise */\n\tframe_header.bits_per_sample = encoder->protected_->bits_per_sample;\n\tframe_header.number_type = FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER;\n\tframe_header.number.frame_number = encoder->private_->current_frame_number;\n\n\t/*\n\t * Figure out what channel assignments to try\n\t */\n\tif(encoder->protected_->do_mid_side_stereo) {\n\t\tif(encoder->protected_->loose_mid_side_stereo) {\n\t\t\tif(encoder->private_->loose_mid_side_stereo_frame_count == 0) {\n\t\t\t\tdo_independent = true;\n\t\t\t\tdo_mid_side = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdo_independent = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT);\n\t\t\t\tdo_mid_side = !do_independent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdo_independent = true;\n\t\t\tdo_mid_side = true;\n\t\t}\n\t}\n\telse {\n\t\tdo_independent = true;\n\t\tdo_mid_side = false;\n\t}\n\n\tFLAC__ASSERT(do_independent || do_mid_side);\n\n\t/*\n\t * Check for wasted bits; set effective bps for each subframe\n\t */\n\tif(do_independent) {\n\t\tfor(channel = 0; channel < encoder->protected_->channels; channel++) {\n\t\t\tunsigned w = get_wasted_bits_(encoder->private_->integer_signal[channel], encoder->protected_->blocksize);\n\t\t\tif (w > encoder->protected_->bits_per_sample) {\n\t\t\t\tw = encoder->protected_->bits_per_sample;\n\t\t\t}\n\t\t\tencoder->private_->subframe_workspace[channel][0].wasted_bits = encoder->private_->subframe_workspace[channel][1].wasted_bits = w;\n\t\t\tencoder->private_->subframe_bps[channel] = encoder->protected_->bits_per_sample - w;\n\t\t}\n\t}\n\tif(do_mid_side) {\n\t\tFLAC__ASSERT(encoder->protected_->channels == 2);\n\t\tfor(channel = 0; channel < 2; channel++) {\n\t\t\tunsigned w = get_wasted_bits_(encoder->private_->integer_signal_mid_side[channel], encoder->protected_->blocksize);\n\t\t\tif (w > encoder->protected_->bits_per_sample) {\n\t\t\t\tw = encoder->protected_->bits_per_sample;\n\t\t\t}\n\t\t\tencoder->private_->subframe_workspace_mid_side[channel][0].wasted_bits = encoder->private_->subframe_workspace_mid_side[channel][1].wasted_bits = w;\n\t\t\tencoder->private_->subframe_bps_mid_side[channel] = encoder->protected_->bits_per_sample - w + (channel==0? 0:1);\n\t\t}\n\t}\n\n\t/*\n\t * First do a normal encoding pass of each independent channel\n\t */\n\tif(do_independent) {\n\t\tfor(channel = 0; channel < encoder->protected_->channels; channel++) {\n\t\t\tif(!\n\t\t\t\tprocess_subframe_(\n\t\t\t\t\tencoder,\n\t\t\t\t\tmin_partition_order,\n\t\t\t\t\tmax_partition_order,\n\t\t\t\t\t&frame_header,\n\t\t\t\t\tencoder->private_->subframe_bps[channel],\n\t\t\t\t\tencoder->private_->integer_signal[channel],\n\t\t\t\t\tencoder->private_->subframe_workspace_ptr[channel],\n\t\t\t\t\tencoder->private_->partitioned_rice_contents_workspace_ptr[channel],\n\t\t\t\t\tencoder->private_->residual_workspace[channel],\n\t\t\t\t\tencoder->private_->best_subframe+channel,\n\t\t\t\t\tencoder->private_->best_subframe_bits+channel\n\t\t\t\t)\n\t\t\t)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Now do mid and side channels if requested\n\t */\n\tif(do_mid_side) {\n\t\tFLAC__ASSERT(encoder->protected_->channels == 2);\n\n\t\tfor(channel = 0; channel < 2; channel++) {\n\t\t\tif(!\n\t\t\t\tprocess_subframe_(\n\t\t\t\t\tencoder,\n\t\t\t\t\tmin_partition_order,\n\t\t\t\t\tmax_partition_order,\n\t\t\t\t\t&frame_header,\n\t\t\t\t\tencoder->private_->subframe_bps_mid_side[channel],\n\t\t\t\t\tencoder->private_->integer_signal_mid_side[channel],\n\t\t\t\t\tencoder->private_->subframe_workspace_ptr_mid_side[channel],\n\t\t\t\t\tencoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[channel],\n\t\t\t\t\tencoder->private_->residual_workspace_mid_side[channel],\n\t\t\t\t\tencoder->private_->best_subframe_mid_side+channel,\n\t\t\t\t\tencoder->private_->best_subframe_bits_mid_side+channel\n\t\t\t\t)\n\t\t\t)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Compose the frame bitbuffer\n\t */\n\tif(do_mid_side) {\n\t\tunsigned left_bps = 0, right_bps = 0; /* initialized only to prevent superfluous compiler warning */\n\t\tFLAC__Subframe *left_subframe = 0, *right_subframe = 0; /* initialized only to prevent superfluous compiler warning */\n\t\tFLAC__ChannelAssignment channel_assignment;\n\n\t\tFLAC__ASSERT(encoder->protected_->channels == 2);\n\n\t\tif(encoder->protected_->loose_mid_side_stereo && encoder->private_->loose_mid_side_stereo_frame_count > 0) {\n\t\t\tchannel_assignment = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT? FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT : FLAC__CHANNEL_ASSIGNMENT_MID_SIDE);\n\t\t}\n\t\telse {\n\t\t\tunsigned bits[4]; /* WATCHOUT - indexed by FLAC__ChannelAssignment */\n\t\t\tunsigned min_bits;\n\t\t\tint ca;\n\n\t\t\tFLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT == 0);\n\t\t\tFLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE   == 1);\n\t\t\tFLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE  == 2);\n\t\t\tFLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_MID_SIDE    == 3);\n\t\t\tFLAC__ASSERT(do_independent && do_mid_side);\n\n\t\t\t/* We have to figure out which channel assignent results in the smallest frame */\n\t\t\tbits[FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT] = encoder->private_->best_subframe_bits         [0] + encoder->private_->best_subframe_bits         [1];\n\t\t\tbits[FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE  ] = encoder->private_->best_subframe_bits         [0] + encoder->private_->best_subframe_bits_mid_side[1];\n\t\t\tbits[FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE ] = encoder->private_->best_subframe_bits         [1] + encoder->private_->best_subframe_bits_mid_side[1];\n\t\t\tbits[FLAC__CHANNEL_ASSIGNMENT_MID_SIDE   ] = encoder->private_->best_subframe_bits_mid_side[0] + encoder->private_->best_subframe_bits_mid_side[1];\n\n\t\t\tchannel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;\n\t\t\tmin_bits = bits[channel_assignment];\n\t\t\tfor(ca = 1; ca <= 3; ca++) {\n\t\t\t\tif(bits[ca] < min_bits) {\n\t\t\t\t\tmin_bits = bits[ca];\n\t\t\t\t\tchannel_assignment = (FLAC__ChannelAssignment)ca;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tframe_header.channel_assignment = channel_assignment;\n\n\t\tif(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch(channel_assignment) {\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:\n\t\t\t\tleft_subframe  = &encoder->private_->subframe_workspace         [0][encoder->private_->best_subframe         [0]];\n\t\t\t\tright_subframe = &encoder->private_->subframe_workspace         [1][encoder->private_->best_subframe         [1]];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:\n\t\t\t\tleft_subframe  = &encoder->private_->subframe_workspace         [0][encoder->private_->best_subframe         [0]];\n\t\t\t\tright_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:\n\t\t\t\tleft_subframe  = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];\n\t\t\t\tright_subframe = &encoder->private_->subframe_workspace         [1][encoder->private_->best_subframe         [1]];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:\n\t\t\t\tleft_subframe  = &encoder->private_->subframe_workspace_mid_side[0][encoder->private_->best_subframe_mid_side[0]];\n\t\t\t\tright_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t}\n\n\t\tswitch(channel_assignment) {\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:\n\t\t\t\tleft_bps  = encoder->private_->subframe_bps         [0];\n\t\t\t\tright_bps = encoder->private_->subframe_bps         [1];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:\n\t\t\t\tleft_bps  = encoder->private_->subframe_bps         [0];\n\t\t\t\tright_bps = encoder->private_->subframe_bps_mid_side[1];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:\n\t\t\t\tleft_bps  = encoder->private_->subframe_bps_mid_side[1];\n\t\t\t\tright_bps = encoder->private_->subframe_bps         [1];\n\t\t\t\tbreak;\n\t\t\tcase FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:\n\t\t\t\tleft_bps  = encoder->private_->subframe_bps_mid_side[0];\n\t\t\t\tright_bps = encoder->private_->subframe_bps_mid_side[1];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tFLAC__ASSERT(0);\n\t\t}\n\n\t\t/* note that encoder_add_subframe_ sets the state for us in case of an error */\n\t\tif(!add_subframe_(encoder, frame_header.blocksize, left_bps , left_subframe , encoder->private_->frame))\n\t\t\treturn false;\n\t\tif(!add_subframe_(encoder, frame_header.blocksize, right_bps, right_subframe, encoder->private_->frame))\n\t\t\treturn false;\n\t}\n\telse {\n\t\tif(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor(channel = 0; channel < encoder->protected_->channels; channel++) {\n\t\t\tif(!add_subframe_(encoder, frame_header.blocksize, encoder->private_->subframe_bps[channel], &encoder->private_->subframe_workspace[channel][encoder->private_->best_subframe[channel]], encoder->private_->frame)) {\n\t\t\t\t/* the above function sets the state for us in case of an error */\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(encoder->protected_->loose_mid_side_stereo) {\n\t\tencoder->private_->loose_mid_side_stereo_frame_count++;\n\t\tif(encoder->private_->loose_mid_side_stereo_frame_count >= encoder->private_->loose_mid_side_stereo_frames)\n\t\t\tencoder->private_->loose_mid_side_stereo_frame_count = 0;\n\t}\n\n\tencoder->private_->last_channel_assignment = frame_header.channel_assignment;\n\n\treturn true;\n}\n\nFLAC__bool process_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tconst FLAC__FrameHeader *frame_header,\n\tunsigned subframe_bps,\n\tconst FLAC__int32 integer_signal[],\n\tFLAC__Subframe *subframe[2],\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],\n\tFLAC__int32 *residual[2],\n\tunsigned *best_subframe,\n\tunsigned *best_bits\n)\n{\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tfloat fixed_residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1];\n#else\n\tFLAC__fixedpoint fixed_residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1];\n#endif\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\tdouble lpc_residual_bits_per_sample;\n\tFLAC__real autoc[FLAC__MAX_LPC_ORDER+1]; /* WATCHOUT: the size is important even though encoder->protected_->max_lpc_order might be less; some asm and x86 intrinsic routines need all the space */\n\tdouble lpc_error[FLAC__MAX_LPC_ORDER];\n\tunsigned min_lpc_order, max_lpc_order, lpc_order;\n\tunsigned min_qlp_coeff_precision, max_qlp_coeff_precision, qlp_coeff_precision;\n#endif\n\tunsigned min_fixed_order, max_fixed_order, guess_fixed_order, fixed_order;\n\tunsigned rice_parameter;\n\tunsigned _candidate_bits, _best_bits;\n\tunsigned _best_subframe;\n\t/* only use RICE2 partitions if stream bps > 16 */\n\tconst unsigned rice_parameter_limit = FLAC__stream_encoder_get_bits_per_sample(encoder) > 16? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;\n\n\tFLAC__ASSERT(frame_header->blocksize > 0);\n\n\t/* verbatim subframe is the baseline against which we measure other compressed subframes */\n\t_best_subframe = 0;\n\tif(encoder->private_->disable_verbatim_subframes && frame_header->blocksize >= FLAC__MAX_FIXED_ORDER)\n\t\t_best_bits = UINT_MAX;\n\telse\n\t\t_best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);\n\n\tif(frame_header->blocksize >= FLAC__MAX_FIXED_ORDER) {\n\t\tunsigned signal_is_constant = false;\n\t\tif(subframe_bps + 4 + FLAC__bitmath_ilog2((frame_header->blocksize-FLAC__MAX_FIXED_ORDER)|1) <= 32)\n\t\t\tguess_fixed_order = encoder->private_->local_fixed_compute_best_predictor(integer_signal+FLAC__MAX_FIXED_ORDER, frame_header->blocksize-FLAC__MAX_FIXED_ORDER, fixed_residual_bits_per_sample);\n\t\telse\n\t\t\tguess_fixed_order = encoder->private_->local_fixed_compute_best_predictor_wide(integer_signal+FLAC__MAX_FIXED_ORDER, frame_header->blocksize-FLAC__MAX_FIXED_ORDER, fixed_residual_bits_per_sample);\n\t\t/* check for constant subframe */\n\t\tif(\n\t\t\t!encoder->private_->disable_constant_subframes &&\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\t\tfixed_residual_bits_per_sample[1] == 0.0\n#else\n\t\t\tfixed_residual_bits_per_sample[1] == FLAC__FP_ZERO\n#endif\n\t\t) {\n\t\t\t/* the above means it's possible all samples are the same value; now double-check it: */\n\t\t\tunsigned i;\n\t\t\tsignal_is_constant = true;\n\t\t\tfor(i = 1; i < frame_header->blocksize; i++) {\n\t\t\t\tif(integer_signal[0] != integer_signal[i]) {\n\t\t\t\t\tsignal_is_constant = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(signal_is_constant) {\n\t\t\t_candidate_bits = evaluate_constant_subframe_(encoder, integer_signal[0], frame_header->blocksize, subframe_bps, subframe[!_best_subframe]);\n\t\t\tif(_candidate_bits < _best_bits) {\n\t\t\t\t_best_subframe = !_best_subframe;\n\t\t\t\t_best_bits = _candidate_bits;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!encoder->private_->disable_fixed_subframes || (encoder->protected_->max_lpc_order == 0 && _best_bits == UINT_MAX)) {\n\t\t\t\t/* encode fixed */\n\t\t\t\tif(encoder->protected_->do_exhaustive_model_search) {\n\t\t\t\t\tmin_fixed_order = 0;\n\t\t\t\t\tmax_fixed_order = FLAC__MAX_FIXED_ORDER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmin_fixed_order = max_fixed_order = guess_fixed_order;\n\t\t\t\t}\n\t\t\t\tif(max_fixed_order >= frame_header->blocksize)\n\t\t\t\t\tmax_fixed_order = frame_header->blocksize - 1;\n\t\t\t\tfor(fixed_order = min_fixed_order; fixed_order <= max_fixed_order; fixed_order++) {\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\t\t\t\tif(fixed_residual_bits_per_sample[fixed_order] >= (float)subframe_bps)\n\t\t\t\t\t\tcontinue; /* don't even try */\n\t\t\t\t\trice_parameter = (fixed_residual_bits_per_sample[fixed_order] > 0.0)? (unsigned)(fixed_residual_bits_per_sample[fixed_order]+0.5) : 0; /* 0.5 is for rounding */\n#else\n\t\t\t\t\tif(FLAC__fixedpoint_trunc(fixed_residual_bits_per_sample[fixed_order]) >= (int)subframe_bps)\n\t\t\t\t\t\tcontinue; /* don't even try */\n\t\t\t\t\trice_parameter = (fixed_residual_bits_per_sample[fixed_order] > FLAC__FP_ZERO)? (unsigned)FLAC__fixedpoint_trunc(fixed_residual_bits_per_sample[fixed_order]+FLAC__FP_ONE_HALF) : 0; /* 0.5 is for rounding */\n#endif\n\t\t\t\t\trice_parameter++; /* to account for the signed->unsigned conversion during rice coding */\n\t\t\t\t\tif(rice_parameter >= rice_parameter_limit) {\n#ifdef DEBUG_VERBOSE\n\t\t\t\t\t\tfprintf(stderr, \"clipping rice_parameter (%u -> %u) @0\\n\", rice_parameter, rice_parameter_limit - 1);\n#endif\n\t\t\t\t\t\trice_parameter = rice_parameter_limit - 1;\n\t\t\t\t\t}\n\t\t\t\t\t_candidate_bits =\n\t\t\t\t\t\tevaluate_fixed_subframe_(\n\t\t\t\t\t\t\tencoder,\n\t\t\t\t\t\t\tinteger_signal,\n\t\t\t\t\t\t\tresidual[!_best_subframe],\n\t\t\t\t\t\t\tencoder->private_->abs_residual_partition_sums,\n\t\t\t\t\t\t\tencoder->private_->raw_bits_per_partition,\n\t\t\t\t\t\t\tframe_header->blocksize,\n\t\t\t\t\t\t\tsubframe_bps,\n\t\t\t\t\t\t\tfixed_order,\n\t\t\t\t\t\t\trice_parameter,\n\t\t\t\t\t\t\trice_parameter_limit,\n\t\t\t\t\t\t\tmin_partition_order,\n\t\t\t\t\t\t\tmax_partition_order,\n\t\t\t\t\t\t\tencoder->protected_->do_escape_coding,\n\t\t\t\t\t\t\tencoder->protected_->rice_parameter_search_dist,\n\t\t\t\t\t\t\tsubframe[!_best_subframe],\n\t\t\t\t\t\t\tpartitioned_rice_contents[!_best_subframe]\n\t\t\t\t\t\t);\n\t\t\t\t\tif(_candidate_bits < _best_bits) {\n\t\t\t\t\t\t_best_subframe = !_best_subframe;\n\t\t\t\t\t\t_best_bits = _candidate_bits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\t\t\t/* encode lpc */\n\t\t\tif(encoder->protected_->max_lpc_order > 0) {\n\t\t\t\tif(encoder->protected_->max_lpc_order >= frame_header->blocksize)\n\t\t\t\t\tmax_lpc_order = frame_header->blocksize-1;\n\t\t\t\telse\n\t\t\t\t\tmax_lpc_order = encoder->protected_->max_lpc_order;\n\t\t\t\tif(max_lpc_order > 0) {\n\t\t\t\t\tunsigned a;\n\t\t\t\t\tfor (a = 0; a < encoder->protected_->num_apodizations; a++) {\n\t\t\t\t\t\tFLAC__lpc_window_data(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize);\n\t\t\t\t\t\tencoder->private_->local_lpc_compute_autocorrelation(encoder->private_->windowed_signal, frame_header->blocksize, max_lpc_order+1, autoc);\n\t\t\t\t\t\t/* if autoc[0] == 0.0, the signal is constant and we usually won't get here, but it can happen */\n\t\t\t\t\t\tif(autoc[0] != 0.0) {\n\t\t\t\t\t\t\tFLAC__lpc_compute_lp_coefficients(autoc, &max_lpc_order, encoder->private_->lp_coeff, lpc_error);\n\t\t\t\t\t\t\tif(encoder->protected_->do_exhaustive_model_search) {\n\t\t\t\t\t\t\t\tmin_lpc_order = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst unsigned guess_lpc_order =\n\t\t\t\t\t\t\t\t\tFLAC__lpc_compute_best_order(\n\t\t\t\t\t\t\t\t\t\tlpc_error,\n\t\t\t\t\t\t\t\t\t\tmax_lpc_order,\n\t\t\t\t\t\t\t\t\t\tframe_header->blocksize,\n\t\t\t\t\t\t\t\t\t\tsubframe_bps + (\n\t\t\t\t\t\t\t\t\t\t\tencoder->protected_->do_qlp_coeff_prec_search?\n\t\t\t\t\t\t\t\t\t\t\t\tFLAC__MIN_QLP_COEFF_PRECISION : /* have to guess; use the min possible size to avoid accidentally favoring lower orders */\n\t\t\t\t\t\t\t\t\t\t\t\tencoder->protected_->qlp_coeff_precision\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tmin_lpc_order = max_lpc_order = guess_lpc_order;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(max_lpc_order >= frame_header->blocksize)\n\t\t\t\t\t\t\t\tmax_lpc_order = frame_header->blocksize - 1;\n\t\t\t\t\t\t\tfor(lpc_order = min_lpc_order; lpc_order <= max_lpc_order; lpc_order++) {\n\t\t\t\t\t\t\t\tlpc_residual_bits_per_sample = FLAC__lpc_compute_expected_bits_per_residual_sample(lpc_error[lpc_order-1], frame_header->blocksize-lpc_order);\n\t\t\t\t\t\t\t\tif(lpc_residual_bits_per_sample >= (double)subframe_bps)\n\t\t\t\t\t\t\t\t\tcontinue; /* don't even try */\n\t\t\t\t\t\t\t\trice_parameter = (lpc_residual_bits_per_sample > 0.0)? (unsigned)(lpc_residual_bits_per_sample+0.5) : 0; /* 0.5 is for rounding */\n\t\t\t\t\t\t\t\trice_parameter++; /* to account for the signed->unsigned conversion during rice coding */\n\t\t\t\t\t\t\t\tif(rice_parameter >= rice_parameter_limit) {\n#ifdef DEBUG_VERBOSE\n\t\t\t\t\t\t\t\t\tfprintf(stderr, \"clipping rice_parameter (%u -> %u) @1\\n\", rice_parameter, rice_parameter_limit - 1);\n#endif\n\t\t\t\t\t\t\t\t\trice_parameter = rice_parameter_limit - 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(encoder->protected_->do_qlp_coeff_prec_search) {\n\t\t\t\t\t\t\t\t\tmin_qlp_coeff_precision = FLAC__MIN_QLP_COEFF_PRECISION;\n\t\t\t\t\t\t\t\t\t/* try to keep qlp coeff precision such that only 32-bit math is required for decode of <=16bps(+1bps for side channel) streams */\n\t\t\t\t\t\t\t\t\tif(subframe_bps <= 17) {\n\t\t\t\t\t\t\t\t\t\tmax_qlp_coeff_precision = flac_min(32 - subframe_bps - FLAC__bitmath_ilog2(lpc_order), FLAC__MAX_QLP_COEFF_PRECISION);\n\t\t\t\t\t\t\t\t\t\tmax_qlp_coeff_precision = flac_max(max_qlp_coeff_precision, min_qlp_coeff_precision);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tmax_qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tmin_qlp_coeff_precision = max_qlp_coeff_precision = encoder->protected_->qlp_coeff_precision;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor(qlp_coeff_precision = min_qlp_coeff_precision; qlp_coeff_precision <= max_qlp_coeff_precision; qlp_coeff_precision++) {\n\t\t\t\t\t\t\t\t\t_candidate_bits =\n\t\t\t\t\t\t\t\t\t\tevaluate_lpc_subframe_(\n\t\t\t\t\t\t\t\t\t\t\tencoder,\n\t\t\t\t\t\t\t\t\t\t\tinteger_signal,\n\t\t\t\t\t\t\t\t\t\t\tresidual[!_best_subframe],\n\t\t\t\t\t\t\t\t\t\t\tencoder->private_->abs_residual_partition_sums,\n\t\t\t\t\t\t\t\t\t\t\tencoder->private_->raw_bits_per_partition,\n\t\t\t\t\t\t\t\t\t\t\tencoder->private_->lp_coeff[lpc_order-1],\n\t\t\t\t\t\t\t\t\t\t\tframe_header->blocksize,\n\t\t\t\t\t\t\t\t\t\t\tsubframe_bps,\n\t\t\t\t\t\t\t\t\t\t\tlpc_order,\n\t\t\t\t\t\t\t\t\t\t\tqlp_coeff_precision,\n\t\t\t\t\t\t\t\t\t\t\trice_parameter,\n\t\t\t\t\t\t\t\t\t\t\trice_parameter_limit,\n\t\t\t\t\t\t\t\t\t\t\tmin_partition_order,\n\t\t\t\t\t\t\t\t\t\t\tmax_partition_order,\n\t\t\t\t\t\t\t\t\t\t\tencoder->protected_->do_escape_coding,\n\t\t\t\t\t\t\t\t\t\t\tencoder->protected_->rice_parameter_search_dist,\n\t\t\t\t\t\t\t\t\t\t\tsubframe[!_best_subframe],\n\t\t\t\t\t\t\t\t\t\t\tpartitioned_rice_contents[!_best_subframe]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif(_candidate_bits > 0) { /* if == 0, there was a problem quantizing the lpcoeffs */\n\t\t\t\t\t\t\t\t\t\tif(_candidate_bits < _best_bits) {\n\t\t\t\t\t\t\t\t\t\t\t_best_subframe = !_best_subframe;\n\t\t\t\t\t\t\t\t\t\t\t_best_bits = _candidate_bits;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */\n\t\t}\n\t}\n\n\t/* under rare circumstances this can happen when all but lpc subframe types are disabled: */\n\tif(_best_bits == UINT_MAX) {\n\t\tFLAC__ASSERT(_best_subframe == 0);\n\t\t_best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);\n\t}\n\n\t*best_subframe = _best_subframe;\n\t*best_bits = _best_bits;\n\n\treturn true;\n}\n\nFLAC__bool add_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tconst FLAC__Subframe *subframe,\n\tFLAC__BitWriter *frame\n)\n{\n\tswitch(subframe->type) {\n\t\tcase FLAC__SUBFRAME_TYPE_CONSTANT:\n\t\t\tif(!FLAC__subframe_add_constant(&(subframe->data.constant), subframe_bps, subframe->wasted_bits, frame)) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__SUBFRAME_TYPE_FIXED:\n\t\t\tif(!FLAC__subframe_add_fixed(&(subframe->data.fixed), blocksize - subframe->data.fixed.order, subframe_bps, subframe->wasted_bits, frame)) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__SUBFRAME_TYPE_LPC:\n\t\t\tif(!FLAC__subframe_add_lpc(&(subframe->data.lpc), blocksize - subframe->data.lpc.order, subframe_bps, subframe->wasted_bits, frame)) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__SUBFRAME_TYPE_VERBATIM:\n\t\t\tif(!FLAC__subframe_add_verbatim(&(subframe->data.verbatim), blocksize, subframe_bps, subframe->wasted_bits, frame)) {\n\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\treturn true;\n}\n\n#define SPOTCHECK_ESTIMATE 0\n#if SPOTCHECK_ESTIMATE\nstatic void spotcheck_subframe_estimate_(\n\tFLAC__StreamEncoder *encoder,\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tconst FLAC__Subframe *subframe,\n\tunsigned estimate\n)\n{\n\tFLAC__bool ret;\n\tFLAC__BitWriter *frame = FLAC__bitwriter_new();\n\tif(frame == 0) {\n\t\tfprintf(stderr, \"EST: can't allocate frame\\n\");\n\t\treturn;\n\t}\n\tif(!FLAC__bitwriter_init(frame)) {\n\t\tfprintf(stderr, \"EST: can't init frame\\n\");\n\t\treturn;\n\t}\n\tret = add_subframe_(encoder, blocksize, subframe_bps, subframe, frame);\n\tFLAC__ASSERT(ret);\n\t{\n\t\tconst unsigned actual = FLAC__bitwriter_get_input_bits_unconsumed(frame);\n\t\tif(estimate != actual)\n\t\t\tfprintf(stderr, \"EST: bad, frame#%u sub#%%d type=%8s est=%u, actual=%u, delta=%d\\n\", encoder->private_->current_frame_number, FLAC__SubframeTypeString[subframe->type], estimate, actual, (int)actual-(int)estimate);\n\t}\n\tFLAC__bitwriter_delete(frame);\n}\n#endif\n\nunsigned evaluate_constant_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal,\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tFLAC__Subframe *subframe\n)\n{\n\tunsigned estimate;\n\tsubframe->type = FLAC__SUBFRAME_TYPE_CONSTANT;\n\tsubframe->data.constant.value = signal;\n\n\testimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + subframe_bps;\n\n#if SPOTCHECK_ESTIMATE\n\tspotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);\n#else\n\t(void)encoder, (void)blocksize;\n#endif\n\n\treturn estimate;\n}\n\nunsigned evaluate_fixed_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tFLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tunsigned order,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__Subframe *subframe,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents\n)\n{\n\tunsigned i, residual_bits, estimate;\n\tconst unsigned residual_samples = blocksize - order;\n\n\tFLAC__fixed_compute_residual(signal+order, residual_samples, order, residual);\n\n\tsubframe->type = FLAC__SUBFRAME_TYPE_FIXED;\n\n\tsubframe->data.fixed.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;\n\tsubframe->data.fixed.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;\n\tsubframe->data.fixed.residual = residual;\n\n\tresidual_bits =\n\t\tfind_best_partition_order_(\n\t\t\tencoder->private_,\n\t\t\tresidual,\n\t\t\tabs_residual_partition_sums,\n\t\t\traw_bits_per_partition,\n\t\t\tresidual_samples,\n\t\t\torder,\n\t\t\trice_parameter,\n\t\t\trice_parameter_limit,\n\t\t\tmin_partition_order,\n\t\t\tmax_partition_order,\n\t\t\tsubframe_bps,\n\t\t\tdo_escape_coding,\n\t\t\trice_parameter_search_dist,\n\t\t\t&subframe->data.fixed.entropy_coding_method\n\t\t);\n\n\tsubframe->data.fixed.order = order;\n\tfor(i = 0; i < order; i++)\n\t\tsubframe->data.fixed.warmup[i] = signal[i];\n\n\testimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (order * subframe_bps) + residual_bits;\n\n#if SPOTCHECK_ESTIMATE\n\tspotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);\n#endif\n\n\treturn estimate;\n}\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\nunsigned evaluate_lpc_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tFLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tconst FLAC__real lp_coeff[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tunsigned order,\n\tunsigned qlp_coeff_precision,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__Subframe *subframe,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents\n)\n{\n\tFLAC__int32 qlp_coeff[FLAC__MAX_LPC_ORDER]; /* WATCHOUT: the size is important; some x86 intrinsic routines need more than lpc order elements */\n\tunsigned i, residual_bits, estimate;\n\tint quantization, ret;\n\tconst unsigned residual_samples = blocksize - order;\n\n\t/* try to keep qlp coeff precision such that only 32-bit math is required for decode of <=16bps(+1bps for side channel) streams */\n\tif(subframe_bps <= 17) {\n\t\tFLAC__ASSERT(order > 0);\n\t\tFLAC__ASSERT(order <= FLAC__MAX_LPC_ORDER);\n\t\tqlp_coeff_precision = flac_min(qlp_coeff_precision, 32 - subframe_bps - FLAC__bitmath_ilog2(order));\n\t}\n\n\tret = FLAC__lpc_quantize_coefficients(lp_coeff, order, qlp_coeff_precision, qlp_coeff, &quantization);\n\tif(ret != 0)\n\t\treturn 0; /* this is a hack to indicate to the caller that we can't do lp at this order on this subframe */\n\n\tif(subframe_bps + qlp_coeff_precision + FLAC__bitmath_ilog2(order) <= 32)\n\t\tif(subframe_bps <= 16 && qlp_coeff_precision <= 16)\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit(signal+order, residual_samples, qlp_coeff, order, quantization, residual);\n\t\telse\n\t\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients(signal+order, residual_samples, qlp_coeff, order, quantization, residual);\n\telse\n\t\tencoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit(signal+order, residual_samples, qlp_coeff, order, quantization, residual);\n\n\tsubframe->type = FLAC__SUBFRAME_TYPE_LPC;\n\n\tsubframe->data.lpc.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;\n\tsubframe->data.lpc.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;\n\tsubframe->data.lpc.residual = residual;\n\n\tresidual_bits =\n\t\tfind_best_partition_order_(\n\t\t\tencoder->private_,\n\t\t\tresidual,\n\t\t\tabs_residual_partition_sums,\n\t\t\traw_bits_per_partition,\n\t\t\tresidual_samples,\n\t\t\torder,\n\t\t\trice_parameter,\n\t\t\trice_parameter_limit,\n\t\t\tmin_partition_order,\n\t\t\tmax_partition_order,\n\t\t\tsubframe_bps,\n\t\t\tdo_escape_coding,\n\t\t\trice_parameter_search_dist,\n\t\t\t&subframe->data.lpc.entropy_coding_method\n\t\t);\n\n\tsubframe->data.lpc.order = order;\n\tsubframe->data.lpc.qlp_coeff_precision = qlp_coeff_precision;\n\tsubframe->data.lpc.quantization_level = quantization;\n\tmemcpy(subframe->data.lpc.qlp_coeff, qlp_coeff, sizeof(FLAC__int32)*FLAC__MAX_LPC_ORDER);\n\tfor(i = 0; i < order; i++)\n\t\tsubframe->data.lpc.warmup[i] = signal[i];\n\n\testimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN + FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN + (order * (qlp_coeff_precision + subframe_bps)) + residual_bits;\n\n#if SPOTCHECK_ESTIMATE\n\tspotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);\n#endif\n\n\treturn estimate;\n}\n#endif\n\nunsigned evaluate_verbatim_subframe_(\n\tFLAC__StreamEncoder *encoder,\n\tconst FLAC__int32 signal[],\n\tunsigned blocksize,\n\tunsigned subframe_bps,\n\tFLAC__Subframe *subframe\n)\n{\n\tunsigned estimate;\n\n\tsubframe->type = FLAC__SUBFRAME_TYPE_VERBATIM;\n\n\tsubframe->data.verbatim.data = signal;\n\n\testimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (blocksize * subframe_bps);\n\n#if SPOTCHECK_ESTIMATE\n\tspotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);\n#else\n\t(void)encoder;\n#endif\n\n\treturn estimate;\n}\n\nunsigned find_best_partition_order_(\n\tFLAC__StreamEncoderPrivate *private_,\n\tconst FLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned rice_parameter,\n\tunsigned rice_parameter_limit,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tunsigned bps,\n\tFLAC__bool do_escape_coding,\n\tunsigned rice_parameter_search_dist,\n\tFLAC__EntropyCodingMethod *best_ecm\n)\n{\n\tunsigned residual_bits, best_residual_bits = 0;\n\tunsigned best_parameters_index = 0;\n\tunsigned best_partition_order = 0;\n\tconst unsigned blocksize = residual_samples + predictor_order;\n\n\tmax_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(max_partition_order, blocksize, predictor_order);\n\tmin_partition_order = flac_min(min_partition_order, max_partition_order);\n\n\tprivate_->local_precompute_partition_info_sums(residual, abs_residual_partition_sums, residual_samples, predictor_order, min_partition_order, max_partition_order, bps);\n\n\tif(do_escape_coding)\n\t\tprecompute_partition_info_escapes_(residual, raw_bits_per_partition, residual_samples, predictor_order, min_partition_order, max_partition_order);\n\n\t{\n\t\tint partition_order;\n\t\tunsigned sum;\n\n\t\tfor(partition_order = (int)max_partition_order, sum = 0; partition_order >= (int)min_partition_order; partition_order--) {\n\t\t\tif(!\n\t\t\t\tset_partitioned_rice_(\n#ifdef EXACT_RICE_BITS_CALCULATION\n\t\t\t\t\tresidual,\n#endif\n\t\t\t\t\tabs_residual_partition_sums+sum,\n\t\t\t\t\traw_bits_per_partition+sum,\n\t\t\t\t\tresidual_samples,\n\t\t\t\t\tpredictor_order,\n\t\t\t\t\trice_parameter,\n\t\t\t\t\trice_parameter_limit,\n\t\t\t\t\trice_parameter_search_dist,\n\t\t\t\t\t(unsigned)partition_order,\n\t\t\t\t\tdo_escape_coding,\n\t\t\t\t\t&private_->partitioned_rice_contents_extra[!best_parameters_index],\n\t\t\t\t\t&residual_bits\n\t\t\t\t)\n\t\t\t)\n\t\t\t{\n\t\t\t\tFLAC__ASSERT(best_residual_bits != 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum += 1u << partition_order;\n\t\t\tif(best_residual_bits == 0 || residual_bits < best_residual_bits) {\n\t\t\t\tbest_residual_bits = residual_bits;\n\t\t\t\tbest_parameters_index = !best_parameters_index;\n\t\t\t\tbest_partition_order = partition_order;\n\t\t\t}\n\t\t}\n\t}\n\n\tbest_ecm->data.partitioned_rice.order = best_partition_order;\n\n\t{\n\t\t/*\n\t\t * We are allowed to de-const the pointer based on our special\n\t\t * knowledge; it is const to the outside world.\n\t\t */\n\t\tFLAC__EntropyCodingMethod_PartitionedRiceContents* prc = (FLAC__EntropyCodingMethod_PartitionedRiceContents*)best_ecm->data.partitioned_rice.contents;\n\t\tunsigned partition;\n\n\t\t/* save best parameters and raw_bits */\n\t\tFLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(prc, flac_max(6u, best_partition_order));\n\t\tmemcpy(prc->parameters, private_->partitioned_rice_contents_extra[best_parameters_index].parameters, sizeof(unsigned)*(1<<(best_partition_order)));\n\t\tif(do_escape_coding)\n\t\t\tmemcpy(prc->raw_bits, private_->partitioned_rice_contents_extra[best_parameters_index].raw_bits, sizeof(unsigned)*(1<<(best_partition_order)));\n\t\t/*\n\t\t * Now need to check if the type should be changed to\n\t\t * FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 based on the\n\t\t * size of the rice parameters.\n\t\t */\n\t\tfor(partition = 0; partition < (1u<<best_partition_order); partition++) {\n\t\t\tif(prc->parameters[partition] >= FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER) {\n\t\t\t\tbest_ecm->type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_residual_bits;\n}\n\nvoid precompute_partition_info_sums_(\n\tconst FLAC__int32 residual[],\n\tFLAC__uint64 abs_residual_partition_sums[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order,\n\tunsigned bps\n)\n{\n\tconst unsigned default_partition_samples = (residual_samples + predictor_order) >> max_partition_order;\n\tunsigned partitions = 1u << max_partition_order;\n\n\tFLAC__ASSERT(default_partition_samples > predictor_order);\n\n\t/* first do max_partition_order */\n\t{\n\t\tconst unsigned threshold = 32 - FLAC__bitmath_ilog2(default_partition_samples);\n\t\tunsigned partition, residual_sample, end = (unsigned)(-(int)predictor_order);\n\t\t/* WATCHOUT: \"bps + FLAC__MAX_EXTRA_RESIDUAL_BPS\" is the maximum assumed size of the average residual magnitude */\n\t\tif(bps + FLAC__MAX_EXTRA_RESIDUAL_BPS < threshold) {\n\t\t\tfor(partition = residual_sample = 0; partition < partitions; partition++) {\n\t\t\t\tFLAC__uint32 abs_residual_partition_sum = 0;\n\t\t\t\tend += default_partition_samples;\n\t\t\t\tfor( ; residual_sample < end; residual_sample++)\n\t\t\t\t\tabs_residual_partition_sum += abs(residual[residual_sample]); /* abs(INT_MIN) is undefined, but if the residual is INT_MIN we have bigger problems */\n\t\t\t\tabs_residual_partition_sums[partition] = abs_residual_partition_sum;\n\t\t\t}\n\t\t}\n\t\telse { /* have to pessimistically use 64 bits for accumulator */\n\t\t\tfor(partition = residual_sample = 0; partition < partitions; partition++) {\n\t\t\t\tFLAC__uint64 abs_residual_partition_sum64 = 0;\n\t\t\t\tend += default_partition_samples;\n\t\t\t\tfor( ; residual_sample < end; residual_sample++)\n\t\t\t\t\tabs_residual_partition_sum64 += abs(residual[residual_sample]); /* abs(INT_MIN) is undefined, but if the residual is INT_MIN we have bigger problems */\n\t\t\t\tabs_residual_partition_sums[partition] = abs_residual_partition_sum64;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* now merge partitions for lower orders */\n\t{\n\t\tunsigned from_partition = 0, to_partition = partitions;\n\t\tint partition_order;\n\t\tfor(partition_order = (int)max_partition_order - 1; partition_order >= (int)min_partition_order; partition_order--) {\n\t\t\tunsigned i;\n\t\t\tpartitions >>= 1;\n\t\t\tfor(i = 0; i < partitions; i++) {\n\t\t\t\tabs_residual_partition_sums[to_partition++] =\n\t\t\t\t\tabs_residual_partition_sums[from_partition  ] +\n\t\t\t\t\tabs_residual_partition_sums[from_partition+1];\n\t\t\t\tfrom_partition += 2;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid precompute_partition_info_escapes_(\n\tconst FLAC__int32 residual[],\n\tunsigned raw_bits_per_partition[],\n\tunsigned residual_samples,\n\tunsigned predictor_order,\n\tunsigned min_partition_order,\n\tunsigned max_partition_order\n)\n{\n\tint partition_order;\n\tunsigned from_partition, to_partition = 0;\n\tconst unsigned blocksize = residual_samples + predictor_order;\n\n\t/* first do max_partition_order */\n\tfor(partition_order = (int)max_partition_order; partition_order >= 0; partition_order--) {\n\t\tFLAC__int32 r;\n\t\tFLAC__uint32 rmax;\n\t\tunsigned partition, partition_sample, partition_samples, residual_sample;\n\t\tconst unsigned partitions = 1u << partition_order;\n\t\tconst unsigned default_partition_samples = blocksize >> partition_order;\n\n\t\tFLAC__ASSERT(default_partition_samples > predictor_order);\n\n\t\tfor(partition = residual_sample = 0; partition < partitions; partition++) {\n\t\t\tpartition_samples = default_partition_samples;\n\t\t\tif(partition == 0)\n\t\t\t\tpartition_samples -= predictor_order;\n\t\t\trmax = 0;\n\t\t\tfor(partition_sample = 0; partition_sample < partition_samples; partition_sample++) {\n\t\t\t\tr = residual[residual_sample++];\n\t\t\t\t/* OPT: maybe faster: rmax |= r ^ (r>>31) */\n\t\t\t\tif(r < 0)\n\t\t\t\t\trmax |= ~r;\n\t\t\t\telse\n\t\t\t\t\trmax |= r;\n\t\t\t}\n\t\t\t/* now we know all residual values are in the range [-rmax-1,rmax] */\n\t\t\traw_bits_per_partition[partition] = rmax? FLAC__bitmath_ilog2(rmax) + 2 : 1;\n\t\t}\n\t\tto_partition = partitions;\n\t\tbreak; /*@@@ yuck, should remove the 'for' loop instead */\n\t}\n\n\t/* now merge partitions for lower orders */\n\tfor(from_partition = 0, --partition_order; partition_order >= (int)min_partition_order; partition_order--) {\n\t\tunsigned m;\n\t\tunsigned i;\n\t\tconst unsigned partitions = 1u << partition_order;\n\t\tfor(i = 0; i < partitions; i++) {\n\t\t\tm = raw_bits_per_partition[from_partition];\n\t\t\tfrom_partition++;\n\t\t\traw_bits_per_partition[to_partition] = flac_max(m, raw_bits_per_partition[from_partition]);\n\t\t\tfrom_partition++;\n\t\t\tto_partition++;\n\t\t}\n\t}\n}\n\n#ifdef EXACT_RICE_BITS_CALCULATION\nstatic inline unsigned count_rice_bits_in_partition_(\n\tconst unsigned rice_parameter,\n\tconst unsigned partition_samples,\n\tconst FLAC__int32 *residual\n)\n{\n\tunsigned i, partition_bits =\n\t\tFLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + /* actually could end up being FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN but err on side of 16bps */\n\t\t(1+rice_parameter) * partition_samples /* 1 for unary stop bit + rice_parameter for the binary portion */\n\t;\n\tfor(i = 0; i < partition_samples; i++)\n\t\tpartition_bits += ( (FLAC__uint32)((residual[i]<<1)^(residual[i]>>31)) >> rice_parameter );\n\treturn partition_bits;\n}\n#else\nstatic inline unsigned count_rice_bits_in_partition_(\n\tconst unsigned rice_parameter,\n\tconst unsigned partition_samples,\n\tconst FLAC__uint64 abs_residual_partition_sum\n)\n{\n\treturn\n\t\tFLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + /* actually could end up being FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN but err on side of 16bps */\n\t\t(1+rice_parameter) * partition_samples + /* 1 for unary stop bit + rice_parameter for the binary portion */\n\t\t(\n\t\t\trice_parameter?\n\t\t\t\t(unsigned)(abs_residual_partition_sum >> (rice_parameter-1)) /* rice_parameter-1 because the real coder sign-folds instead of using a sign bit */\n\t\t\t\t: (unsigned)(abs_residual_partition_sum << 1) /* can't shift by negative number, so reverse */\n\t\t)\n\t\t- (partition_samples >> 1)\n\t\t/* -(partition_samples>>1) to subtract out extra contributions to the abs_residual_partition_sum.\n\t\t * The actual number of bits used is closer to the sum(for all i in the partition) of  abs(residual[i])>>(rice_parameter-1)\n\t\t * By using the abs_residual_partition sum, we also add in bits in the LSBs that would normally be shifted out.\n\t\t * So the subtraction term tries to guess how many extra bits were contributed.\n\t\t * If the LSBs are randomly distributed, this should average to 0.5 extra bits per sample.\n\t\t */\n\t;\n}\n#endif\n\nFLAC__bool set_partitioned_rice_(\n#ifdef EXACT_RICE_BITS_CALCULATION\n\tconst FLAC__int32 residual[],\n#endif\n\tconst FLAC__uint64 abs_residual_partition_sums[],\n\tconst unsigned raw_bits_per_partition[],\n\tconst unsigned residual_samples,\n\tconst unsigned predictor_order,\n\tconst unsigned suggested_rice_parameter,\n\tconst unsigned rice_parameter_limit,\n\tconst unsigned rice_parameter_search_dist,\n\tconst unsigned partition_order,\n\tconst FLAC__bool search_for_escapes,\n\tFLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,\n\tunsigned *bits\n)\n{\n\tunsigned rice_parameter, partition_bits;\n\tunsigned best_partition_bits, best_rice_parameter = 0;\n\tunsigned bits_ = FLAC__ENTROPY_CODING_METHOD_TYPE_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN;\n\tunsigned *parameters, *raw_bits;\n#ifdef ENABLE_RICE_PARAMETER_SEARCH\n\tunsigned min_rice_parameter, max_rice_parameter;\n#else\n\t(void)rice_parameter_search_dist;\n#endif\n\n\tFLAC__ASSERT(suggested_rice_parameter < FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER);\n\tFLAC__ASSERT(rice_parameter_limit <= FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER);\n\n\tFLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(partitioned_rice_contents, flac_max(6u, partition_order));\n\tparameters = partitioned_rice_contents->parameters;\n\traw_bits = partitioned_rice_contents->raw_bits;\n\n\tif(partition_order == 0) {\n\t\tbest_partition_bits = (unsigned)(-1);\n#ifdef ENABLE_RICE_PARAMETER_SEARCH\n\t\tif(rice_parameter_search_dist) {\n\t\t\tif(suggested_rice_parameter < rice_parameter_search_dist)\n\t\t\t\tmin_rice_parameter = 0;\n\t\t\telse\n\t\t\t\tmin_rice_parameter = suggested_rice_parameter - rice_parameter_search_dist;\n\t\t\tmax_rice_parameter = suggested_rice_parameter + rice_parameter_search_dist;\n\t\t\tif(max_rice_parameter >= rice_parameter_limit) {\n#ifdef DEBUG_VERBOSE\n\t\t\t\tfprintf(stderr, \"clipping rice_parameter (%u -> %u) @5\\n\", max_rice_parameter, rice_parameter_limit - 1);\n#endif\n\t\t\t\tmax_rice_parameter = rice_parameter_limit - 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tmin_rice_parameter = max_rice_parameter = suggested_rice_parameter;\n\n\t\tfor(rice_parameter = min_rice_parameter; rice_parameter <= max_rice_parameter; rice_parameter++) {\n#else\n\t\t\trice_parameter = suggested_rice_parameter;\n#endif\n#ifdef EXACT_RICE_BITS_CALCULATION\n\t\t\tpartition_bits = count_rice_bits_in_partition_(rice_parameter, residual_samples, residual);\n#else\n\t\t\tpartition_bits = count_rice_bits_in_partition_(rice_parameter, residual_samples, abs_residual_partition_sums[0]);\n#endif\n\t\t\tif(partition_bits < best_partition_bits) {\n\t\t\t\tbest_rice_parameter = rice_parameter;\n\t\t\t\tbest_partition_bits = partition_bits;\n\t\t\t}\n#ifdef ENABLE_RICE_PARAMETER_SEARCH\n\t\t}\n#endif\n\t\tif(search_for_escapes) {\n\t\t\tpartition_bits = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN + raw_bits_per_partition[0] * residual_samples;\n\t\t\tif(partition_bits <= best_partition_bits) {\n\t\t\t\traw_bits[0] = raw_bits_per_partition[0];\n\t\t\t\tbest_rice_parameter = 0; /* will be converted to appropriate escape parameter later */\n\t\t\t\tbest_partition_bits = partition_bits;\n\t\t\t}\n\t\t\telse\n\t\t\t\traw_bits[0] = 0;\n\t\t}\n\t\tparameters[0] = best_rice_parameter;\n\t\tbits_ += best_partition_bits;\n\t}\n\telse {\n\t\tunsigned partition, residual_sample;\n\t\tunsigned partition_samples;\n\t\tFLAC__uint64 mean, k;\n\t\tconst unsigned partitions = 1u << partition_order;\n\t\tfor(partition = residual_sample = 0; partition < partitions; partition++) {\n\t\t\tpartition_samples = (residual_samples+predictor_order) >> partition_order;\n\t\t\tif(partition == 0) {\n\t\t\t\tif(partition_samples <= predictor_order)\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\tpartition_samples -= predictor_order;\n\t\t\t}\n\t\t\tmean = abs_residual_partition_sums[partition];\n\t\t\t/* we are basically calculating the size in bits of the\n\t\t\t * average residual magnitude in the partition:\n\t\t\t *   rice_parameter = floor(log2(mean/partition_samples))\n\t\t\t * 'mean' is not a good name for the variable, it is\n\t\t\t * actually the sum of magnitudes of all residual values\n\t\t\t * in the partition, so the actual mean is\n\t\t\t * mean/partition_samples\n\t\t\t */\n#if 0 /* old simple code */\n\t\t\tfor(rice_parameter = 0, k = partition_samples; k < mean; rice_parameter++, k <<= 1)\n\t\t\t\t;\n#else\n#if defined FLAC__CPU_X86_64 /* and other 64-bit arch, too */\n\t\t\tif(mean <= 0x80000000/512) { /* 512: more or less optimal for both 16- and 24-bit input */\n#else\n\t\t\tif(mean <= 0x80000000/8) { /* 32-bit arch: use 32-bit math if possible */\n#endif\n\t\t\t\tFLAC__uint32 k2, mean2 = (FLAC__uint32) mean;\n\t\t\t\trice_parameter = 0; k2 = partition_samples;\n\t\t\t\twhile(k2*8 < mean2) { /* requires: mean <= (2^31)/8 */\n\t\t\t\t\trice_parameter += 4; k2 <<= 4; /* tuned for 16-bit input */\n\t\t\t\t}\n\t\t\t\twhile(k2 < mean2) { /* requires: mean <= 2^31 */\n\t\t\t\t\trice_parameter++; k2 <<= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trice_parameter = 0; k = partition_samples;\n\t\t\t\tif(mean <= FLAC__U64L(0x8000000000000000)/128) /* usually mean is _much_ smaller than this value */\n\t\t\t\t\twhile(k*128 < mean) { /* requires: mean <= (2^63)/128 */\n\t\t\t\t\t\trice_parameter += 8; k <<= 8; /* tuned for 24-bit input */\n\t\t\t\t\t}\n\t\t\t\twhile(k < mean) { /* requires: mean <= 2^63 */\n\t\t\t\t\trice_parameter++; k <<= 1;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tif(rice_parameter >= rice_parameter_limit) {\n#ifdef DEBUG_VERBOSE\n\t\t\t\tfprintf(stderr, \"clipping rice_parameter (%u -> %u) @6\\n\", rice_parameter, rice_parameter_limit - 1);\n#endif\n\t\t\t\trice_parameter = rice_parameter_limit - 1;\n\t\t\t}\n\n\t\t\tbest_partition_bits = (unsigned)(-1);\n#ifdef ENABLE_RICE_PARAMETER_SEARCH\n\t\t\tif(rice_parameter_search_dist) {\n\t\t\t\tif(rice_parameter < rice_parameter_search_dist)\n\t\t\t\t\tmin_rice_parameter = 0;\n\t\t\t\telse\n\t\t\t\t\tmin_rice_parameter = rice_parameter - rice_parameter_search_dist;\n\t\t\t\tmax_rice_parameter = rice_parameter + rice_parameter_search_dist;\n\t\t\t\tif(max_rice_parameter >= rice_parameter_limit) {\n#ifdef DEBUG_VERBOSE\n\t\t\t\t\tfprintf(stderr, \"clipping rice_parameter (%u -> %u) @7\\n\", max_rice_parameter, rice_parameter_limit - 1);\n#endif\n\t\t\t\t\tmax_rice_parameter = rice_parameter_limit - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tmin_rice_parameter = max_rice_parameter = rice_parameter;\n\n\t\t\tfor(rice_parameter = min_rice_parameter; rice_parameter <= max_rice_parameter; rice_parameter++) {\n#endif\n#ifdef EXACT_RICE_BITS_CALCULATION\n\t\t\t\tpartition_bits = count_rice_bits_in_partition_(rice_parameter, partition_samples, residual+residual_sample);\n#else\n\t\t\t\tpartition_bits = count_rice_bits_in_partition_(rice_parameter, partition_samples, abs_residual_partition_sums[partition]);\n#endif\n\t\t\t\tif(partition_bits < best_partition_bits) {\n\t\t\t\t\tbest_rice_parameter = rice_parameter;\n\t\t\t\t\tbest_partition_bits = partition_bits;\n\t\t\t\t}\n#ifdef ENABLE_RICE_PARAMETER_SEARCH\n\t\t\t}\n#endif\n\t\t\tif(search_for_escapes) {\n\t\t\t\tpartition_bits = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN + raw_bits_per_partition[partition] * partition_samples;\n\t\t\t\tif(partition_bits <= best_partition_bits) {\n\t\t\t\t\traw_bits[partition] = raw_bits_per_partition[partition];\n\t\t\t\t\tbest_rice_parameter = 0; /* will be converted to appropriate escape parameter later */\n\t\t\t\t\tbest_partition_bits = partition_bits;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\traw_bits[partition] = 0;\n\t\t\t}\n\t\t\tparameters[partition] = best_rice_parameter;\n\t\t\tbits_ += best_partition_bits;\n\t\t\tresidual_sample += partition_samples;\n\t\t}\n\t}\n\n\t*bits = bits_;\n\treturn true;\n}\n\nunsigned get_wasted_bits_(FLAC__int32 signal[], unsigned samples)\n{\n\tunsigned i, shift;\n\tFLAC__int32 x = 0;\n\n\tfor(i = 0; i < samples && !(x&1); i++)\n\t\tx |= signal[i];\n\n\tif(x == 0) {\n\t\tshift = 0;\n\t}\n\telse {\n\t\tfor(shift = 0; !(x&1); shift++)\n\t\t\tx >>= 1;\n\t}\n\n\tif(shift > 0) {\n\t\tfor(i = 0; i < samples; i++)\n\t\t\t signal[i] >>= shift;\n\t}\n\n\treturn shift;\n}\n\nvoid append_to_verify_fifo_(verify_input_fifo *fifo, const FLAC__int32 * const input[], unsigned input_offset, unsigned channels, unsigned wide_samples)\n{\n\tunsigned channel;\n\n\tfor(channel = 0; channel < channels; channel++)\n\t\tmemcpy(&fifo->data[channel][fifo->tail], &input[channel][input_offset], sizeof(FLAC__int32) * wide_samples);\n\n\tfifo->tail += wide_samples;\n\n\tFLAC__ASSERT(fifo->tail <= fifo->size);\n}\n\nvoid append_to_verify_fifo_interleaved_(verify_input_fifo *fifo, const FLAC__int32 input[], unsigned input_offset, unsigned channels, unsigned wide_samples)\n{\n\tunsigned channel;\n\tunsigned sample, wide_sample;\n\tunsigned tail = fifo->tail;\n\n\tsample = input_offset * channels;\n\tfor(wide_sample = 0; wide_sample < wide_samples; wide_sample++) {\n\t\tfor(channel = 0; channel < channels; channel++)\n\t\t\tfifo->data[channel][tail] = input[sample++];\n\t\ttail++;\n\t}\n\tfifo->tail = tail;\n\n\tFLAC__ASSERT(fifo->tail <= fifo->size);\n}\n\nFLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n{\n\tFLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;\n\tconst size_t encoded_bytes = encoder->private_->verify.output.bytes;\n\t(void)decoder;\n\n\tif(encoder->private_->verify.needs_magic_hack) {\n\t\tFLAC__ASSERT(*bytes >= FLAC__STREAM_SYNC_LENGTH);\n\t\t*bytes = FLAC__STREAM_SYNC_LENGTH;\n\t\tmemcpy(buffer, FLAC__STREAM_SYNC_STRING, *bytes);\n\t\tencoder->private_->verify.needs_magic_hack = false;\n\t}\n\telse {\n\t\tif(encoded_bytes == 0) {\n\t\t\t/*\n\t\t\t * If we get here, a FIFO underflow has occurred,\n\t\t\t * which means there is a bug somewhere.\n\t\t\t */\n\t\t\tFLAC__ASSERT(0);\n\t\t\treturn FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n\t\t}\n\t\telse if(encoded_bytes < *bytes)\n\t\t\t*bytes = encoded_bytes;\n\t\tmemcpy(buffer, encoder->private_->verify.output.data, *bytes);\n\t\tencoder->private_->verify.output.data += *bytes;\n\t\tencoder->private_->verify.output.bytes -= *bytes;\n\t}\n\n\treturn FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n}\n\nFLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data)\n{\n\tFLAC__StreamEncoder *encoder = (FLAC__StreamEncoder *)client_data;\n\tunsigned channel;\n\tconst unsigned channels = frame->header.channels;\n\tconst unsigned blocksize = frame->header.blocksize;\n\tconst unsigned bytes_per_block = sizeof(FLAC__int32) * blocksize;\n\n\t(void)decoder;\n\n\tfor(channel = 0; channel < channels; channel++) {\n\t\tif(0 != memcmp(buffer[channel], encoder->private_->verify.input_fifo.data[channel], bytes_per_block)) {\n\t\t\tunsigned i, sample = 0;\n\t\t\tFLAC__int32 expect = 0, got = 0;\n\n\t\t\tfor(i = 0; i < blocksize; i++) {\n\t\t\t\tif(buffer[channel][i] != encoder->private_->verify.input_fifo.data[channel][i]) {\n\t\t\t\t\tsample = i;\n\t\t\t\t\texpect = (FLAC__int32)encoder->private_->verify.input_fifo.data[channel][i];\n\t\t\t\t\tgot = (FLAC__int32)buffer[channel][i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFLAC__ASSERT(i < blocksize);\n\t\t\tFLAC__ASSERT(frame->header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n\t\t\tencoder->private_->verify.error_stats.absolute_sample = frame->header.number.sample_number + sample;\n\t\t\tencoder->private_->verify.error_stats.frame_number = (unsigned)(frame->header.number.sample_number / blocksize);\n\t\t\tencoder->private_->verify.error_stats.channel = channel;\n\t\t\tencoder->private_->verify.error_stats.sample = sample;\n\t\t\tencoder->private_->verify.error_stats.expected = expect;\n\t\t\tencoder->private_->verify.error_stats.got = got;\n\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;\n\t\t\treturn FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;\n\t\t}\n\t}\n\t/* dequeue the frame from the fifo */\n\tencoder->private_->verify.input_fifo.tail -= blocksize;\n\tFLAC__ASSERT(encoder->private_->verify.input_fifo.tail <= OVERREAD_);\n\tfor(channel = 0; channel < channels; channel++)\n\t\tmemmove(&encoder->private_->verify.input_fifo.data[channel][0], &encoder->private_->verify.input_fifo.data[channel][blocksize], encoder->private_->verify.input_fifo.tail * sizeof(encoder->private_->verify.input_fifo.data[0][0]));\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;\n}\n\nvoid verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)\n{\n\t(void)decoder, (void)metadata, (void)client_data;\n}\n\nvoid verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)\n{\n\tFLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;\n\t(void)decoder, (void)status;\n\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n}\n\nFLAC__StreamEncoderReadStatus file_read_callback_(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n{\n\t(void)client_data;\n\n\t*bytes = fread(buffer, 1, *bytes, encoder->private_->file);\n\tif (*bytes == 0) {\n\t\tif (feof(encoder->private_->file))\n\t\t\treturn FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;\n\t\telse if (ferror(encoder->private_->file))\n\t\t\treturn FLAC__STREAM_ENCODER_READ_STATUS_ABORT;\n\t}\n\treturn FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;\n}\n\nFLAC__StreamEncoderSeekStatus file_seek_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)\n{\n\t(void)client_data;\n\n\tif(fseeko(encoder->private_->file, (FLAC__off_t)absolute_byte_offset, SEEK_SET) < 0)\n\t\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;\n\telse\n\t\treturn FLAC__STREAM_ENCODER_SEEK_STATUS_OK;\n}\n\nFLAC__StreamEncoderTellStatus file_tell_callback_(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)\n{\n\tFLAC__off_t offset;\n\n\t(void)client_data;\n\n\toffset = ftello(encoder->private_->file);\n\n\tif(offset < 0) {\n\t\treturn FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;\n\t}\n\telse {\n\t\t*absolute_byte_offset = (FLAC__uint64)offset;\n\t\treturn FLAC__STREAM_ENCODER_TELL_STATUS_OK;\n\t}\n}\n\n#ifdef FLAC__VALGRIND_TESTING\nstatic size_t local__fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n\tsize_t ret = fwrite(ptr, size, nmemb, stream);\n\tif(!ferror(stream))\n\t\tfflush(stream);\n\treturn ret;\n}\n#else\n#define local__fwrite fwrite\n#endif\n\nFLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)\n{\n\t(void)client_data, (void)current_frame;\n\n\tif(local__fwrite(buffer, sizeof(FLAC__byte), bytes, encoder->private_->file) == bytes) {\n\t\tFLAC__bool call_it = 0 != encoder->private_->progress_callback && (\n#if FLAC__HAS_OGG\n\t\t\t/* We would like to be able to use 'samples > 0' in the\n\t\t\t * clause here but currently because of the nature of our\n\t\t\t * Ogg writing implementation, 'samples' is always 0 (see\n\t\t\t * ogg_encoder_aspect.c).  The downside is extra progress\n\t\t\t * callbacks.\n\t\t\t */\n\t\t\tencoder->private_->is_ogg? true :\n#endif\n\t\t\tsamples > 0\n\t\t);\n\t\tif(call_it) {\n\t\t\t/* NOTE: We have to add +bytes, +samples, and +1 to the stats\n\t\t\t * because at this point in the callback chain, the stats\n\t\t\t * have not been updated.  Only after we return and control\n\t\t\t * gets back to write_frame_() are the stats updated\n\t\t\t */\n\t\t\tencoder->private_->progress_callback(encoder, encoder->private_->bytes_written+bytes, encoder->private_->samples_written+samples, encoder->private_->frames_written+(samples?1:0), encoder->private_->total_frames_estimate, encoder->private_->client_data);\n\t\t}\n\t\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_OK;\n\t}\n\telse\n\t\treturn FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;\n}\n\n/*\n * This will forcibly set stdout to binary mode (for OSes that require it)\n */\nFILE *get_binary_stdout_(void)\n{\n\t/* if something breaks here it is probably due to the presence or\n\t * absence of an underscore before the identifiers 'setmode',\n\t * 'fileno', and/or 'O_BINARY'; check your system header files.\n\t */\n#if defined _MSC_VER || defined __MINGW32__\n\t_setmode(_fileno(stdout), _O_BINARY);\n#elif defined __CYGWIN__\n\t/* almost certainly not needed for any modern Cygwin, but let's be safe... */\n\tsetmode(_fileno(stdout), _O_BINARY);\n#elif defined __EMX__\n\tsetmode(fileno(stdout), O_BINARY);\n#endif\n\n\treturn stdout;\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2000-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h> /* for strlen() */\n#include \"private/stream_encoder_framing.h\"\n#include \"private/crc.h\"\n#include \"FLAC/assert.h\"\n#include \"share/compat.h\"\n\nstatic FLAC__bool add_entropy_coding_method_(FLAC__BitWriter *bw, const FLAC__EntropyCodingMethod *method);\nstatic FLAC__bool add_residual_partitioned_rice_(FLAC__BitWriter *bw, const FLAC__int32 residual[], const unsigned residual_samples, const unsigned predictor_order, const unsigned rice_parameters[], const unsigned raw_bits[], const unsigned partition_order, const FLAC__bool is_extended);\n\nFLAC__bool FLAC__add_metadata_block(const FLAC__StreamMetadata *metadata, FLAC__BitWriter *bw)\n{\n\tunsigned i, j;\n\tconst unsigned vendor_string_length = (unsigned)strlen(FLAC__VENDOR_STRING);\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->is_last, FLAC__STREAM_METADATA_IS_LAST_LEN))\n\t\treturn false;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->type, FLAC__STREAM_METADATA_TYPE_LEN))\n\t\treturn false;\n\n\t/*\n\t * First, for VORBIS_COMMENTs, adjust the length to reflect our vendor string\n\t */\n\ti = metadata->length;\n\tif(metadata->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {\n\t\tFLAC__ASSERT(metadata->data.vorbis_comment.vendor_string.length == 0 || 0 != metadata->data.vorbis_comment.vendor_string.entry);\n\t\ti -= metadata->data.vorbis_comment.vendor_string.length;\n\t\ti += vendor_string_length;\n\t}\n\tFLAC__ASSERT(i < (1u << FLAC__STREAM_METADATA_LENGTH_LEN));\n\t/* double protection */\n\tif(i >= (1u << FLAC__STREAM_METADATA_LENGTH_LEN))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, i, FLAC__STREAM_METADATA_LENGTH_LEN))\n\t\treturn false;\n\n\tswitch(metadata->type) {\n\t\tcase FLAC__METADATA_TYPE_STREAMINFO:\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.min_blocksize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.min_blocksize, FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.max_blocksize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.max_blocksize, FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.min_framesize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.min_framesize, FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.max_framesize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.max_framesize, FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(FLAC__format_sample_rate_is_valid(metadata->data.stream_info.sample_rate));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.sample_rate, FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.channels > 0);\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.channels <= (1u << FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.channels-1, FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.bits_per_sample > 0);\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.bits_per_sample <= (1u << FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.bits_per_sample-1, FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN))\n\t\t\t\treturn false;\n\t\t\tFLAC__ASSERT(metadata->data.stream_info.total_samples < (FLAC__U64L(1) << FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN));\n\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.stream_info.total_samples, FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.stream_info.md5sum, 16))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_PADDING:\n\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, metadata->length * 8))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_APPLICATION:\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.application.id, FLAC__STREAM_METADATA_APPLICATION_ID_LEN / 8))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.application.data, metadata->length - (FLAC__STREAM_METADATA_APPLICATION_ID_LEN / 8)))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_SEEKTABLE:\n\t\t\tfor(i = 0; i < metadata->data.seek_table.num_points; i++) {\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.seek_table.points[i].sample_number, FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.seek_table.points[i].stream_offset, FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.seek_table.points[i].frame_samples, FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_VORBIS_COMMENT:\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, vendor_string_length))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)FLAC__VENDOR_STRING, vendor_string_length))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, metadata->data.vorbis_comment.num_comments))\n\t\t\t\treturn false;\n\t\t\tfor(i = 0; i < metadata->data.vorbis_comment.num_comments; i++) {\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, metadata->data.vorbis_comment.comments[i].length))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.vorbis_comment.comments[i].entry, metadata->data.vorbis_comment.comments[i].length))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_CUESHEET:\n\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN % 8 == 0);\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)metadata->data.cue_sheet.media_catalog_number, FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN/8))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.cue_sheet.lead_in, FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.cue_sheet.is_cd? 1 : 0, FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.cue_sheet.num_tracks, FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN))\n\t\t\t\treturn false;\n\t\t\tfor(i = 0; i < metadata->data.cue_sheet.num_tracks; i++) {\n\t\t\t\tconst FLAC__StreamMetadata_CueSheet_Track *track = metadata->data.cue_sheet.tracks + i;\n\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, track->offset, FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, track->number, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tFLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN % 8 == 0);\n\t\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)track->isrc, FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN/8))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, track->type, FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, track->pre_emphasis, FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, track->num_indices, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tfor(j = 0; j < track->num_indices; j++) {\n\t\t\t\t\tconst FLAC__StreamMetadata_CueSheet_Index *indx = track->indices + j;\n\n\t\t\t\t\tif(!FLAC__bitwriter_write_raw_uint64(bw, indx->offset, FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, indx->number, FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLAC__METADATA_TYPE_PICTURE:\n\t\t\t{\n\t\t\t\tsize_t len;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.type, FLAC__STREAM_METADATA_PICTURE_TYPE_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tlen = strlen(metadata->data.picture.mime_type);\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, len, FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)metadata->data.picture.mime_type, len))\n\t\t\t\t\treturn false;\n\t\t\t\tlen = strlen((const char *)metadata->data.picture.description);\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, len, FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.picture.description, len))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.width, FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.height, FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.depth, FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.colors, FLAC__STREAM_METADATA_PICTURE_COLORS_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.data_length, FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.picture.data, metadata->data.picture.data_length))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(!FLAC__bitwriter_write_byte_block(bw, metadata->data.unknown.data, metadata->length))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(bw));\n\treturn true;\n}\n\nFLAC__bool FLAC__frame_add_header(const FLAC__FrameHeader *header, FLAC__BitWriter *bw)\n{\n\tunsigned u, blocksize_hint, sample_rate_hint;\n\tFLAC__byte crc;\n\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(bw));\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__FRAME_HEADER_SYNC, FLAC__FRAME_HEADER_SYNC_LEN))\n\t\treturn false;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, 0, FLAC__FRAME_HEADER_RESERVED_LEN))\n\t\treturn false;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, (header->number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER)? 0 : 1, FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN))\n\t\treturn false;\n\n\tFLAC__ASSERT(header->blocksize > 0 && header->blocksize <= FLAC__MAX_BLOCK_SIZE);\n\t/* when this assertion holds true, any legal blocksize can be expressed in the frame header */\n\tFLAC__ASSERT(FLAC__MAX_BLOCK_SIZE <= 65535u);\n\tblocksize_hint = 0;\n\tswitch(header->blocksize) {\n\t\tcase   192: u = 1; break;\n\t\tcase   576: u = 2; break;\n\t\tcase  1152: u = 3; break;\n\t\tcase  2304: u = 4; break;\n\t\tcase  4608: u = 5; break;\n\t\tcase   256: u = 8; break;\n\t\tcase   512: u = 9; break;\n\t\tcase  1024: u = 10; break;\n\t\tcase  2048: u = 11; break;\n\t\tcase  4096: u = 12; break;\n\t\tcase  8192: u = 13; break;\n\t\tcase 16384: u = 14; break;\n\t\tcase 32768: u = 15; break;\n\t\tdefault:\n\t\t\tif(header->blocksize <= 0x100)\n\t\t\t\tblocksize_hint = u = 6;\n\t\t\telse\n\t\t\t\tblocksize_hint = u = 7;\n\t\t\tbreak;\n\t}\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_BLOCK_SIZE_LEN))\n\t\treturn false;\n\n\tFLAC__ASSERT(FLAC__format_sample_rate_is_valid(header->sample_rate));\n\tsample_rate_hint = 0;\n\tswitch(header->sample_rate) {\n\t\tcase  88200: u = 1; break;\n\t\tcase 176400: u = 2; break;\n\t\tcase 192000: u = 3; break;\n\t\tcase   8000: u = 4; break;\n\t\tcase  16000: u = 5; break;\n\t\tcase  22050: u = 6; break;\n\t\tcase  24000: u = 7; break;\n\t\tcase  32000: u = 8; break;\n\t\tcase  44100: u = 9; break;\n\t\tcase  48000: u = 10; break;\n\t\tcase  96000: u = 11; break;\n\t\tdefault:\n\t\t\tif(header->sample_rate <= 255000 && header->sample_rate % 1000 == 0)\n\t\t\t\tsample_rate_hint = u = 12;\n\t\t\telse if(header->sample_rate % 10 == 0)\n\t\t\t\tsample_rate_hint = u = 14;\n\t\t\telse if(header->sample_rate <= 0xffff)\n\t\t\t\tsample_rate_hint = u = 13;\n\t\t\telse\n\t\t\t\tu = 0;\n\t\t\tbreak;\n\t}\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_SAMPLE_RATE_LEN))\n\t\treturn false;\n\n\tFLAC__ASSERT(header->channels > 0 && header->channels <= (1u << FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN) && header->channels <= FLAC__MAX_CHANNELS);\n\tswitch(header->channel_assignment) {\n\t\tcase FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:\n\t\t\tu = header->channels - 1;\n\t\t\tbreak;\n\t\tcase FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:\n\t\t\tFLAC__ASSERT(header->channels == 2);\n\t\t\tu = 8;\n\t\t\tbreak;\n\t\tcase FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:\n\t\t\tFLAC__ASSERT(header->channels == 2);\n\t\t\tu = 9;\n\t\t\tbreak;\n\t\tcase FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:\n\t\t\tFLAC__ASSERT(header->channels == 2);\n\t\t\tu = 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN))\n\t\treturn false;\n\n\tFLAC__ASSERT(header->bits_per_sample > 0 && header->bits_per_sample <= (1u << FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN));\n\tswitch(header->bits_per_sample) {\n\t\tcase 8 : u = 1; break;\n\t\tcase 12: u = 2; break;\n\t\tcase 16: u = 4; break;\n\t\tcase 20: u = 5; break;\n\t\tcase 24: u = 6; break;\n\t\tdefault: u = 0; break;\n\t}\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN))\n\t\treturn false;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, 0, FLAC__FRAME_HEADER_ZERO_PAD_LEN))\n\t\treturn false;\n\n\tif(header->number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER) {\n\t\tif(!FLAC__bitwriter_write_utf8_uint32(bw, header->number.frame_number))\n\t\t\treturn false;\n\t}\n\telse {\n\t\tif(!FLAC__bitwriter_write_utf8_uint64(bw, header->number.sample_number))\n\t\t\treturn false;\n\t}\n\n\tif(blocksize_hint)\n\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, header->blocksize-1, (blocksize_hint==6)? 8:16))\n\t\t\treturn false;\n\n\tswitch(sample_rate_hint) {\n\t\tcase 12:\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate / 1000, 8))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate, 16))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate / 10, 16))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\n\t/* write the CRC */\n\tif(!FLAC__bitwriter_get_write_crc8(bw, &crc))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, crc, FLAC__FRAME_HEADER_CRC_LEN))\n\t\treturn false;\n\n\treturn true;\n}\n\nFLAC__bool FLAC__subframe_add_constant(const FLAC__Subframe_Constant *subframe, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)\n{\n\tFLAC__bool ok;\n\n\tok =\n\t\tFLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN) &&\n\t\t(wasted_bits? FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1) : true) &&\n\t\tFLAC__bitwriter_write_raw_int32(bw, subframe->value, subframe_bps)\n\t;\n\n\treturn ok;\n}\n\nFLAC__bool FLAC__subframe_add_fixed(const FLAC__Subframe_Fixed *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)\n{\n\tunsigned i;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK | (subframe->order<<1) | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))\n\t\treturn false;\n\tif(wasted_bits)\n\t\tif(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))\n\t\t\treturn false;\n\n\tfor(i = 0; i < subframe->order; i++)\n\t\tif(!FLAC__bitwriter_write_raw_int32(bw, subframe->warmup[i], subframe_bps))\n\t\t\treturn false;\n\n\tif(!add_entropy_coding_method_(bw, &subframe->entropy_coding_method))\n\t\treturn false;\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!add_residual_partitioned_rice_(\n\t\t\t\tbw,\n\t\t\t\tsubframe->residual,\n\t\t\t\tresidual_samples,\n\t\t\t\tsubframe->order,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents->parameters,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents->raw_bits,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.order,\n\t\t\t\t/*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2\n\t\t\t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__subframe_add_lpc(const FLAC__Subframe_LPC *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)\n{\n\tunsigned i;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK | ((subframe->order-1)<<1) | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))\n\t\treturn false;\n\tif(wasted_bits)\n\t\tif(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))\n\t\t\treturn false;\n\n\tfor(i = 0; i < subframe->order; i++)\n\t\tif(!FLAC__bitwriter_write_raw_int32(bw, subframe->warmup[i], subframe_bps))\n\t\t\treturn false;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, subframe->qlp_coeff_precision-1, FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN))\n\t\treturn false;\n\tif(!FLAC__bitwriter_write_raw_int32(bw, subframe->quantization_level, FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN))\n\t\treturn false;\n\tfor(i = 0; i < subframe->order; i++)\n\t\tif(!FLAC__bitwriter_write_raw_int32(bw, subframe->qlp_coeff[i], subframe->qlp_coeff_precision))\n\t\t\treturn false;\n\n\tif(!add_entropy_coding_method_(bw, &subframe->entropy_coding_method))\n\t\treturn false;\n\tswitch(subframe->entropy_coding_method.type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!add_residual_partitioned_rice_(\n\t\t\t\tbw,\n\t\t\t\tsubframe->residual,\n\t\t\t\tresidual_samples,\n\t\t\t\tsubframe->order,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents->parameters,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.contents->raw_bits,\n\t\t\t\tsubframe->entropy_coding_method.data.partitioned_rice.order,\n\t\t\t\t/*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2\n\t\t\t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\n\treturn true;\n}\n\nFLAC__bool FLAC__subframe_add_verbatim(const FLAC__Subframe_Verbatim *subframe, unsigned samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)\n{\n\tunsigned i;\n\tconst FLAC__int32 *signal = subframe->data;\n\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))\n\t\treturn false;\n\tif(wasted_bits)\n\t\tif(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))\n\t\t\treturn false;\n\n\tfor(i = 0; i < samples; i++)\n\t\tif(!FLAC__bitwriter_write_raw_int32(bw, signal[i], subframe_bps))\n\t\t\treturn false;\n\n\treturn true;\n}\n\nFLAC__bool add_entropy_coding_method_(FLAC__BitWriter *bw, const FLAC__EntropyCodingMethod *method)\n{\n\tif(!FLAC__bitwriter_write_raw_uint32(bw, method->type, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))\n\t\treturn false;\n\tswitch(method->type) {\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:\n\t\tcase FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, method->data.partitioned_rice.order, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tFLAC__ASSERT(0);\n\t}\n\treturn true;\n}\n\nFLAC__bool add_residual_partitioned_rice_(FLAC__BitWriter *bw, const FLAC__int32 residual[], const unsigned residual_samples, const unsigned predictor_order, const unsigned rice_parameters[], const unsigned raw_bits[], const unsigned partition_order, const FLAC__bool is_extended)\n{\n\tconst unsigned plen = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;\n\tconst unsigned pesc = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;\n\n\tif(partition_order == 0) {\n\t\tunsigned i;\n\n\t\tif(raw_bits[0] == 0) {\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, rice_parameters[0], plen))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_rice_signed_block(bw, residual, residual_samples, rice_parameters[0]))\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tFLAC__ASSERT(rice_parameters[0] == 0);\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pesc, plen))\n\t\t\t\treturn false;\n\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, raw_bits[0], FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))\n\t\t\t\treturn false;\n\t\t\tfor(i = 0; i < residual_samples; i++) {\n\t\t\t\tif(!FLAC__bitwriter_write_raw_int32(bw, residual[i], raw_bits[0]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse {\n\t\tunsigned i, j, k = 0, k_last = 0;\n\t\tunsigned partition_samples;\n\t\tconst unsigned default_partition_samples = (residual_samples+predictor_order) >> partition_order;\n\t\tfor(i = 0; i < (1u<<partition_order); i++) {\n\t\t\tpartition_samples = default_partition_samples;\n\t\t\tif(i == 0)\n\t\t\t\tpartition_samples -= predictor_order;\n\t\t\tk += partition_samples;\n\t\t\tif(raw_bits[i] == 0) {\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, rice_parameters[i], plen))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_rice_signed_block(bw, residual+k_last, k-k_last, rice_parameters[i]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, pesc, plen))\n\t\t\t\t\treturn false;\n\t\t\t\tif(!FLAC__bitwriter_write_raw_uint32(bw, raw_bits[i], FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))\n\t\t\t\t\treturn false;\n\t\t\t\tfor(j = k_last; j < k; j++) {\n\t\t\t\t\tif(!FLAC__bitwriter_write_raw_int32(bw, residual[j], raw_bits[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk_last = k;\n\t\t}\n\t\treturn true;\n\t}\n}\n","/* libFLAC - Free Lossless Audio Codec library\n * Copyright (C) 2006-2009  Josh Coalson\n * Copyright (C) 2011-2016  Xiph.Org Foundation\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * - Neither the name of the Xiph.org Foundation nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <math.h>\n#include \"share/compat.h\"\n#include \"FLAC/assert.h\"\n#include \"FLAC/format.h\"\n#include \"private/window.h\"\n\n#ifndef FLAC__INTEGER_ONLY_LIBRARY\n\n\nvoid FLAC__window_bartlett(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tif (L & 1) {\n\t\tfor (n = 0; n <= N/2; n++)\n\t\t\twindow[n] = 2.0f * n / (float)N;\n\t\tfor (; n <= N; n++)\n\t\t\twindow[n] = 2.0f - 2.0f * n / (float)N;\n\t}\n\telse {\n\t\tfor (n = 0; n <= L/2-1; n++)\n\t\t\twindow[n] = 2.0f * n / (float)N;\n\t\tfor (; n <= N; n++)\n\t\t\twindow[n] = 2.0f - 2.0f * n / (float)N;\n\t}\n}\n\nvoid FLAC__window_bartlett_hann(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.62f - 0.48f * fabs((float)n/(float)N-0.5f) - 0.38f * cos(2.0f * M_PI * ((float)n/(float)N)));\n}\n\nvoid FLAC__window_blackman(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.42f - 0.5f * cos(2.0f * M_PI * n / N) + 0.08f * cos(4.0f * M_PI * n / N));\n}\n\n/* 4-term -92dB side-lobe */\nvoid FLAC__window_blackman_harris_4term_92db_sidelobe(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n <= N; n++)\n\t\twindow[n] = (FLAC__real)(0.35875f - 0.48829f * cos(2.0f * M_PI * n / N) + 0.14128f * cos(4.0f * M_PI * n / N) - 0.01168f * cos(6.0f * M_PI * n / N));\n}\n\nvoid FLAC__window_connes(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tconst double N2 = (double)N / 2.;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n <= N; n++) {\n\t\tdouble k = ((double)n - N2) / N2;\n\t\tk = 1.0f - k * k;\n\t\twindow[n] = (FLAC__real)(k * k);\n\t}\n}\n\nvoid FLAC__window_flattop(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(1.0f - 1.93f * cos(2.0f * M_PI * n / N) + 1.29f * cos(4.0f * M_PI * n / N) - 0.388f * cos(6.0f * M_PI * n / N) + 0.0322f * cos(8.0f * M_PI * n / N));\n}\n\nvoid FLAC__window_gauss(FLAC__real *window, const FLAC__int32 L, const FLAC__real stddev)\n{\n\tconst FLAC__int32 N = L - 1;\n\tconst double N2 = (double)N / 2.;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n <= N; n++) {\n\t\tconst double k = ((double)n - N2) / (stddev * N2);\n\t\twindow[n] = (FLAC__real)exp(-0.5f * k * k);\n\t}\n}\n\nvoid FLAC__window_hamming(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.54f - 0.46f * cos(2.0f * M_PI * n / N));\n}\n\nvoid FLAC__window_hann(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(2.0f * M_PI * n / N));\n}\n\nvoid FLAC__window_kaiser_bessel(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.402f - 0.498f * cos(2.0f * M_PI * n / N) + 0.098f * cos(4.0f * M_PI * n / N) - 0.001f * cos(6.0f * M_PI * n / N));\n}\n\nvoid FLAC__window_nuttall(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = (FLAC__real)(0.3635819f - 0.4891775f*cos(2.0f*M_PI*n/N) + 0.1365995f*cos(4.0f*M_PI*n/N) - 0.0106411f*cos(6.0f*M_PI*n/N));\n}\n\nvoid FLAC__window_rectangle(FLAC__real *window, const FLAC__int32 L)\n{\n\tFLAC__int32 n;\n\n\tfor (n = 0; n < L; n++)\n\t\twindow[n] = 1.0f;\n}\n\nvoid FLAC__window_triangle(FLAC__real *window, const FLAC__int32 L)\n{\n\tFLAC__int32 n;\n\n\tif (L & 1) {\n\t\tfor (n = 1; n <= (L+1)/2; n++)\n\t\t\twindow[n-1] = 2.0f * n / ((float)L + 1.0f);\n\t\tfor (; n <= L; n++)\n\t\t\twindow[n-1] = (float)(2 * (L - n + 1)) / ((float)L + 1.0f);\n\t}\n\telse {\n\t\tfor (n = 1; n <= L/2; n++)\n\t\t\twindow[n-1] = 2.0f * n / ((float)L + 1.0f);\n\t\tfor (; n <= L; n++)\n\t\t\twindow[n-1] = (float)(2 * (L - n + 1)) / ((float)L + 1.0f);\n\t}\n}\n\nvoid FLAC__window_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p)\n{\n\tif (p <= 0.0)\n\t\tFLAC__window_rectangle(window, L);\n\telse if (p >= 1.0)\n\t\tFLAC__window_hann(window, L);\n\telse {\n\t\tconst FLAC__int32 Np = (FLAC__int32)(p / 2.0f * L) - 1;\n\t\tFLAC__int32 n;\n\t\t/* start with rectangle... */\n\t\tFLAC__window_rectangle(window, L);\n\t\t/* ...replace ends with hann */\n\t\tif (Np > 0) {\n\t\t\tfor (n = 0; n <= Np; n++) {\n\t\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * n / Np));\n\t\t\t\twindow[L-Np-1+n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * (n+Np) / Np));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid FLAC__window_partial_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p, const FLAC__real start, const FLAC__real end)\n{\n\tconst FLAC__int32 start_n = (FLAC__int32)(start * L);\n\tconst FLAC__int32 end_n = (FLAC__int32)(end * L);\n\tconst FLAC__int32 N = end_n - start_n;\n\tFLAC__int32 Np, n, i;\n\n\tif (p <= 0.0f)\n\t\tFLAC__window_partial_tukey(window, L, 0.05f, start, end);\n\telse if (p >= 1.0f)\n\t\tFLAC__window_partial_tukey(window, L, 0.95f, start, end);\n\telse {\n\n\t\tNp = (FLAC__int32)(p / 2.0f * N);\n\n\t\tfor (n = 0; n < start_n && n < L; n++)\n\t\t\twindow[n] = 0.0f;\n\t\tfor (i = 1; n < (start_n+Np) && n < L; n++, i++)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Np));\n\t\tfor (; n < (end_n-Np) && n < L; n++)\n\t\t\twindow[n] = 1.0f;\n\t\tfor (i = Np; n < end_n && n < L; n++, i--)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Np));\n\t\tfor (; n < L; n++)\n\t\t\twindow[n] = 0.0f;\n\t}\n}\n\nvoid FLAC__window_punchout_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p, const FLAC__real start, const FLAC__real end)\n{\n\tconst FLAC__int32 start_n = (FLAC__int32)(start * L);\n\tconst FLAC__int32 end_n = (FLAC__int32)(end * L);\n\tFLAC__int32 Ns, Ne, n, i;\n\n\tif (p <= 0.0f)\n\t\tFLAC__window_punchout_tukey(window, L, 0.05f, start, end);\n\telse if (p >= 1.0f)\n\t\tFLAC__window_punchout_tukey(window, L, 0.95f, start, end);\n\telse {\n\n\t\tNs = (FLAC__int32)(p / 2.0f * start_n);\n\t\tNe = (FLAC__int32)(p / 2.0f * (L - end_n));\n\n\t\tfor (n = 0, i = 1; n < Ns && n < L; n++, i++)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Ns));\n\t\tfor (; n < start_n-Ns && n < L; n++)\n\t\t\twindow[n] = 1.0f;\n\t\tfor (i = Ns; n < start_n && n < L; n++, i--)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Ns));\n\t\tfor (; n < end_n && n < L; n++)\n\t\t\twindow[n] = 0.0f;\n\t\tfor (i = 1; n < end_n+Ne && n < L; n++, i++)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Ne));\n\t\tfor (; n < L - (Ne) && n < L; n++)\n\t\t\twindow[n] = 1.0f;\n\t\tfor (i = Ne; n < L; n++, i--)\n\t\t\twindow[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * i / Ne));\n\t}\n}\n\nvoid FLAC__window_welch(FLAC__real *window, const FLAC__int32 L)\n{\n\tconst FLAC__int32 N = L - 1;\n\tconst double N2 = (double)N / 2.;\n\tFLAC__int32 n;\n\n\tfor (n = 0; n <= N; n++) {\n\t\tconst double k = ((double)n - N2) / N2;\n\t\twindow[n] = (FLAC__real)(1.0f - k * k);\n\t}\n}\n\n#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */\n"]}