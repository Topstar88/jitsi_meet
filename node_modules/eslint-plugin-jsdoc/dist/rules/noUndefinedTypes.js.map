{"version":3,"sources":["../../src/rules/noUndefinedTypes.js"],"names":["extraTypes","context","jsdoc","report","sourceCode","scopeManager","globalScope","typedefDeclarations","getAllComments","filter","comment","_","startsWith","value","map","parseComment","flatMap","doc","tags","tag","name","definedTypes","variables","variable","concat","isModule","childScopes","forEach","parsedType","type","error","node","includes","markVariableAsUsed"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;;;;;AAEA,IAAMA,aAAa,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgC,KAAhC,EAAuC,GAAvC,CAAnB;;kBAEe,4BAAa,gBAKtB;AAAA,MAJJC,OAII,QAJJA,OAII;AAAA,MAHJC,KAGI,QAHJA,KAGI;AAAA,MAFJC,MAEI,QAFJA,MAEI;AAAA,MADJC,UACI,QADJA,UACI;;AACJ,MAAMC,eAAeD,WAAWC,YAAhC;AACA,MAAMC,cAAcD,aAAaC,WAAjC;;AAEA,MAAMC,sBAAsB,sBAAEN,QAAQO,cAAR,EAAF,EACzBC,MADyB,CAClB,UAACC,OAAD,EAAa;AACnB,WAAOC,iBAAEC,UAAF,CAAaF,QAAQG,KAArB,EAA4B,GAA5B,CAAP;AACD,GAHyB,EAIzBC,GAJyB,CAIrBC,0BAJqB,EAKzBC,OALyB,CAKjB,UAACC,GAAD,EAAS;AAChB,WAAO,CAACA,IAAIC,IAAJ,IAAY,EAAb,EAAiBT,MAAjB,CAAwB,UAACU,GAAD,EAAS;AACtC,aAAOA,IAAIA,GAAJ,KAAY,SAAnB;AACD,KAFM,CAAP;AAGD,GATyB,EAUzBL,GAVyB,CAUrB,UAACK,GAAD,EAAS;AACZ,WAAOA,IAAIC,IAAX;AACD,GAZyB,EAazBP,KAbyB,EAA5B;;AAeA,MAAMQ,eAAef,YAAYgB,SAAZ,CAAsBR,GAAtB,CAA0B,UAACS,QAAD,EAAc;AAC3D,WAAOA,SAASH,IAAhB;AACD,GAFoB;;AAInB;AAJmB,GAKlBI,MALkB,CAKXnB,aAAaoB,QAAb,KAA0BnB,YAAYoB,WAAZ,CAAwB,CAAxB,EAA2BJ,SAA3B,CAAqCR,GAArC,CAAyC,UAACS,QAAD,EAAc;AACvF,WAAOA,SAASH,IAAhB;AACD,GAFiC,CAA1B,GAEH,EAPc,EAQlBI,MARkB,CAQXxB,UARW,EASlBwB,MATkB,CASXjB,mBATW,CAArB;;AAWAI,mBAAEgB,OAAF,CAAUzB,MAAMgB,IAAhB,EAAsB,UAACC,GAAD,EAAS;AAC7B,QAAIS,mBAAJ;;AAEA,QAAI;AACFA,mBAAa,4BAAUT,IAAIU,IAAd,CAAb;AACD,KAFD,CAEE,OAAOC,KAAP,EAAc;AACd;AACA;AACD;;AAED,mCAASF,UAAT,EAAqB,UAACG,IAAD,EAAU;AAC7B,UAAIA,KAAKF,IAAL,KAAc,MAAlB,EAA0B;AACxB,YAAI,CAAClB,iBAAEqB,QAAF,CAAWX,YAAX,EAAyBU,KAAKX,IAA9B,CAAL,EAA0C;AACxCjB,iBAAO,gBAAgB4B,KAAKX,IAArB,GAA4B,kBAAnC;AACD,SAFD,MAEO,IAAI,CAACT,iBAAEqB,QAAF,CAAWhC,UAAX,EAAuB+B,KAAKX,IAA5B,CAAL,EAAwC;AAC7CnB,kBAAQgC,kBAAR,CAA2BF,KAAKX,IAAhC;AACD;AACF;AACF,KARD;AASD,GAnBD;AAoBD,CAvDc,C","file":"noUndefinedTypes.js","sourcesContent":["import _ from 'lodash';\nimport {parse as parseType, traverse} from 'jsdoctypeparser';\nimport iterateJsdoc, {parseComment} from '../iterateJsdoc';\n\nconst extraTypes = ['string', 'number', 'boolean', 'any', '*'];\n\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  report,\n  sourceCode\n}) => {\n  const scopeManager = sourceCode.scopeManager;\n  const globalScope = scopeManager.globalScope;\n\n  const typedefDeclarations = _(context.getAllComments())\n    .filter((comment) => {\n      return _.startsWith(comment.value, '*');\n    })\n    .map(parseComment)\n    .flatMap((doc) => {\n      return (doc.tags || []).filter((tag) => {\n        return tag.tag === 'typedef';\n      });\n    })\n    .map((tag) => {\n      return tag.name;\n    })\n    .value();\n\n  const definedTypes = globalScope.variables.map((variable) => {\n    return variable.name;\n  })\n\n    // If the file is a module, concat the variables from the module scope.\n    .concat(scopeManager.isModule() ? globalScope.childScopes[0].variables.map((variable) => {\n      return variable.name;\n    }) : [])\n    .concat(extraTypes)\n    .concat(typedefDeclarations);\n\n  _.forEach(jsdoc.tags, (tag) => {\n    let parsedType;\n\n    try {\n      parsedType = parseType(tag.type);\n    } catch (error) {\n      // On syntax error, will be handled by valid-types.\n      return;\n    }\n\n    traverse(parsedType, (node) => {\n      if (node.type === 'NAME') {\n        if (!_.includes(definedTypes, node.name)) {\n          report('The type \\'' + node.name + '\\' is undefined.');\n        } else if (!_.includes(extraTypes, node.name)) {\n          context.markVariableAsUsed(node.name);\n        }\n      }\n    });\n  });\n});\n"]}