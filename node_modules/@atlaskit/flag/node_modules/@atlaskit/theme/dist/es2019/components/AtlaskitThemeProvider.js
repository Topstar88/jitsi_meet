import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled, { ThemeProvider } from 'styled-components';
import exenv from 'exenv';
import * as colors from '../colors';
import { CHANNEL, DEFAULT_THEME_MODE } from '../constants';
// For forward-compat until everything is upgraded.
import Theme from './Theme';
function getStylesheetResetCSS(backgroundColor) {
    return `
    body { background: ${backgroundColor}; }
  `;
}
function buildThemeState(mode) {
    return { theme: { [CHANNEL]: { mode } } };
}
const LegacyReset = styled.div `
  background-color: ${p => p.background};
  color: ${colors.text};

  a {
    color: ${colors.link};
  }
  a:hover {
    color: ${colors.linkHover};
  }
  a:active {
    color: ${colors.linkActive};
  }
  a:focus {
    outline-color: ${colors.linkOutline};
  }
  h1 {
    color: ${colors.heading};
  }
  h2 {
    color: ${colors.heading};
  }
  h3 {
    color: ${colors.heading};
  }
  h4 {
    color: ${colors.heading};
  }
  h5 {
    color: ${colors.heading};
  }
  h6 {
    color: ${colors.subtleHeading};
  }
  small {
    color: ${colors.subtleText};
  }
`;
export default class AtlaskitThemeProvider extends Component {
    constructor(props) {
        super(props);
        /**
         * This function never changes its reference because it accesses
         * `this` in the function call - thereby sidestepping the need for
         * creating a new reference everytime theme state changes.
         * NOTE: When moving to hooks watch out for this regressing.
         */
        this.getThemeMode = () => ({ mode: this.state.theme[CHANNEL].mode });
        this.state = buildThemeState(props.mode);
    }
    getChildContext() {
        return { hasAtlaskitThemeProvider: true };
    }
    UNSAFE_componentWillMount() {
        if (!this.context.hasAtlaskitThemeProvider && exenv.canUseDOM) {
            const css = getStylesheetResetCSS(this.props.background(this.state));
            this.stylesheet = document.createElement('style');
            this.stylesheet.type = 'text/css';
            this.stylesheet.innerHTML = css;
            if (document && document.head) {
                document.head.appendChild(this.stylesheet);
            }
        }
    }
    UNSAFE_componentWillReceiveProps(newProps) {
        if (newProps.mode !== this.props.mode) {
            const newThemeState = buildThemeState(newProps.mode);
            if (this.stylesheet) {
                const css = getStylesheetResetCSS(newProps.background(newThemeState));
                this.stylesheet.innerHTML = css;
            }
            this.setState(newThemeState);
        }
    }
    componentWillUnmount() {
        if (this.stylesheet && document && document.head) {
            document.head.removeChild(this.stylesheet);
            delete this.stylesheet;
        }
    }
    render() {
        const { children } = this.props;
        const { theme } = this.state;
        return (
        /* Wrapping the new provider around the old one provides forward
        compatibility when using the old provider for styled components. This
        allows us to use components converted to use the new API with consumers
        using the old provider along side components that may still be using the
        old theming API. */
        React.createElement(Theme.Provider, { value: this.getThemeMode },
            React.createElement(ThemeProvider, { theme: theme },
                React.createElement(LegacyReset, { background: this.props.background }, children))));
    }
}
AtlaskitThemeProvider.defaultProps = {
    mode: DEFAULT_THEME_MODE,
    background: colors.background,
};
AtlaskitThemeProvider.childContextTypes = {
    hasAtlaskitThemeProvider: PropTypes.bool,
};
AtlaskitThemeProvider.contextTypes = {
    hasAtlaskitThemeProvider: PropTypes.bool,
};
//# sourceMappingURL=AtlaskitThemeProvider.js.map