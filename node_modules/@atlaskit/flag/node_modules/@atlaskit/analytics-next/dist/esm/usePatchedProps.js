import { __assign, __read, __spread } from "tslib";
import { useMemo } from 'react';
import { useAnalyticsEvents } from './useAnalyticsEvents';
export function usePatchedProps(createEventMap, wrappedComponentProps) {
    if (createEventMap === void 0) { createEventMap = {}; }
    var createAnalyticsEvent = useAnalyticsEvents().createAnalyticsEvent;
    var patchedProps = useMemo(function () {
        return Object.keys(createEventMap).reduce(function (p, k) {
            var _a;
            var eventCreator = createEventMap[k];
            if (!['object', 'function'].includes(typeof eventCreator)) {
                return p;
            }
            var propValue = wrappedComponentProps[k];
            var wrappedCallback = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var analyticsEvent = typeof eventCreator === 'function'
                    ? eventCreator(createAnalyticsEvent, wrappedComponentProps)
                    : createAnalyticsEvent(eventCreator);
                if (propValue && typeof propValue === 'function') {
                    propValue.apply(void 0, __spread(args, [analyticsEvent]));
                }
            };
            return wrappedCallback ? __assign(__assign({}, p), (_a = {}, _a[k] = wrappedCallback, _a)) : p;
        }, {});
    }, [createEventMap, wrappedComponentProps, createAnalyticsEvent]);
    return {
        patchedEventProps: patchedProps,
    };
}
//# sourceMappingURL=usePatchedProps.js.map