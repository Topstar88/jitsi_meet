'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _indexMin = require('../../popper/index-min');

var _indexMin2 = _interopRequireDefault(_indexMin);

var _helpers = require('./internal/helpers');

var _styledContentContainer = require('../styledContentContainer');

var _styledContentContainer2 = _interopRequireDefault(_styledContentContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable react/no-unused-prop-types */

var Layer = function (_Component) {
  (0, _inherits3.default)(Layer, _Component);

  function Layer(props) {
    (0, _classCallCheck3.default)(this, Layer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Layer.__proto__ || (0, _getPrototypeOf2.default)(Layer)).call(this, props));

    _this.extractStyles = function (state) {
      if (state) {
        var popperHeight = state.offsets.popper.height;
        var left = Math.round(state.offsets.popper.left);
        // The offset position is sometimes an object and sometimes just a string...
        var _cssPosition = (0, _typeof3.default)(state.offsets.popper.position) === 'object' ? state.offsets.popper.position.position : state.offsets.popper.position;
        var top = _this.fixPositionTopUnderflow(state.offsets.popper.top, _cssPosition);

        var _originalHeight = _this.state.originalHeight || popperHeight;
        var _maxHeight = _this.calculateMaxHeight(_originalHeight, popperHeight, top, _cssPosition);
        _this.setState({
          // position: fixed or absolute
          cssPosition: _cssPosition,
          hasExtractedStyles: true,
          transform: 'translate3d(' + left + 'px, ' + top + 'px, 0px)',
          // state.flipped is either true or undefined
          flipped: !!state.flipped,
          actualPosition: state.position,
          originalPosition: state.originalPosition,
          originalHeight: _originalHeight,
          maxHeight: _maxHeight
        });
      }
    };

    _this.state = {
      hasExtractedStyles: false,
      position: null,
      transform: null,
      flipped: false,
      actualPosition: null,
      // We set these default offsets to prevent a flash of popper content in the wrong position
      // which can cause incorrect height calculations. Popper will calculate these values
      offsets: {
        popper: {
          left: -9999,
          top: -9999
        }
      },
      originalPosition: null,
      // fix Safari parent width: https://product-fabric.atlassian.net/browse/ED-1784
      cssPosition: 'absolute',
      originalHeight: null,
      maxHeight: null
    };
    _this.extractStyles = _this.extractStyles.bind(_this);
    return _this;
  }

  // TODO: get the value of zIndex from theme, not using it now as it is not
  // working with extract-react-types


  (0, _createClass3.default)(Layer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.applyPopper(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.applyPopper(nextProps);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.flipped !== this.state.flipped && this.props.onFlippedChange) {
        this.props.onFlippedChange({
          flipped: this.state.flipped,
          actualPosition: this.state.actualPosition,
          originalPosition: this.state.originalPosition
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.popper) {
        this.popper.destroy();
      }
    }

    /* Calculate the max height of the popper if it's height is greater than the viewport to prevent
     * the bottom of the popper not being viewable.
     * Only works if the popper uses viewport as the boundary and has a fixed position ancestor.
     */

  }, {
    key: 'calculateMaxHeight',
    value: function calculateMaxHeight(originalHeight, currentHeight, positionTop, cssPosition) {
      var DocumentElementClientHeight = 0;

      if (document.documentElement) {
        DocumentElementClientHeight = document.documentElement.clientHeight;
      }
      if (cssPosition !== 'fixed' || this.props.boundariesElement !== 'viewport') {
        return null;
      }
      var viewportHeight = Math.max(DocumentElementClientHeight, window.innerHeight || 0);
      return viewportHeight < originalHeight && currentHeight + positionTop >= viewportHeight - 50 ? // allow some spacing either side of viewport height
      viewportHeight - 12 : null;
    }

    /* Clamp fixed position to the window for fixed position poppers that flow off the top of the
     * window.
     * A fixed position popper is a popper who has an ancestor with position: fixed.
     *
     * It is too difficult to fix this for non-fixed position poppers without re-implementing popper's
     * offset functionality or fixing the issue upstream.
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'fixPositionTopUnderflow',
    value: function fixPositionTopUnderflow(popperTop, cssPosition) {
      return popperTop >= 0 || cssPosition !== 'fixed' ? Math.round(popperTop) : 0;
    }
  }, {
    key: 'applyPopper',
    value: function applyPopper(props) {
      if (!this.targetRef || !this.contentRef) {
        return;
      }

      if (this.popper) {
        this.popper.destroy();
      }

      // "new Popper(...)" operation is very expensive when called on virtual DOM.
      // This condition reduces the number of calls so we can run our tests faster
      // (time was reduced from 100s to 13s).
      if (!props.content) {
        return;
      }

      // we wrap our target in a div so that we can safely get a reference to it, but we pass the
      // actual target to popper
      var actualTarget = this.targetRef.firstChild;
      var popperOpts = {
        placement: (0, _helpers.positionPropToPopperPosition)(props.position),
        onCreate: this.extractStyles,
        onUpdate: this.extractStyles,
        modifiers: {
          applyStyle: {
            enabled: false
          },
          hide: {
            enabled: false
          },
          offset: {
            enabled: true,
            offset: this.props.offset
          },
          flip: {
            enabled: !!this.props.autoFlip,
            flipVariations: true,
            boundariesElement: this.props.boundariesElement,
            padding: 0 // leave 0 pixels between popper and the boundariesElement
          },
          preventOverflow: {
            enabled: !!this.props.autoFlip,
            escapeWithReference: !(this.props.boundariesElement === 'scrollParent')
          }
        }
      };

      var flipBehavior = (0, _helpers.getFlipBehavior)(props);
      if (flipBehavior) {
        popperOpts.modifiers.flip.behavior = flipBehavior;
      }

      this.popper = new _indexMin2.default(actualTarget, this.contentRef, popperOpts);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var zIndex = this.props.zIndex;
      var _state = this.state,
          cssPosition = _state.cssPosition,
          transform = _state.transform,
          hasExtractedStyles = _state.hasExtractedStyles,
          maxHeight = _state.maxHeight;

      var opacity = hasExtractedStyles ? {} : { opacity: 0 };

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
          'div',
          {
            ref: function ref(_ref) {
              _this2.targetRef = _ref;
            }
          },
          this.props.children
        ),
        _react2.default.createElement(
          _styledContentContainer2.default,
          { maxHeight: maxHeight },
          _react2.default.createElement(
            'div',
            {
              ref: function ref(_ref2) {
                _this2.contentRef = _ref2;
              },
              style: (0, _extends3.default)({
                top: 0,
                left: 0,
                position: cssPosition,
                transform: transform,
                zIndex: zIndex
              }, opacity)
            },
            this.props.content
          )
        )
      );
    }
  }]);
  return Layer;
}(_react.Component);

/* eslint-enable react/no-unused-prop-types */


Layer.defaultProps = {
  autoFlip: true,
  boundariesElement: 'viewport',
  children: null,
  content: null,
  offset: '0 0',
  onFlippedChange: function onFlippedChange() {},
  position: 'right middle',
  zIndex: 400
};
exports.default = Layer;